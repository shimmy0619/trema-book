<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<!DOCTYPE book [<!ENTITY % db5ent PUBLIC "-//FOPUB//ENTITIES Entities for DocBook 5" "db5.ent"> %db5ent;]>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>TremaでOpenFlowプログラミング</title>
<date>2016-02-23</date>
<authorgroup>
<author>
<personname>
<firstname>高宮</firstname>
<surname>安仁</surname>
</personname>
<email>yasuhito@gmail.com</email>
</author>
<author>
<personname>
<firstname>鈴木</firstname>
<surname>一哉</surname>
</personname>
</author>
<author>
<personname>
<firstname>松井</firstname>
<surname>暢之</surname>
</personname>
</author>
<author>
<personname>
<firstname>村木</firstname>
<surname>暢哉</surname>
</personname>
</author>
<author>
<personname>
<firstname>山崎</firstname>
<surname>泰宏</surname>
</personname>
</author>
</authorgroup>
</info>
<chapter xml:id="_はじめに">
<title>はじめに</title>
<simpara><link xl:href="https://github.com/trema/trema">Trema</link>を使ったOpenFlowプログラミングを解説するフリー書籍です。対応スイッチの多いOpenFlowバージョン1.3.xを対象にしています。プログラミング言語はRubyバージョン2.0以降です。</simpara>
<itemizedlist>
<listitem>
<simpara>ブラウザで読む: <link xl:href="https://yasuhito.github.com/trema-book/">https://yasuhito.github.com/trema-book/</link></simpara>
</listitem>
<listitem>
<simpara>PDFで読む: (準備中)</simpara>
</listitem>
<listitem>
<simpara>GitHubのプロジェクトページ: <link xl:href="https://github.com/yasuhito/trema-book">https://github.com/yasuhito/trema-book</link></simpara>
</listitem>
<listitem>
<simpara>Twitterのハッシュタグ: <link xl:href="https://twitter.com/hashtag/Trema%E6%9C%AC">#Trema本</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="_書籍版">
<title>書籍版</title>
<simpara>各種書店で入手可能です。もちろん、プロによる組版なので高品質です。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.github.com/yasuhito/trema-book/develop/images/cover.png"/>
</imageobject>
<textobject><phrase>本のカバー</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>正誤表など技術評論社のサポートページは <link xl:href="https://gihyo.jp/book/2016/978-4-7741-7983-4">こちら</link>です</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://www.amazon.co.jp/o/ASIN/4774179833/">Amazonで購入</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.yodobashi.com/-増補改訂版-クラウド時代のネットワーク技術-OpenFlow実践入門-Software-Design-plus-単行本/pd/100000009002526970/">ヨドバシ.comで購入</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://7net.omni7.jp/detail_isbn/978-4-7741-7983-4">7netショッピングで購入</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://honto.jp/netstore/pd-book_27703803.html">hontoで購入</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_フリー版">
<title>フリー版</title>
<simpara>次のようにしてソースから本をビルドできます。</simpara>
<screen>git clone git@github.com:yasuhito/trema-book.git
cd trema-book
bundle install
bundle exec rake</screen>
</section>
<section xml:id="_執筆に参加する">
<title>執筆に参加する</title>
<simpara>誰でもいろいろな形でTrema本の執筆に参加できます。</simpara>
<simpara>本に関する雑談は <link xl:href="https://gitter.im/yasuhito/trema-book">Gitterのチャット</link>でどうぞ。</simpara>
<simpara>もし誤字脱字を見つけたら、GitHubでイシューを切ってもらうか、ソースコードを直接修正してPull Requestを出してもらえると助かります。もちろん、内容についてのコメントや追加内容も歓迎します。</simpara>
<simpara>原稿の書式は <link xl:href="http://asciidoc.org/">Asciidoc</link>です。詳しい書き方についてはAsciidocのコンパイラである <link xl:href="http://asciidoctor.org/docs/user-manual/">Asciidoctorのユーザマニュアル</link>を参照してください。</simpara>
<simpara>貢献していただいた方は書籍版の「謝辞」にもれなくお名前が載ります。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.github.com/yasuhito/trema-book/develop/images/acknowledgements.jpg"/>
</imageobject>
<textobject><phrase>謝辞</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_ライセンス">
<title>ライセンス</title>
<simpara>This book is released under the GNU General Public License version 3.0:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://www.gnu.org/licenses/gpl-3.0.html">http://www.gnu.org/licenses/gpl-3.0.html</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="how_does_openflow_work">
<title>OpenFlow の仕組み</title>
<simpara role="lead">ネットワークを OpenFlow で構築すると、どんな利点があるのでしょうか。その答えは、<emphasis role="strong">ソフトウェアによる自動化</emphasis>です。まずは身近な自動化の例を見ていきましょう。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/how_does_openflow_work/incredible_machine.png"/>
</imageobject>
<textobject><phrase>incredible machine</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_ソフトウェアで楽をする">
<title>ソフトウェアで楽をする</title>
<blockquote>
<attribution>
Larry Wall
<citetitle>『プログラミング Perl』(オーム社)</citetitle>
</attribution>
<simpara>無精 (Laziness): エネルギーの総支出を減らすために、多大な努力をするように、あなたをかりたてる性質。こうして労力を省くために書いたプログラムは他人も使うようになり、そのプログラムに関する質問にいちいち答えずに済ますためにドキュメントを書くようになる。それゆえ、プログラマにとってもっとも重要な素質である。またそれゆえ、この本が存在するのである。</simpara>
</blockquote>
<simpara>優れたプログラマが持つハッカー気質の 1 つに<emphasis role="strong">無精</emphasis>があります。「大好きなコンピュータの前から一時も離れずに、どうやってジャンクフードにありつこう。そうだ、ソフトウェアを書けばできるじゃないか!」普通の人からするとただの横着に見えるかもしれません。しかし、ハッカーにとってはいつでも大きな問題なのです。</simpara>
<simpara>ソフトウェアによる横着は、ハッカーがもっとも創造性を発揮する分野の 1 つです。時間のかかる面倒な仕事も、ハッカーにかかれば気の利いたスクリプトひとつで自動化してしまいます。ハッカーによる次の 3 つの伝説的な逸話は、いずれもただ横着のためだけに高い技術力を駆使したといういい例です。</simpara>
<variablelist>
<varlistentry>
<term>ピザ注文コマンド</term>
<listitem>
<simpara>ハッカーの巣窟として有名な MIT の AI ラボにはかつて、コンピュータからオンラインでピザを注文できる UNIX コマンドが存在しました<footnote><simpara>MIT の <literal>xpizza</literal> コマンドのマニュアル: <link xl:href="https://stuff.mit.edu/afs/sipb/project/lnf/other/CONTRIB/ai-info">https://stuff.mit.edu/afs/sipb/project/lnf/other/CONTRIB/ai-info</link></simpara></footnote>。ハックしていて腹が減ったらコマンドを叩いてピザを取る。なんとも横着です。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>自販機のリモート監視</term>
<listitem>
<simpara>コンピュータサイエンスの名門、カーネギーメロン大学にはコーク・マシンという変わったコーラ自販機がかつてあり、UNIX コマンド一発でコーラの冷え具合を確認できるようになっていました<footnote><simpara>カーネギーメロン大学のコーク・マシンのサイト: <link xl:href="http://www.cs.cmu.edu/~coke/">http://www.cs.cmu.edu/~coke/</link></simpara></footnote>。わざわざ遠くの自販機まで行ったのにぬるいコーラをつかまされた、なんてことが起きないようにするための工夫です。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>コーヒーポットプロトコル</term>
<listitem>
<simpara>RFC (Request For Comment) 2324 のコーヒーポットプロトコルは、遠隔地にあるコーヒーポットのコーヒーの量を監視したり、コーヒーを自動的にいれたりするための半分冗談の HTTP メッセージを定義しています<footnote><simpara>RFC 2324: <link xl:href="https://www.ietf.org/rfc/rfc2324.txt">https://www.ietf.org/rfc/rfc2324.txt</link></simpara></footnote>。いわゆるジョーク RFC にもかかわらず、本当に実装してしまった人もいたそうですから驚きです。</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>こうした<emphasis role="strong">ソフトウェアで楽をする</emphasis>ハックの中でも、もっとも大規模な例が最新鋭のデータセンターです。クラウドサービスの裏で動く巨大なデータセンターは、大部分の管理作業をソフトウェアによって極限まで自動化しています。このおかげで、極めて少人数のエンジニアによる運用を可能にしています。</simpara>
<simpara>このように、ピザの注文やコーラ自販機、コーヒーポットといったお遊びから、データセンターのように一筋縄ではいかない相手まで、ソフトウェアを書けばその大部分を自動化できます。そして何より、<emphasis role="strong">ソフトウェアでモノを思いどおりにコントロールする</emphasis>のは楽しく、かつ実際に役立ちます。</simpara>
<note>
<simpara>こうした最新鋭データセンターでのネットワーク管理自動化の仕組みは、<link linkend="routing_switch">16 章「たくさんのスイッチを制御する」</link>および<link linkend="sliceable_switch">17 章「ネットワークを仮想化する」</link>で詳しく解説します。</simpara>
</note>
</section>
<section xml:id="_ネットワークもソフトウェア制御">
<title>ネットワークもソフトウェア制御</title>
<simpara>ネットワークをソフトウェア制御する技術の 1 つが OpenFlow です。より正確に言えば、OpenFlow とはネットワークスイッチの動作を制御するための標準プロトコルの 1 つです。OpenFlow を使えばスイッチ 1 つひとつの動作をソフトウェアから自由に書き換えられるので、究極的にはネットワーク全体の動作をソースコードとして記述できます。これを <emphasis role="strong">Software Defined Networking</emphasis> (ソフトウェアで定義されるネットワーク。以下 <emphasis role="strong">SDN</emphasis> と略す) と呼び、OpenFlow は SDN を実現する代表的な技術として注目を集めています。</simpara>
<simpara>OpenFlow の登場によって、これからはネットワークインフラもプログラミングの対象になります。「いまだに手で管理してるの? そんなのソフトウェアで自動化しようぜ!」ハッカーのこんな声が聞こえてきそうです。たしかに、今までネットワーク管理と言えば専門のオペレータによる手作業がメインでした。横着できる部分はまだまだたくさんあるはずです。</simpara>
<simpara>OpenFlow を使えば、次のような究極の自動化も夢ではなくなります。</simpara>
<itemizedlist>
<listitem>
<simpara>スイッチの障害やネットワーク構成の変化など、あらゆる情報を自動収集するネットワーク</simpara>
</listitem>
<listitem>
<simpara>ユーザ／サーバ／スイッチの追加や削除に応じて、自動的に構成を変更するネットワーク</simpara>
</listitem>
<listitem>
<simpara>追加投資をしなくても、既存のインフラを目一杯まで使ってスケールするネットワーク</simpara>
</listitem>
</itemizedlist>
<simpara>本書はこれらすべてのトピックを扱います。自宅や職場のような中小規模ネットワークからデータセンターのような超大規模ネットワークまで、実例を交じえながら「OpenFlow ってどんなもので、具体的に何に使えるのだろう?」という素朴な疑問に答えていきます。そして実際に動かしながら理解できるように、各章では実用的なソースコードを解説しています。</simpara>
<simpara>本書を読み進めるにあたって、ネットワークやプログラミングの深い知識は不要です。基本から 1 つひとつ説明しますので、ネットワークの専門家はもちろん、プログラマやシステムエンジニア、そして営業職や管理職などなど OpenFlow に興味を持つ方であれば誰でもすんなり理解できるように構成してあります。</simpara>
<simpara>ではさっそく、OpenFlow で構築したネットワークがどう動くかを見て行きましょう。</simpara>
</section>
<section xml:id="_openflow_の動作モデル">
<title>OpenFlow の動作モデル</title>
<simpara>OpenFlow の仕組みを理解するために、ちょっとした<emphasis role="strong">たとえ話</emphasis>から始めます。みなさんもきっと利用したことがある、電話のカスタマーサポートサービスを思い浮かべてください。そう、テレビとかパソコンの調子が悪くなったときに、フリーダイヤルで相談するアレです。でもそれって、OpenFlow とどう関係するのでしょう?</simpara>
<simpara>実は OpenFlow の基本的な仕組みはカスタマーサポートにとてもよく似ているのです。これからお話しするストーリーがわかれば、OpenFlow の 95% を理解できたも同然です。</simpara>
<simpara>それでは、このストーリーの主人公の友太郎 (ゆうたろう) 君と、カスタマーサポートセンターで働く青井さん、そして上司の宮坂部長の 3 人に登場してもらいましょう。</simpara>
<section xml:id="_ストーリー_1_エアコンが壊れた">
<title>ストーリー 1: エアコンが壊れた</title>
<simpara>今年もエアコンの活躍する季節がやってきました。</simpara>
<simpara>ところが友太郎君のエアコンはどうにも調子がよくありません。取扱説明書に載っていたカスタマーサポートに電話し、自動音声に従ってしばし自分で直そうとしてみたものの、いっこうに解決しません。</simpara>
<simpara>結局、自動音声はあきらめて電話サポートに相談することにしました。</simpara>
<simpara>「はい、こちらカスタマーサポートセンターです。担当はわたくし青井がうけたまわります。ご要件は何でしょうか？」</simpara>
<simpara>青井さんはヨーヨーダイン・エアコン社で働く電話オペレータです。青井さんの普段のオペレータ業務は、主に次の 2 つです (<link linkend="yoyodyne_support">図1-1</link>)。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>お客さんから不具合の症状を聞き出す</simpara>
</listitem>
<listitem>
<simpara>症状の内容に応じてそれぞれの担当技術サポートに電話をつなぐ</simpara>
</listitem>
</orderedlist>
<figure xml:id="yoyodyne_support">
<title>電話オペレータはお客さんからの問い合わせを適切な技術サポートへ転送</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/how_does_openflow_work/yoyodyne_support.png"/>
</imageobject>
<textobject><phrase>yoyodyne support</phrase></textobject>
</mediaobject>
</figure>
<simpara>友太郎君は聞きます。</simpara>
<simpara>「なんだかリモコンの調子が悪いんです。温度表示がずっと点滅してるんですけど、どうしたら直りますか？」</simpara>
<simpara>青井さんは手元の対応マニュアルを開きます (<link linkend="operator_manual">表 1-1</link>)。対応マニュアルには 3 つの項目があり、お客さんからの「問い合わせ内容」、電話オペレータの「対応方法」、そしてお客さんからの「問い合わせ件数」を調べられるようになっています。</simpara>
<table xml:id="operator_manual" frame="all" rowsep="1" colsep="1">
<title>表 1-1: 電話オペレータ用対応マニュアル</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">問い合わせ内容</entry>
<entry align="left" valign="top">対応方法</entry>
<entry align="left" valign="top">問い合わせ件数</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">リモコンの不調</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">周辺機器担当の技術サポートに転送</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">8 件</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>エアコン本体の不調</simpara></entry>
<entry align="left" valign="top"><simpara>エアコン担当の技術サポートに転送</simpara></entry>
<entry align="left" valign="top"><simpara>6 件</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>室外機の不調</simpara></entry>
<entry align="left" valign="top"><simpara>周辺機器担当の技術サポートに転送</simpara></entry>
<entry align="left" valign="top"><simpara>4 件</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>いたずら電話</simpara></entry>
<entry align="left" valign="top"><simpara>電話を切る</simpara></entry>
<entry align="left" valign="top"><simpara>2 件</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>青井さんはちょうどマニュアルの先頭に、探していた「リモコンの不調」の項目を見つけました。</simpara>
<simpara>「ご不便をおかけしました。リモコン担当の技術サポートにただいまお繋ぎいたします」</simpara>
<simpara>電話の転送を終えると、青井さんはリモコン不調の問い合わせ件数を 8 件から 9 件にアップデートしました (<link linkend="operator_manual_update">表 1-2</link>)。</simpara>
<table xml:id="operator_manual_update" frame="all" rowsep="1" colsep="1">
<title>表 1-2: 対応マニュアルの「問い合わせ件数」をアップデートする</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">問い合わせ内容</entry>
<entry align="left" valign="top">対応方法</entry>
<entry align="left" valign="top">問い合わせ件数</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>リモコンの不調</simpara></entry>
<entry align="left" valign="top"><simpara>周辺機器担当の技術サポートに転送</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">9 件</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>エアコン本体の不調</simpara></entry>
<entry align="left" valign="top"><simpara>エアコン担当の技術サポートに転送</simpara></entry>
<entry align="left" valign="top"><simpara>6 件</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>室外機の不調</simpara></entry>
<entry align="left" valign="top"><simpara>周辺機器担当の技術サポートに転送</simpara></entry>
<entry align="left" valign="top"><simpara>4 件</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>いたずら電話</simpara></entry>
<entry align="left" valign="top"><simpara>電話を切る</simpara></entry>
<entry align="left" valign="top"><simpara>2 件</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>このように問い合わせ件数を控えておくことで、どんな故障が多いかを上司にフィードバックできます。たとえばリモコンに関する問い合わせが多ければ、上司は次の製品開発で「リモコンを改良せよ」という指示を飛ばせます。あるいは、周辺機器担当の技術サポートメンバーをもっと増やそうという判断もできます。</simpara>
</section>
<section xml:id="_openflow_に置き換えると">
<title>OpenFlow に置き換えると</title>
<simpara>OpenFlow の世界では、パケットを送信するホストがお客さんの友太郎君、パケットを転送する OpenFlow スイッチが電話オペレータの青井さんに対応します (<link linkend="openflow_host_switch">図 1-2</link>)。ホストがパケットを送ると、OpenFlow スイッチはパケットの中身に応じてパケットを適切に処理します。これはちょうど、青井さんが友太郎君からの問い合わせ内容に応じ、適切な技術サポートに電話を転送するのと同じです。</simpara>
<figure xml:id="openflow_host_switch">
<title>OpenFlow ではホストがお客さん、スイッチが電話オペレータ、そしてフローテーブルがマニュアルに対応</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/how_does_openflow_work/openflow_host_switch.png"/>
</imageobject>
<textobject><phrase>openflow host switch</phrase></textobject>
</mediaobject>
</figure>
<simpara>OpenFlow スイッチは、動作が<emphasis role="strong">マニュアル化</emphasis>されています。カスタマーサポートの例では、青井さんはマニュアルから対応方法を調べました。いっぽう OpenFlow スイッチでは、スイッチ内の<emphasis role="strong">フローテーブル</emphasis>からパケットの処理方法を調べます。フローテーブルとは一種のデータベースで、パケットごとの処理方法が入っています。青井さんの業務がすべてマニュアル化されているのと同じく、OpenFlowスイッチの動作はすべてこのフローテーブルの内容によって決まります。</simpara>
</section>
<section xml:id="_フローテーブルとフローエントリ">
<title>フローテーブルとフローエントリ</title>
<simpara>フローテーブルには、「こういうパケットが届いたら、こう処理する」というルールがいくつか入っています。このルールを<emphasis role="strong">フローエントリ</emphasis>と呼びます。フローエントリはちょうど「リモコンの故障に関する問い合わせがきたら、リモコン担当の技術サポートに電話を転送する」といったマニュアルの各項目に対応します。</simpara>
<simpara>実際のフローテーブルの例を見てみましょう。<link linkend="flow_table_entry">表 1-3</link> はあるスイッチのフローテーブルで、各行がフローエントリです。フローエントリは主に、マッチフィールド・アクション・カウンタの 3 つの要素からなります<footnote><simpara>実際にはアクションはインストラクションという要素の一部です。アクションとインストラクションの関係について、詳しくは<link linkend="openflow_spec">2章「OpenFlow の仕様」</link>で詳しく説明します</simpara></footnote>。</simpara>
<table xml:id="flow_table_entry" frame="all" rowsep="1" colsep="1">
<title>表 1-3: フローテーブルとフローエントリの例</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">マッチフィールド</entry>
<entry align="left" valign="top">アクション</entry>
<entry align="left" valign="top">カウンタ</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>送信元 IP アドレス = 192.168.1.0</simpara></entry>
<entry align="left" valign="top"><simpara>ポート 8 番に転送</simpara></entry>
<entry align="left" valign="top"><simpara>80 パケット</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>VLAN ID = 10</simpara></entry>
<entry align="left" valign="top"><simpara>ポート 10 番に転送</simpara></entry>
<entry align="left" valign="top"><simpara>64 パケット</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>送信元 MAC アドレス = 00:50:56:c0:00:08</simpara></entry>
<entry align="left" valign="top"><simpara>VLAN ID = 2 を付けてポート 8 番に転送</simpara></entry>
<entry align="left" valign="top"><simpara>24 パケット</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>送信元 IP アドレス = 203.0.113.0/16</simpara></entry>
<entry align="left" valign="top"><simpara>パケットを破棄</simpara></entry>
<entry align="left" valign="top"><simpara>10 パケット</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<variablelist>
<varlistentry>
<term>マッチフィールド</term>
<listitem>
<simpara>届いたパケットに対応するフローエントリを探すための<emphasis role="strong">条件</emphasis>です。たとえば「リモコンの調子がおかしい」という問い合わせ内容と同じく、マッチフィールドには「送信元 IP アドレス = 192.168.1.0」などと指定します。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>アクション</term>
<listitem>
<simpara>届いたパケットをどう処理するかという<emphasis role="strong">処理方法</emphasis>にあたります。たとえば「リモコン担当の技術サポートへ引き継ぎ」という対応方法と同じく、アクションには「スイッチのポート 8 番に転送」などと指定します。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>カウンタ</term>
<listitem>
<simpara>フローエントリごとの<emphasis role="strong">パケット処理量</emphasis>を記録します。たとえば「リモコン関連の問い合わせ数は 9 件」とマニュアルに記録したように、「このフローエントリに従って処理したパケットは 80 個」といった情報が入ります。</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>このように、実は OpenFlow はとても単純で理解しやすい仕組みです。</simpara>
</section>
<section xml:id="_ストーリー_2_エアコンがまたまた故障">
<title>ストーリー 2: エアコンがまたまた故障</title>
<simpara>エアコンもしばらくは順調でしたが、1 ヶ月後また調子が悪くなってしまいました。友太郎君は再びカスタマーサポートへダイヤルします。</simpara>
<simpara>「エアコンの排水ホースがすぐ詰まっちゃうんです」</simpara>
<simpara>どうやらまったく新しい不具合のようです。青井さんはいつものように手元の対応マニュアルを調べましたが、困ったことに排水ホースの項目は載っていません。</simpara>
<simpara>「申し訳ございませんが少々お待ちください。対応可能な技術サポートがいるかどうか確認いたします」</simpara>
<simpara>そして電話口にはどこか軽快な音楽と、「しばらくお待ちください」のメッセージが繰り返し流れはじめました。</simpara>
<figure xml:id="yoyodyne_support_miyasaka">
<title>対応マニュアルに対処法が見つからなかった場合、上司に聞く</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/how_does_openflow_work/yoyodyne_support_miyasaka.png"/>
</imageobject>
<textobject><phrase>yoyodyne support miyasaka</phrase></textobject>
</mediaobject>
</figure>
<simpara>こういうとき、青井さんがいつも頼るのは上司の宮坂部長です (<link linkend="yoyodyne_support_miyasaka">図1-3</link>)。</simpara>
<simpara>「宮坂さん、排水ホースについての問い合わせがきたのですが、どの技術サポートにつなげばよいですか？」</simpara>
<simpara>「それだったら消耗品技術サポートだよ」</simpara>
<simpara>転送先がわかった青井さんは、友太郎君の待つ電話に戻ります。</simpara>
<simpara>「大変お待たせいたしました。担当の技術サポートに転送いたします」</simpara>
<simpara>一度目の問い合わせと比べてかなり時間がかかってしまいましたが、これでようやく一件落着です。青井さんは忘れないうちに、宮坂部長から教わった消耗品技術サポートの連絡先をマニュアルに追加します (<link linkend="operator_manual_add_row">表 1-4</link>)。もしも同じ問い合わせがきた場合には、素早く答えられるようにするためです。</simpara>
<table xml:id="operator_manual_add_row" frame="all" rowsep="1" colsep="1">
<title>表 1-4: マニュアルに新しい項目を追加してアップデートする</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">問い合わせ内容</entry>
<entry align="left" valign="top">対応方法</entry>
<entry align="left" valign="top">問い合わせ件数</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>リモコンの不調</simpara></entry>
<entry align="left" valign="top"><simpara>周辺機器担当の技術サポートに転送</simpara></entry>
<entry align="left" valign="top"><simpara>9 件</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>エアコン本体の不調</simpara></entry>
<entry align="left" valign="top"><simpara>エアコン担当の技術サポートに転送</simpara></entry>
<entry align="left" valign="top"><simpara>6 件</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>室外機の不調</simpara></entry>
<entry align="left" valign="top"><simpara>周辺機器担当の技術サポートに転送</simpara></entry>
<entry align="left" valign="top"><simpara>4 件</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>いたずら電話</simpara></entry>
<entry align="left" valign="top"><simpara>電話を切る</simpara></entry>
<entry align="left" valign="top"><simpara>2 件</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">排水ホースの不調</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">消耗品担当の技術サポートに転送</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">1 件</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="_openflow_に置き換えると_2">
<title>OpenFlow に置き換えると</title>
<simpara>OpenFlow でこの上司にあたるのが、<emphasis role="strong">コントローラ</emphasis>と呼ばれるソフトウェアです (<link linkend="openflow_host_switch_controller">図 1-4</link>)。フローテーブルに載っていないパケットがスイッチに届くと、スイッチは「このパケットはどうすればよいですか」とコントローラに指示をあおぎます。コントローラはパケットの中身を調べ、どうすべきかという指示、つまり新しいフローエントリをフローテーブルに書き込みます。</simpara>
<figure xml:id="openflow_host_switch_controller">
<title>フローテーブルにエントリーが見つからなかった場合、コントローラに問い合わせる</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/how_does_openflow_work/openflow_host_switch_controller.png"/>
</imageobject>
<textobject><phrase>openflow host switch controller</phrase></textobject>
</mediaobject>
</figure>
<simpara>当然ながら、コントローラへの問い合わせが発生するとパケット転送が遅くなります。そこで、あらかじめ必要とわかっているフローエントリは、スイッチの起動時に書き込んでおくようにします。そうすれば、スイッチ側でパケットを素早く処理できます。</simpara>
<simpara>OpenFlow でネットワークインフラをプログラミングする場合、プログラマが書くのはこのコントローラです。頭脳であるコントローラをソフトウェアとして記述することで、ネットワークを自由自在に制御できるというわけです。ただし、スイッチからの問い合わせをあまり発生させずに効率良くパケット転送できるかどうかは、すべてコントローラの設計にかかっています。</simpara>
</section>
</section>
</section>
<section xml:id="_openflow_のうれしさ">
<title>OpenFlow のうれしさ</title>
<simpara>OpenFlow の大枠が理解できたところで、OpenFlow の利点を具体的に見ていきましょう。</simpara>
<section xml:id="_自動化やシステム連携がしやすい">
<title>自動化やシステム連携がしやすい</title>
<simpara>カスタマーサポートセンターでは、お客さん対応はすべて電話オペレータがやってくれます。上司があらかじめ適切なマニュアルを作っておけば、あとはほとんどの仕事を電話オペレータにおまかせできるのです。これによって、電話オペレータが対応している間、管理職は他の部署との連携に集中できます。</simpara>
<simpara>OpenFlow では上司であるコントローラ自体をソフトウェアとして書けるので、ネットワークだけでなくその管理も自動化できます。さらにコントローラが Ruby や Python、Java などの汎用言語で書いてあれば、既存のシステムやサービスとの連携も簡単です。たとえば、アプリケーションからの要求やビジネスポリシーの変更、問題発生などさまざまなトリガーに応じてネットワークの設定を変更するといった、一歩進んだ自動化もできます。</simpara>
<note>
<simpara>システム連携の一例として、コントローラに REST API を実装する方法を<link linkend="sliceable_switch">17 章「ネットワークを仮想化する」</link>で解説します。また、実際のデータセンターでのコントローラと各種サービスの連携については、<link linkend="openvnet">18 章「OpenVNet で本格的な仮想ネットワーク」</link>で紹介します。</simpara>
</note>
</section>
<section xml:id="_ネットワークトラフィックを集中制御しやすい">
<title>ネットワークトラフィックを集中制御しやすい</title>
<simpara>カスタマーサポートセンターでは問い合わせ件数の情報はすべて上司に上がってくるため、混み具合の把握や全体の交通整理が楽です。もし特定の技術サポートに問い合わせが集中しても、問い合わせがうまくバラけるようにマニュアルを通じて電話オペレータの全員に指示できます。反対にもし各オペレータが個々に判断してしまうと、おなじ技術サポートに問い合わせが偏ることは避けられません。</simpara>
<simpara>OpenFlow でもすべての情報はコントローラに上がってくるため、全体を見たトラフィックの最適化が可能です。フローエンントリ内のカウンタを集計し、検出したスイッチの接続関係 (ネットワークトポロジ) と突き合わせることで、コントローラはネットワーク全体のトラフィックを把握できます。そしてその情報をもとに各スイッチのフローテーブルを更新することで、全体的に見て最適となるパケットの通り道を引けます。反対に、もし個々のスイッチが判断してしまうと、効率的にトラフィックを分散できません。</simpara>
<note>
<simpara>各種カウンタの収集方法については<link linkend="switch_monitor">4 章「スイッチ監視ツール」</link>で、ネットワークトポロジの検出方法については<link linkend="topology">15 章「ネットワークトポロジを検出する」</link>で、またトラフィックの分散方法については<link linkend="routing_switch">16 章「たくさんのスイッチを制御する」</link>で解説します。</simpara>
</note>
</section>
<section xml:id="_ソフトウェア開発のテクニックやツールが使える">
<title>ソフトウェア開発のテクニックやツールが使える</title>
<simpara>コントローラはソフトウェアの一種なので、ソフトウェア開発で長年培われているさまざまなテクニックやツールをネットワーク構築に応用できます。</simpara>
<simpara>たとえば近年主流のアジャイル開発手法でコントローラを開発すれば、反復的な機能追加が可能です。ユーザからのフィードバックを受けながら少しずつバージョンアップしてくことで、ネットワークを段階的に構築できます。</simpara>
<simpara>またコントローラのテストコードを書くことで、ネットワーク全体を自動的にテストできます。テストコードやテスト結果の出力は、そのまま仕様書の一部として使えます。もう Excel や Word で書いた仕様書を別個に管理する必要はありません。</simpara>
<note>
<simpara>アジャイル開発手法やソフトウェアテストによるコントローラ開発については、<link linkend="tdd">9 章「Trema でテスト駆動開発」</link>で解説します。</simpara>
</note>
</section>
<section xml:id="_アップグレード方法の選択肢が広がる">
<title>アップグレード方法の選択肢が広がる</title>
<simpara>従来のネットワーク機器を OpenFlow コントローラで置き換えれば、アップグレード方法の選択肢が広がります。従来のスイッチ・ルータ・ファイアウォールといったネットワーク機器では、ポート数を増やしたい場合にはワンランク上のハイエンドな機器との入れ換えが必要でした。これは、コストのかかる垂直方向のアップグレードです。しかし、ネットワーク機器を OpenFlow のコントローラとして汎用サーバ上にソフトウェア実装すれば、並べるサーバを増やすだけでポート数を増やせます。こうした水平方向へのアップグレードは垂直方向のアップグレードと比べて低コストで実現できます。</simpara>
<simpara>さらに、ネットワーク機器の機能アップグレードも、OpenFlow ではソフトウェアの書き換えで済みます。従来のようにワンランク上の高機能なネットワーク機器を購入するかわりに、新機能をコントローラにソフトウェアとして実装すればよいのです。</simpara>
<simpara>ただし、これらはもちろん<emphasis role="strong">自分で実装しなければならない</emphasis>という前提付きです。たとえば水平方向にサーバを増やす場合には、サーバ間での設定情報の同期や、一部のサーバがダウンした場合の障害復旧といった機能を自分で実装しなければなりません。また、ハイエンドなネットワーク機器の機能の中には、ソフトウェアによる実現がむずかしい複雑な機能もあるでしょう。これらを実現するには、既存の分散データベースといったミドルウェアを利用したり、OpenFlow で実装しやすい機能に置き換えたり、といった工夫が必要になります。</simpara>
<note>
<simpara>こうしたネットワーク機器の OpenFlow 実装については、<link linkend="patch_panel">6 章「インテリジェントなパッチパネル」</link>・<link linkend="learning_switch">7 章「すべての基本、ラーニングスイッチ」</link>・<link linkend="learning_switch13">8 章「OpenFlow1.3 版ラーニングスイッチ」</link>・<link linkend="firewall">11 章「ファイアウォール」</link>・<link linkend="router_part1">12 章「ルータ (前編)」</link>・<link linkend="router_part2">13 章「ルータ (後編)」</link>・<link linkend="router13">14 章「ルータ (マルチプルテーブル編)」</link>でそれぞれ解説します。</simpara>
</note>
<note>
<title>OpenFlowは回転ずし</title>
<simpara>従来のファイアウォールやルータ、スイッチといった専用機器は、ベンダが提供する機能をそのまま使うしかありませんでした。たとえば、100 個ある機能のうち、本当に使いたい機能は 10 個だけだったとしても、100 機能付きのルータを買うしかありません。これではある意味、フルコースしか頼めないフレンチレストランのようなものです。一部の機能しか利用していないのに障害ポイントが無数にあるので、切り分けやデバッグが難航することもままあります。</simpara>
<simpara>OpenFlow は回転ずしです。フランス料理の味に近づけるのは大変ですが、必要な機能だけをチョイスしてがんばって実装すれば、思いどおりの機器が手に入るのです。</simpara>
</note>
</section>
</section>
<section xml:id="_openflowで気をつけること">
<title>OpenFlowで気をつけること</title>
<simpara>もちろん、OpenFlow はうれしいことばかりではありません。コントローラで制御を一手に引き受けるため、コントローラの過負荷に気をつける必要があります。たとえばもし、フローテーブルに載っていないパケットが一気にコントローラへ到着すると、パケットの配送が遅延するか、最悪の場合にはコントローラが停止してしまいます。</simpara>
<simpara>そこで、OpenFlow の使いどころにはとくに注意する必要があります。たとえばフローエントリの入っていない OpenFlow スイッチをインターネットのような多種多様のパケットが流れる環境につなげると、すぐにコントローラへの問い合わせが殺到し破綻してしまいます。しかしデータセンターなどの閉じた環境では、トラフィックの特徴や流れるパケットの種類はあらかじめ見当を付けておけます。そこで最低限のパケットのみがコントローラへ上がってくるようにうまくフローエントリを設計することで、スイッチが増えてもうまくスケールできます。</simpara>
</section>
<section xml:id="_まとめ">
<title>まとめ</title>
<simpara>本章では SDN を実現する部品である OpenFlow を解説しました。OpenFlow で構築したネットワークは、フローテーブルを持つスイッチと、スイッチを集中制御するソフトウェアであるコントローラからなります。このようにネットワークの制御をソフトウェア化することによって、次の恩恵があります。</simpara>
<itemizedlist>
<listitem>
<simpara>自動化やさざまななシステムとの連携</simpara>
</listitem>
<listitem>
<simpara>トラフィック制御のしやすさ</simpara>
</listitem>
<listitem>
<simpara>ソフトウェア開発テクニックの適用</simpara>
</listitem>
<listitem>
<simpara>水平方向へのアップグレード</simpara>
</listitem>
</itemizedlist>
<simpara>次章では OpenFlow の仕様をもう少し詳しく紹介します。</simpara>
</section>
</chapter>
<chapter xml:id="openflow_spec">
<title>OpenFlow の仕様</title>
<simpara role="lead">OpenFlow の概要がわかったところで、もう少し細かい仕様に進みましょう。実用重視で OpenFlow バージョン 1.3 仕様のポイントとよく使う用語を押さえます。</simpara>
<section xml:id="_説明する範囲とバージョン">
<title>説明する範囲とバージョン</title>
<simpara>OpenFlow標準仕様が主に定義するのは次の 2 つです。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>コントローラとスイッチの間の通信プロトコル</simpara>
</listitem>
<listitem>
<simpara>書き込んだフローエントリに対するスイッチの動作</simpara>
</listitem>
</orderedlist>
<simpara>本章ではこの 2 つの中でも、特によく使う機能のみを重点的に説明します。主に対象とするバージョンは、執筆時の安定バージョンであるバージョン 1.3 です。なお、バージョン 1.3 と以前の安定バージョンである 1.0 では、考え方やモデルに大きな違いはありません。そのため 1.3 を理解すれば 1.0 も理解しやすいでしょう。</simpara>
<simpara>なお OpenFlow が初めての方は、最初は難しい部分を読み飛ばしても構いません。後からより詳しく知りたくなった時に、いつでも読み直してください。</simpara>
</section>
<section xml:id="_スイッチとコントローラ間のやりとり">
<title>スイッチとコントローラ間のやりとり</title>
<simpara>OpenFlow スイッチとコントローラは、OpenFlow 仕様の規定するメッセージをやりとりしながら動作します。ここでは具体的にどのようなメッセージを送受信するか、順を追って説明します。<link linkend="how_does_openflow_work">1 章「OpenFlow の仕組み」</link>で見た、カスタマーサポートセンターでのやりとりを思い出しながら読んでください。</simpara>
<section xml:id="_スイッチ_コントローラ間の接続">
<title>スイッチ・コントローラ間の接続</title>
<simpara>最初にコントローラとスイッチは TCP 接続を確立します。これを <emphasis role="strong">OpenFlow チャンネル</emphasis>と呼びます。この TCP 接続は、仕様によるとスイッチとコントローラのどちらが始めてもよいことになっています。しかし多くの場合、<link linkend="openflow_channel">図 2-1</link> のようにスイッチからコントローラへと接続する実装となっています。</simpara>
<figure xml:id="openflow_channel">
<title>スイッチがコントローラに接続し OpenFlow チャンネルを確立</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/openflow_channel.png"/>
</imageobject>
<textobject><phrase>openflow channel</phrase></textobject>
</mediaobject>
</figure>
<simpara>なお OpenFlow チャンネルには普通の TCP 接続だけでなく、よりセキュアな TLS (Transport Layer Security) も使えます。ただし、コントローラとスイッチの両方が TLS に対応している必要があります。また、TLS は暗号化・復号化に多くのリソースを必要とするので、大量にメッセージをやりとりする場合には性能が低下します。</simpara>
</section>
<section xml:id="_バージョンの確認">
<title>バージョンの確認</title>
<simpara>次にスイッチとコントローラは、使う OpenFlow バージョンをお互いに確認します。これを一般にバージョンネゴシエーションと呼びます。OpenFlow チャンネルの確立後、スイッチとコントローラは自分のしゃべれるバージョン番号を乗せた <emphasis role="strong">Hello メッセージ</emphasis>をお互いに出し合います (<link linkend="version_negotiation">図 2-2</link>)。</simpara>
<figure xml:id="version_negotiation">
<title>Hello メッセージを出し合うことで、お互いの OpenFlow プロトコルバージョンを確認</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/version_negotiation.png"/>
</imageobject>
<textobject><phrase>version negotiation</phrase></textobject>
</mediaobject>
</figure>
<simpara>もしここで、相手と同じバージョンを話せるようであればネゴシエーションに成功です。成功すると、Hello 以外のメッセージもやりとりできるようになります。</simpara>
</section>
<section xml:id="_スイッチの_datapath_id_の確認">
<title>スイッチの Datapath ID の確認</title>
<simpara>次にコントローラは接続したスイッチの Datapath ID を確認します。コントローラがスイッチに <emphasis role="strong">Features Request メッセージ</emphasis>を送ると、スイッチは Datapath ID とスペックを乗せた <emphasis role="strong">Features Reply メッセージ</emphasis>を返答します。</simpara>
<figure xml:id="features_request_reply">
<title>Features Request メッセージでスイッチの Datapath ID を確認</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/features_request_reply.png"/>
</imageobject>
<textobject><phrase>features request reply</phrase></textobject>
</mediaobject>
</figure>
<simpara>Features Reply メッセージには Datapath ID に加えて、主に次のスペック情報が入っています。</simpara>
<itemizedlist>
<listitem>
<simpara>一度にバッファできるパケットの数</simpara>
</listitem>
<listitem>
<simpara>サポートするテーブルの数</simpara>
</listitem>
<listitem>
<simpara>サポートする機能の一覧</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_コントローラへの受信パケットの通知">
<title>コントローラへの受信パケットの通知</title>
<simpara>スイッチは、受信したパケットと関連情報を <emphasis role="strong">Packet In メッセージ</emphasis>でコントローラへ通知できます。たとえば、フローテーブルに登録していない通信を検知した場合など、Packet In メッセージを使ってパケットの情報をコントローラへ送ります (<link linkend="packet_in">図 2-4</link>)。</simpara>
<figure xml:id="packet_in">
<title>受信パケットとその情報を Packet In メッセージとしてコントローラに上げる</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/packet_in.png"/>
</imageobject>
<textobject><phrase>packet in</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_パケットの出力">
<title>パケットの出力</title>
<simpara><emphasis role="strong">Packet Out メッセージ</emphasis>は Packet In メッセージの逆で、スイッチからパケットを出力するためのメッセージです (<link linkend="packet_out">図 2-5</link>)。</simpara>
<figure xml:id="packet_out">
<title>Packet Out メッセージでパケットをスイッチから出力</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/packet_out.png"/>
</imageobject>
<textobject><phrase>packet out</phrase></textobject>
</mediaobject>
</figure>
<simpara>Packet Out の典型的な利用例は、Packet In でコントローラへ届いたパケットを宛先に届ける場合です。もしも Packet In の後に Packet Out をやらないと、パケットはコントローラに残ったままで宛先には届きません。</simpara>
</section>
<section xml:id="_フローテーブルの更新">
<title>フローテーブルの更新</title>
<simpara><emphasis role="strong">Flow Mod メッセージ</emphasis>はスイッチのフローエントリを追加・削除・変更するためのメッセージです (<link linkend="flow_mod">図 2-6</link>)。Flow Mod メッセージを受け取ったスイッチは、メッセージ内容に従って自身のフローテーブルを更新します。</simpara>
<figure xml:id="flow_mod">
<title>Flow Mod メッセージでフローテーブルを更新</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/flow_mod.png"/>
</imageobject>
<textobject><phrase>flow mod</phrase></textobject>
</mediaobject>
</figure>
<simpara>OpenFlow 仕様によると、スイッチはフローテーブルの更新完了をコントローラに通知しません。その理由は、もしも Flow Mod メッセージごとに応答メッセージを返すことにすると、多くのフローエントリを設定する場合に時間がかかってしまうためです。</simpara>
<note>
<title>禁じ手: Flow ModとPacket Outを同時にやる方法</title>
<simpara>実は OpenFlow の仕様には、1つの Flow Mod メッセージで同時に Packet Out もまとめてやってしまう方法があります。しかし、これは危険なプログラミングスタイルです。</simpara>
<simpara>この Flow Mod &amp; Packet Out は<link linkend="flow_mod_and_packet_out">図 2-7</link> のように動作します。スイッチは Packet In を起こすと、スイッチのバッファ領域に Packet In を起こしたパケットの中身をバッファします。そしてコントローラに送る Packet In メッセージに、このバッファ領域の ID (Buffer ID と呼ぶ) 情報を入れて送ります。コントローラは Flow Mod のときにこの Buffer ID を指定すると、スイッチがフローテーブルの更新と同時に、コントローラの代わりに Packet Out してくれます。</simpara>
<figure xml:id="flow_mod_and_packet_out">
<title>Flow Mod に Buffer ID を指定することで同時に Packet Out する</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/flow_mod_and_packet_out.png"/>
</imageobject>
<textobject><phrase>flow mod and packet out</phrase></textobject>
</mediaobject>
</figure>
<simpara>しかし、この方法は<emphasis role="strong">禁じ手</emphasis>です。これは次の 3 つの理由によります。</simpara>
<itemizedlist>
<listitem>
<simpara>スイッチのバッファにパケットが残っているかどうかはスイッチの外からわからない。つまり指定した Buffer ID のパケットがまだバッファに残っているかどうかは、イチかバチかである</simpara>
</listitem>
<listitem>
<simpara>もしスイッチのバッファに残っているとわかったとしても、Flow Mod を打った時には消えているかもしれない</simpara>
</listitem>
<listitem>
<simpara>格安のスイッチには、そもそもバッファがないかもしれない</simpara>
</listitem>
</itemizedlist>
<simpara>というわけで、やはり Packet Out は Flow Mod と独立して打つのが良い方法です。</simpara>
</note>
</section>
<section xml:id="_フローテーブル更新完了の確認">
<title>フローテーブル更新完了の確認</title>
<simpara>Flow Mod メッセージによるフローテーブルの更新完了を確認するには <emphasis role="strong">Barrier メッセージ</emphasis>を使います (<link linkend="barrier">図 2-8</link>)。コントローラが <emphasis role="strong">Barrier Request メッセージ</emphasis>を送ると、それ以前に送った Flow Mod メッセージの処理が全て完了した後、スイッチは <emphasis role="strong">Barrier Reply メッセージ</emphasis>を返します。</simpara>
<figure>
<title>Barrier Request/Reply メッセージによってフローテーブルの更新完了を確認</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/barrier.png"/>
</imageobject>
<textobject><phrase>barrier</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_フローエントリ削除の通知">
<title>フローエントリ削除の通知</title>
<simpara>フローエントリが消えると、消えたフローエントリーの情報は <emphasis role="strong">Flow Removed メッセージ</emphasis>としてコントローラに届きます。Flow Removed メッセージには、消えたフローエントリの内容とそのフローエントリにしたがって処理したパケットの統計情報が入っています。これを使えば、たとえばネットワークのトラフィック量の集計ができます。</simpara>
<figure>
<title>フローエントリが消えると、フローエントリの内容と転送したパケットの統計情報が Flow Removed としてコントローラへ上がる</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/flow_removed.png"/>
</imageobject>
<textobject><phrase>flow removed</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section xml:id="_フローエントリの中身">
<title>フローエントリの中身</title>
<simpara><link linkend="how_does_openflow_work">1章</link>で見たようにフローエントリは次の 6 要素から成ります。</simpara>
<itemizedlist>
<listitem>
<simpara>優先度</simpara>
</listitem>
<listitem>
<simpara>カウンタ (統計情報)</simpara>
</listitem>
<listitem>
<simpara>タイムアウト (寿命)</simpara>
</listitem>
<listitem>
<simpara>クッキー</simpara>
</listitem>
<listitem>
<simpara>マッチフィールド</simpara>
</listitem>
<listitem>
<simpara>インストラクション</simpara>
</listitem>
</itemizedlist>
<section xml:id="_優先度">
<title>優先度</title>
<simpara>フローエントリには、優先度 (0 〜 65535) が設定できます。受信パケットが、フローテーブル中に複数のフローエントリにマッチする場合、この優先度の値が高いフローエントリが優先されます。</simpara>
</section>
<section xml:id="_カウンタ_統計情報">
<title>カウンタ (統計情報)</title>
<simpara>OpenFlow 1.3 ではフローエントリごとにカウンタを持っており、次の統計情報を取得できます。</simpara>
<itemizedlist>
<listitem>
<simpara>受信パケット数</simpara>
</listitem>
<listitem>
<simpara>受信バイト数</simpara>
</listitem>
<listitem>
<simpara>フローエントリが作られてからの経過時間 (秒)</simpara>
</listitem>
<listitem>
<simpara>フローエントリが作られてからの経過時間 (ナノ秒)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_タイムアウト_寿命">
<title>タイムアウト (寿命)</title>
<simpara>フローエントリにはタイムアウト (寿命) を設定できます。寿命の指定には次の 2 種類があります。</simpara>
<itemizedlist>
<listitem>
<simpara>アイドルタイムアウト: 参照されない時間がこの寿命に逹すると、そのフローエントリを消す。パケットが到着し、フローエントリが参照された時点で 0 秒にリセットされる。</simpara>
</listitem>
<listitem>
<simpara>ハードタイムアウト: 参照の有無を問わず、フローエントリが書き込まれてからの時間がこの寿命に逹すると、そのフローエントリを消す。</simpara>
</listitem>
</itemizedlist>
<simpara>どちらのタイムアウトも 0 にして打ち込むと、そのフローエントリは明示的に消さない限りフローテーブルに残ります。</simpara>
</section>
<section xml:id="_クッキー">
<title>クッキー</title>
<simpara>フローエントリには、クッキーを設定できます。クッキーに設定された値は、スイッチにおけるパケット処理には全く影響を与えません。例えば、フローエントリを管理するために、コントローラがクッキーフィールドに管理用の ID を付与するといった使い方ができます。</simpara>
</section>
<section xml:id="_マッチフィールド">
<title>マッチフィールド</title>
<simpara>マッチフィールドとは、OpenFlow スイッチがパケットを受け取ったときにアクションを起こすかどうかを決める条件です。たとえば「パケットの宛先が http サーバだったら」とか「パケットの宛先がブロードキャストアドレスだったら」などという条件に適合したパケットにだけ、スイッチがアクションを起こすというわけです。</simpara>
<simpara>OpenFlow 1.3 では、40 種類の条件が使えます。主な条件を <link linkend="matching_rules">表2-1</link> に示します。これらの条件はイーサネットや TCP/UDP でよく使われる値です。</simpara>
<note>
<title>コラム マッチフィールドの別名</title>
<simpara>OpenFlow が使われ始めたころ、フローエントリの要素の1つであるマッチフィールドには、"OpenFlow 12 タプル"、"ヘッダフィールド" 等、さまざまな別の呼び方がありました。混乱を避けるため、本書の前版では "マッチングルール" という呼び方に統一しました。パケットがきたときにルールに従ってマッチする、という役割をすなおに表現していて、いちばんわかりやすい名前だったからです。</simpara>
<simpara>その後、OpenFlow バージョン 1.3 で正式な呼び名が "マッチフィールド" に決まりました。そのため、本書では仕様に従い "マッチフィールド" という呼び方を使っています。</simpara>
</note>
<table xml:id="matching_rules" frame="all" rowsep="1" colsep="1">
<title>マッチフィールドで指定できる主な条件</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">名前</entry>
<entry align="left" valign="top">説明</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>In Port</simpara></entry>
<entry align="left" valign="top"><simpara>スイッチの論理ポート番号</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>In Phy Port</simpara></entry>
<entry align="left" valign="top"><simpara>スイッチの物理ポート番号</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ether Src</simpara></entry>
<entry align="left" valign="top"><simpara>送信元 MAC アドレス</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ether Dst</simpara></entry>
<entry align="left" valign="top"><simpara>宛先 MAC アドレス</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ether Type</simpara></entry>
<entry align="left" valign="top"><simpara>イーサネットの種別</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>VLAN ID</simpara></entry>
<entry align="left" valign="top"><simpara>VLAN ID</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>VLAN Priority</simpara></entry>
<entry align="left" valign="top"><simpara>VLAN PCP の値 (CoS)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IP DSCP</simpara></entry>
<entry align="left" valign="top"><simpara>DiffServ コードポイント</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IP ECN</simpara></entry>
<entry align="left" valign="top"><simpara>IP ECN ビット</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IP Src</simpara></entry>
<entry align="left" valign="top"><simpara>送信元 IP アドレス</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IP Dst</simpara></entry>
<entry align="left" valign="top"><simpara>宛先 IP アドレス</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IP Proto</simpara></entry>
<entry align="left" valign="top"><simpara>IP のプロトコル種別</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TCP Src Port</simpara></entry>
<entry align="left" valign="top"><simpara>TCP の送信元ポート番号</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TCP Dst Port</simpara></entry>
<entry align="left" valign="top"><simpara>TCP の宛先ポート番号</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>UDP Src Port</simpara></entry>
<entry align="left" valign="top"><simpara>UDP の送信元ポート番号</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>UDP Dst Port</simpara></entry>
<entry align="left" valign="top"><simpara>UDP の宛先ポート番号</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ICMPv4 Type</simpara></entry>
<entry align="left" valign="top"><simpara>ICMP 種別</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ICMPv4 Code</simpara></entry>
<entry align="left" valign="top"><simpara>ICMP コード</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IPv6 Src</simpara></entry>
<entry align="left" valign="top"><simpara>送信元 IPv6 アドレス</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IPv6 Dst</simpara></entry>
<entry align="left" valign="top"><simpara>宛先 IPv6 アドレス</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IPv6 Flowlabel</simpara></entry>
<entry align="left" valign="top"><simpara>IPv6 フローラベル</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ICMPv6 Type</simpara></entry>
<entry align="left" valign="top"><simpara>ICMPv6 種別</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ICMPv6 Code</simpara></entry>
<entry align="left" valign="top"><simpara>ICMPv6 コード</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MPLS Label</simpara></entry>
<entry align="left" valign="top"><simpara>MPLS ラベル</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MPLS TC</simpara></entry>
<entry align="left" valign="top"><simpara>MPLS トラフィッククラス</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PBB ISID</simpara></entry>
<entry align="left" valign="top"><simpara>PBB ISID</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>OpenFlow の世界では、このマッチフィールドで指定できる条件を自由に組み合わせて通信を制御します。たとえば、</simpara>
<itemizedlist>
<listitem>
<simpara>スイッチの物理ポート 1 番から届く、宛先が TCP 80 番 (= HTTP) のパケットを書き換える</simpara>
</listitem>
<listitem>
<simpara>MAC アドレスが 02:27:e4:fd:a3:5d で宛先の IP アドレスが 192.168.0.0/24 は遮断する</simpara>
</listitem>
</itemizedlist>
<simpara>などといった具合です。</simpara>
<note>
<title>OSI ネットワークモデルが壊れる？</title>
<simpara>あるネットワークの経験豊富な若者がこんな事を言っていました。</simpara>
<simpara>「OpenFlow のようにレイヤをまたがって自由に何でもできるようになると、OSI ネットワークモデル(よく「レイヤ 2」とか「レイヤ 3」とか呼ばれるアレのこと。正確には ISO によって制定された、異機種間のデータ通信を実現するためのネットワーク構造の設計方針)が壊れるんじゃないか？」</simpara>
<simpara>その心配は無用です。OSI ネットワークモデルは正確に言うと「OSI 参照モデル」と言って、通信プロトコルを分類して見通しを良くするために定義した "参照用" の階層モデルです。たとえば自分が xyz プロトコルというのを作ったけど人に説明したいというときに、どう説明するか考えてみましょう。「これはレイヤ 3 のプロトコルで、…」という風に階層を指して (参照して) 説明を始めれば相手に通りがよいでしょう。つまり、OSI ネットワークモデルはネットワーク屋同士で通じる「語彙」として使える、まことに便利なものなのです。</simpara>
<simpara>でも、これはあくまで「参照」であって「規約」ではないので、すべてのネットワークプロトコル、ネットワーク機器がこれに従わなければいけない、というものではありません。さっき言ったように「この ○○ は、仮に OSI で言うとレイヤ4 にあたる」のように使うのが正しいのです。</simpara>
<simpara>そして、OpenFlow はたまたまいくつものレイヤの情報が使える、ただそれだけのことです。</simpara>
</note>
</section>
<section xml:id="_インストラクション">
<title>インストラクション</title>
<simpara>インストラクションには、そのフローエントリにマッチしたパケットを、次にどのように扱うかを指定します。OpenFlow 1.3 では主に、以下のインストラクションを利用可能です。</simpara>
<itemizedlist>
<listitem>
<simpara>Apply-Actions: 指定されたアクションを実行します。</simpara>
</listitem>
<listitem>
<simpara>Write-Actions: 指定されたアクションをアクションセットに追加します。</simpara>
</listitem>
<listitem>
<simpara>Clear-Actions: アクションセット中のアクションをすべてクリアします。</simpara>
</listitem>
<listitem>
<simpara>Write-Metadata: 受信したパケットに、メタデータを付与します。</simpara>
</listitem>
<listitem>
<simpara>Goto-Table: 指定のフローテーブルに移動します。</simpara>
</listitem>
</itemizedlist>
<simpara>これらのうち Write-Actions, Clear-Actions, Write-Metadata, Goto-Table は、マルチプルテーブルを使う際に用いるインストラクションです。そのため、マルチプルテーブルを説明する際に、合わせて詳しく説明します。</simpara>
<simpara>Apply-Actions にて指定するアクションとは、スイッチに入ってきたパケットをどう料理するか、という <emphasis role="strong">動詞</emphasis> にあたる部分です。よく「OpenFlow でパケットを書き換えて曲げる」などと言いますが、こうした書き換えなどはすべてアクションで実現できます。OpenFlow 1.3 では、次の 7 種類のアクションがあります。</simpara>
<itemizedlist>
<listitem>
<simpara>Output: パケットを指定したポートから出す</simpara>
</listitem>
<listitem>
<simpara>Group: パケットに対し、指定したグループテーブルの処理を適用する</simpara>
</listitem>
<listitem>
<simpara>Drop: パケットを捨てる</simpara>
</listitem>
<listitem>
<simpara>Set-Queue: ポートごとに指定されたスイッチのキューに入れる。QoS 用</simpara>
</listitem>
<listitem>
<simpara>Push-Tag/Pop-Tag: パケットに対し MPLS/VLAN タグの付与/除去を行う</simpara>
</listitem>
<listitem>
<simpara>Set-Field: 指定のフィールドの中身を書き換える</simpara>
</listitem>
<listitem>
<simpara>Change-TTL: TTL フィールドの値を書き換える</simpara>
</listitem>
</itemizedlist>
<simpara>アクションは動詞と同じく指定した順番に実行されます。「おにぎりを作って、食べて、片付ける」といったふうに。たとえば、パケットを書き換えて指定したポートから出したいときには、</simpara>
<screen>[Set-Field, Output]</screen>
<simpara>と、複数のアクション並べて指定します。この実行順に並べられた複数のアクションのことを、アクションリストと呼びます。Apply-Actions インストラクションや Write-Actions インストラクションには、アクションリストを用いることで、複数のアクションを指定できます。</simpara>
<simpara>ここで、アクションリストは指定された順番に実行されることに注意してください。アクションリストの順番を変えてしまうと、違う結果が起こります。たとえば「おにぎりを食べてから、おにぎりを作る」と最後におにぎりが残ってしまいます。同様に先ほどの例を逆にしてしまうと、まず先にパケットがフォワードされてしまいます。その後 Set-Field が実行されても、書き換えられた後、そのパケットは破棄されるだけです。</simpara>
<screen># パケットを書き換える前にフォワードされてしまう。
[Output, Set-Field]</screen>
<simpara>同じ動詞を複数指定することもできます。</simpara>
<screen>[Set-Field A, Set-Field B, Output A, Output B]</screen>
<simpara>この場合は、フィールド A と B を書き換えて、ポート A と B へフォワードする、と読めます。このように、複数のフィールドを書き換えたり、複数のポートにパケットを出したりする場合には、アクションを複数連ねて指定します<footnote><simpara>指定できるアクション数の上限は OpenFlow スイッチとコントローラの実装に依存します。普通に使う分にはまず問題は起こらないでしょう</simpara></footnote>。</simpara>
<simpara>Drop は特殊なアクションで、実際に Drop アクションというものが具体的に定義されているわけではありません。アクションのリストに Output アクションを1つも入れなかった場合、そのパケットはどこにもフォワードされずに捨てられます。これを便宜的に Drop アクションと呼んでいるわけです。</simpara>
<simpara>それでは、もっともよく使われる Output アクションと Set-Field アクションで具体的に何が指定できるか見て行きましょう。</simpara>
</section>
<section xml:id="_output_アクション">
<title>Output アクション</title>
<simpara>Output アクションでは指定したポートからパケットを出力します。出力先にはポート番号を指定しますが、特殊用途のために定義されている論理ポートを使うこともできます。</simpara>
<itemizedlist>
<listitem>
<simpara>ポート番号: パケットを指定した番号のポートに出す。</simpara>
</listitem>
<listitem>
<simpara>IN_PORT: パケットを入ってきたポートに出す。</simpara>
</listitem>
<listitem>
<simpara>ALL: パケットを入ってきたポート以外のすべてのポートに出す。</simpara>
</listitem>
<listitem>
<simpara>FLOOD: パケットをスイッチが作るスパニングツリーに沿って出す。</simpara>
</listitem>
<listitem>
<simpara>CONTROLLER: パケットをコントローラに明示的に送り、Packet In を起こす。</simpara>
</listitem>
<listitem>
<simpara>NORMAL: パケットをスイッチの機能を使って転送する。</simpara>
</listitem>
<listitem>
<simpara>LOCAL: パケットをスイッチのローカルスタックに上げる。ローカルスタック上で動作するアプリケーションにパケットを渡したい場合に使う。あまり使われない。</simpara>
</listitem>
</itemizedlist>
<simpara>この中でも FLOOD や NORMAL は OpenFlow スイッチ機能と既存のスイッチ機能を組み合わせて使うための論理ポートです。</simpara>
</section>
<section xml:id="_set_field_アクション">
<title>Set-Field アクション</title>
<simpara>Set-Field アクションでは、パケットのさまざまな部分を書き換えられます。パケットで書き換えられるフィールドは、マッチフィールドで指定可能なフィールドと同じです (<link linkend="matching_rules">表2-1</link>)。例えば、以下に示す書き換えが可能です。</simpara>
<itemizedlist>
<listitem>
<simpara>送信元/宛先 MAC アドレスの書き換え</simpara>
</listitem>
<listitem>
<simpara>送信元/宛先 IP アドレスの書き換え</simpara>
</listitem>
<listitem>
<simpara>ToS フィールドの書き換え</simpara>
</listitem>
<listitem>
<simpara>TCP/UDP 送信元/宛先ポートの書き換え</simpara>
</listitem>
<listitem>
<simpara>VLAN ID/プライオリティの書き換え</simpara>
</listitem>
</itemizedlist>
<simpara>それでは Set-Field アクションの代表的な使い道を順に見ていきましょう。</simpara>
<section xml:id="_mac_アドレスの書き換え">
<title>MAC アドレスの書き換え</title>
<simpara>MAC アドレス書き換えの代表的な例がルータです。OpenFlow はルータの実装に必要な、送信元と宛先 MAC アドレスの書き換えをサポートしています。</simpara>
<figure>
<title>ルータでの送信元と宛先 MAC アドレスの書き換え</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/rewrite_mac.png"/>
</imageobject>
<textobject><phrase>rewrite mac</phrase></textobject>
</mediaobject>
</figure>
<simpara>ルータは 2 つのネットワークの間で動作し、ネットワーク間で行き交うパケットの交通整理を行います。ホスト A が異なるネットワークに属するホスト B にパケットを送ると、ルータはそのパケットを受け取りその宛先 IP アドレスから転送先のネットワークを決定します。そして、パケットに記述された宛先 MAC アドレスを次に送るべきホストの MAC アドレスに、送信元を自分の MAC アドレスに書き換えてデータを転送します。</simpara>
</section>
<section xml:id="_ip_アドレスの書き換え">
<title>IP アドレスの書き換え</title>
<simpara>IP アドレス書き換えの代表的な例が NAT (Network Address Transition) です。OpenFlow は NAT の実装に必要な、送信元と宛先 IP アドレスの書き換えをサポートしています。</simpara>
<figure>
<title>NAT での送信元と宛先 IP アドレスの書き換え</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/rewrite_ip_address.png"/>
</imageobject>
<textobject><phrase>rewrite ip address</phrase></textobject>
</mediaobject>
</figure>
<simpara>インターネットと接続するルータでは、プライベート/グローバルネットワーク間での通信を通すために IP アドレスを次のように変換します。プライベートネットワーク内のクライアントからインターネット上のサーバに通信をする場合、ゲートウェイはプライベートネットワークから届いたパケットの送信元 IP アドレスを自分のグローバルな IP アドレスに変換して送信します。逆にサーバからの返信は逆の書き換えを行うことによりプライベートネットワーク内のクライアントに届けます。</simpara>
</section>
<section xml:id="_tos_フィールドの書き換え">
<title>ToS フィールドの書き換え</title>
<simpara>ToS フィールドは通信のサービス品質 (QoS) を制御する目的でパケットを受け取ったルータに対して処理の優先度を指定するために使われます。OpenFlow はこの ToS フィールドの書き換えをサポートしています。</simpara>
</section>
<section xml:id="_tcp_udp_ポート番号の書き換え">
<title>TCP/UDP ポート番号の書き換え</title>
<simpara>TCP/UDP ポート番号書き換えの代表的な例が IP マスカレードです。OpenFlow は IP マスカレードの実装に必要な、送信元と宛先の TCP/UDP ポート番号の書き換えをサポートしています。</simpara>
<figure>
<title>IP マスカレードでの送信元と宛先 TCP/UDP ポート番号の書き換え</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/rewrite_port.png"/>
</imageobject>
<textobject><phrase>rewrite port</phrase></textobject>
</mediaobject>
</figure>
<simpara>ブロードバンドルータなど 1 つのグローバルアドレスで複数のホストが同時に通信を行う環境では、NAT だけだと TCP/UDP のポート番号が重複する可能性があります。そこで、IP マスカレードではプライベートネットワーク側のポート番号をホストごとに適当に割り当て、通信のつどポート番号を変換することで解決します。</simpara>
</section>
<section xml:id="_vlan_ヘッダの書き換え">
<title>VLAN ヘッダの書き換え</title>
<simpara>既存のタグ付き VLAN で構築したネットワークと OpenFlow で構築したネットワークを接続するという特別な用途のために、VLAN ヘッダの書き換えができます。VLAN をひとことで説明すると、既存のスイッチで構成されるネットワーク (ブロードキャストが届く範囲のネットワーク) を複数のネットワークに分割して使用するための仕組みです。この分割したネットワーク自体を VLAN と呼ぶ場合もあります。どの VLAN に所属するかを区別するのが VLAN ID で、パケットに付与される VLAN タグがこの VLAN ID を含みます。Set-Field アクションを用いることで、以下に示す 2 種類の VLAN ヘッダ操作ができます。</simpara>
<figure>
<title>VLAN ヘッダを書き換えるアクションの使い道</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/strip_vlan.png"/>
</imageobject>
<textobject><phrase>strip vlan</phrase></textobject>
</mediaobject>
</figure>
<variablelist>
<varlistentry>
<term>VLAN ID の書き換え</term>
<listitem>
<simpara>VLAN パケットが属する VLAN の ID を書き換えます。たとえば VLAN ID を 3 に書き換えるといったアクションを指定できます。また、VLAN ヘッダがついていないパケットに 指定した VLAN ID を持つ VLAN ヘッダを付与することもできます。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>VLAN プライオリティの書き換え</term>
<listitem>
<simpara>VLAN 上でのパケットを転送する優先度を変更します。このプライオリティはトラフィックの種類 (データ、音声、動画など) を区別する場合などに使います。指定できる値は 0 (最低) から 7 (最高) までです。</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_change_ttl_アクション">
<title>Change-TTL アクション</title>
<simpara>Chante-TTL アクションは、パケット中の TTL (Time-To-Live) の値を変更するためのアクションです。TTL は、なんらかの不具合によりネットワーク中でパケットがループすることを防ぐための仕組みです。パケットを受信したネットワーク機器は、ヘッダ中の TTL の値を一つ減らしてからパケットを転送します。もし、受信したパケットの TTL の値が 0 だった場合、そのパケットを破棄します。このようにすることで、パケットがループ中を転送され続けることを防ぎます。Change-TTL アクションでは、以下に示す TTL の書き換えが可能です。</simpara>
<itemizedlist>
<listitem>
<simpara>MPLS ヘッダの TTL に指定の値を設定 (Set MPLS TTL)</simpara>
</listitem>
<listitem>
<simpara>IP ヘッダの TTL に指定の値を設定 (Set IP TTL)</simpara>
</listitem>
<listitem>
<simpara>MPLS ヘッダの TTL の値を一つ減算 (Decrement MPLS TTL)</simpara>
</listitem>
<listitem>
<simpara>IP ヘッダの TTL の値を一つ減算 (Decrement IP TTL)</simpara>
</listitem>
<listitem>
<simpara>内側ヘッダの TTL の値を外側ヘッダの TTL のフィールドにコピー (Copy TTL outwards)</simpara>
</listitem>
<listitem>
<simpara>外側ヘッダの TTL の値を内側ヘッダの TTL のフィールドにコピー (Copy TTL inwards)</simpara>
</listitem>
</itemizedlist>
<simpara>例えば、内側が IP ヘッダで外側が MPLS ヘッダである時、Copy TTL outwards では、IP ヘッダの TTL 値を MPLS ヘッダの TTL のフィールドに設定します。一方、Copy TTL inwards では、MPLS ヘッダの TTL 値を IP ヘッダの TTL のフィールドに設定します。</simpara>
</section>
</section>
<section xml:id="_マルチプルテーブル">
<title>マルチプルテーブル</title>
<simpara>OpenFlow バージョン 1.3 では、OpenFlow スイッチがフローテーブルを複数持てます。この複数のフローテーブルのことを、マルチプルテーブルと呼びます。マルチプルテーブルをうまく活用することで、複雑なパケット処理を行えます。</simpara>
<simpara>宮坂部長グループの社内ネットワーク運用について考えてみましょう(<link linkend="multiple_table_example">図 2-14</link>)。</simpara>
<figure xml:id="multiple_table_example">
<title>宮坂部長グループの社内ネットワーク</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openflow_spec/multiple_table_example.png"/>
</imageobject>
<textobject><phrase>multiple table example</phrase></textobject>
</mediaobject>
</figure>
<itemizedlist>
<listitem>
<simpara>宮坂部長 (192.168.0.1) の端末からのパケットは、MailとWebのトラフィックの場合のみ、ポート 2 に出力したい。</simpara>
</listitem>
<listitem>
<simpara>一般社員の端末 (192.168.0.2 ～ 192.168.0.254) からは、すべてのトラフィックを、ポート 2 に出力したい。</simpara>
</listitem>
</itemizedlist>
<simpara>Mail のトラフィックを許可する場合には、TCP で Destination Port 番号が 25 と 110 のパケットを通過するようにします。同様に Web では、TCP で Destination Port 番号 80 と 443 を許可します。</simpara>
<simpara>これをフローテーブルに設定すると、<link linkend="table0_1">表2-2</link> の様になります。先頭の 5 つのが宮坂部長の端末 (192.168.0.1) からのパケット向けのフローエントリです。</simpara>
<table xml:id="table0_1" frame="all" rowsep="1" colsep="1">
<title>マルチプルテーブルを使わない場合のフローテーブルの例1</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">マッチ</entry>
<entry align="left" valign="top">インストラクション</entry>
<entry align="left" valign="top">優先度</entry>
<entry align="left" valign="top">備考</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.1/32, dst_port = 25</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"><simpara>宮坂部長用</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.1/32, dst_port = 110</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.1/32, dst_port = 80</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.1/32, dst_port = 443</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.1/32</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Drop)</simpara></entry>
<entry align="left" valign="top"><simpara>5000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.0/24</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>一般社員用</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>宮坂部長の仕事が多くなったため、事務員を雇うことになりました。事務員は宮坂部長の業務を手伝う必要があるため、事務員に割り当てられた端末 (192.168.0.2) は宮坂部長の端末と同じポリシーで運用することとします。この場合、フローテーブルを <link linkend="table0_2">表2-3</link> のように書き換える必要があります。</simpara>
<table xml:id="table0_2" frame="all" rowsep="1" colsep="1">
<title>マルチプルテーブルを使わない場合のフローテーブルの例2</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">マッチ</entry>
<entry align="left" valign="top">インストラクション</entry>
<entry align="left" valign="top">優先度</entry>
<entry align="left" valign="top">備考</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.1/32, dst_port = 25</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"><simpara>宮坂部長用</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.1/32, dst_port = 110</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.1/32, dst_port = 80</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.1/32, dst_port = 443</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.1/32</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Drop)</simpara></entry>
<entry align="left" valign="top"><simpara>5000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.2/32, dst_port = 25</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"><simpara>事務員用</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.2/32, dst_port = 110</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.2/32, dst_port = 80</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.2/32, dst_port = 443</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.2/32</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Drop)</simpara></entry>
<entry align="left" valign="top"><simpara>5000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.0/24</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>一般社員用</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>wildcard</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Drop)</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><link linkend="table0_1">表2-2</link> と <link linkend="table0_2">表2-3</link> を比較すると、フローエントリが 5 つ増えているのがわかります。もし事務員をもう一人雇うことになった場合、さらに 5 つのエントリを追加する必要があります。</simpara>
<simpara>このようにフローテーブルの内容が複雑になるケースでも、マルチプルテーブルを使うことですっきりできます。まず Table1 の内容は <link linkend="table1">表2-4</link> の様になります。宮坂部長および事務員の端末からのパケットを、TCP のポート番号を見てからどのように処理するか判断すべきです。そのための判断をするために、これらのパケットは次に Table 2 を見るように Goto-Table インストラクションが指定されています。</simpara>
<table xml:id="table1" frame="all" rowsep="1" colsep="1">
<title>マルチプルテーブルを使う場合のフローテーブルの例 1 (Table1)</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">マッチ</entry>
<entry align="left" valign="top">インストラクション</entry>
<entry align="left" valign="top">優先度</entry>
<entry align="left" valign="top">備考</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.1/32</simpara></entry>
<entry align="left" valign="top"><simpara>Goto-Table 2</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"><simpara>宮坂部長用</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.2/32</simpara></entry>
<entry align="left" valign="top"><simpara>Goto-Table 2</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"><simpara>事務員用</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.0.0/24</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>一般社員用</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>wildcard</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Drop)</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Table2 の内容は、<link linkend="table2">表2-5</link> のようになっています。このテーブルを参照するのは、宮坂部長、事務員の端末からのパケットが到着した場合のみなので、あとは Mail, Web のトラフィックのみ通過できるようなエントリを記述すれば良いことになります。</simpara>
<table xml:id="table2" frame="all" rowsep="1" colsep="1">
<title>マルチプルテーブルを使う場合のフローテーブルの例 2 (Table2)</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">マッチ</entry>
<entry align="left" valign="top">インストラクション</entry>
<entry align="left" valign="top">優先度</entry>
<entry align="left" valign="top">備考</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>dst_port = 25</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"><simpara>宮坂部長、事務員用</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>dst_port = 110</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>dst_port = 80</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>dst_port = 443</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>wildcard</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Drop)</simpara></entry>
<entry align="left" valign="top"><simpara>5000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>マルチプルテーブルを使ったほうが、<link linkend="table0_2">図2-3</link> と比べ、シンプルになることがわかります。もし、事務員をもう一人雇うことになった場合でも、Table1 に一つエントリを追加するだけで済みます。</simpara>
<section xml:id="_write_actions_と_clear_actions">
<title>Write-Actions と Clear-Actions</title>
<simpara>Apply-Actions に指定されたアクションは、フローテーブルが参照された段階で即座に実行されます。一方で、Write-Actions を使うと、一旦アクションセットに格納されます。そしてフローテーブルの参照が全て終わった段階で、アクションセットに格納されたアクションが実行されます。</simpara>
<simpara>例えば、<link linkend="table_write_action1">表2-6</link> と <link linkend="table_write_action2">表2-7</link> のようにフローエントリが格納されていたとします。宛先ポート番号 25 のパケットを受信した時、このパケットは Table1 の 1 番目のエントリにマッチします。そのため、Write-Actions インストラクションで指定されている Set-Field A というアクションがアクションセットに格納されます。1 番目のエントリには、Goto-Table インストラクションも指定されていますので、次に Table2 の参照を行います。受信パケットは Table2 の 1 番目のエントリにもマッチしますので、同様にアクションセットに Output 2 というアクションが格納されます。最終的にアクションセットには、Set-Field A および Output 2 という二つのアクションが格納されている状態になります。</simpara>
<table xml:id="table_write_action1" frame="all" rowsep="1" colsep="1">
<title>Write-Actions を含むフローテーブルの例 1 (Table1)</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">マッチ</entry>
<entry align="left" valign="top">インストラクション</entry>
<entry align="left" valign="top">優先度</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>dst_port = 25</simpara></entry>
<entry align="left" valign="top"><simpara>Write-Actions (Set-Field A), Goto-Table 2</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>dst_port = 110</simpara></entry>
<entry align="left" valign="top"><simpara>Write-Actions (Set-Field B), Goto-Table 2</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table xml:id="table_write_action2" frame="all" rowsep="1" colsep="1">
<title>Write-Actions を含むフローテーブルの例 2 (Table2)</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">マッチ</entry>
<entry align="left" valign="top">インストラクション</entry>
<entry align="left" valign="top">優先度</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>wildcard</simpara></entry>
<entry align="left" valign="top"><simpara>Write-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>アクションセットに格納された複数のアクションは、次の優先順位に従って実行されます。格納された順に実行されるわけではない点に注意が必要です。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>copy TTL inwards : 外側ヘッダの TTL を内側ヘッダの TTL へコピーするアクションを実行します。</simpara>
</listitem>
<listitem>
<simpara>pop : 指定されたタグを除去するアクションを実行します。</simpara>
</listitem>
<listitem>
<simpara>push-MPLS : MPLS tag をパケットに付与するアクションを実行します。</simpara>
</listitem>
<listitem>
<simpara>push-PBB : PBB tag をパケットに付与するアクションを実行します。</simpara>
</listitem>
<listitem>
<simpara>push-VLAN : VLAN tag をパケットに付与するアクションを実行します。</simpara>
</listitem>
<listitem>
<simpara>copy TTL outwards : 内側ヘッダの TTL を外側ヘッダの TTL へコピーするアクションを実行します。</simpara>
</listitem>
<listitem>
<simpara>decrement TTL : TTL を 1 減らすアクションを実行します。</simpara>
</listitem>
<listitem>
<simpara>set : Set-Field アクションを実行します。</simpara>
</listitem>
<listitem>
<simpara>qos : Set-Queue アクションを実行します。</simpara>
</listitem>
<listitem>
<simpara>group : Group アクションを実行します。</simpara>
</listitem>
<listitem>
<simpara>output : group の指定がない場合のみ、Output アクションを実行します。</simpara>
</listitem>
</orderedlist>
<simpara><link linkend="table_write_action1">表2-6</link> と <link linkend="table_write_action2">表2-7</link> で示した例の場合、Output アクションより優先度が高い Set-Field アクションが先に実行され、その後 Output アクションが実行されます。</simpara>
<simpara>アクションセットは、一連の処理が終わった後にクリアされます。前に受信したパケットのアクションがアクションセットに入ったままになり、次のパケットの処理に用いられることは起こりません。</simpara>
<simpara>マルチプルテーブルを使ったパケットの処理中であっても、Clear-Actions インストラクションを使うことで、アクションセットの中身をクリアできます。Clear-Actions インストラクションを使えば、Write-Actions で格納したアクションをアクションセット中から全て消去できます。</simpara>
</section>
<section xml:id="_メタデータの利用">
<title>メタデータの利用</title>
<simpara>Write-Metadata インストラクションを使って、メタデータを付与できます。付与されたメタデータは、Goto-Table インストラクションで次のフローテーブルを参照する際に、マッチフィールドの一部として利用できます。</simpara>
<simpara>例えば、送信元 IP アドレスが 192.168.1.101, 102 の場合、宛先ポート番号が 25, 110 のパケットのみをポート 2 から出力し、また送信元 IP アドレスが 192.168.1.103, 104 の場合、宛先ポートが 80, 443 のパケットのみをポート 2 から出力することを考えます。この例をメタデータを使って実現したのが <link linkend="table_metadata1">表2-8</link> と <link linkend="table_metadata2">表2-9</link> です。</simpara>
<simpara><link linkend="table_metadata1">表2-8</link> には、送信元 IP アドレスをマッチとしたフローエントリが格納しています。<link linkend="table_metadata2">表2-9</link> には、宛先ポートをマッチとしたフローエントリが格納されています。このように、メタデータを用いることで、複雑な条件であっても、シンプルなフローエントリの組み合わせで設定できます。</simpara>
<table xml:id="table_metadata1" frame="all" rowsep="1" colsep="1">
<title>メタデータを含むフローテーブルの例 1 (Table1)</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">マッチ</entry>
<entry align="left" valign="top">インストラクション</entry>
<entry align="left" valign="top">優先度</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.1.101</simpara></entry>
<entry align="left" valign="top"><simpara>Write-Metadata 1, Goto-Table 2</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.1.102</simpara></entry>
<entry align="left" valign="top"><simpara>Write-Metadata 1, Goto-Table 2</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.1.103</simpara></entry>
<entry align="left" valign="top"><simpara>Write-Metadata 2, Goto-Table 2</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>src_ip = 192.168.1.104</simpara></entry>
<entry align="left" valign="top"><simpara>Write-Metadata 2, Goto-Table 2</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table xml:id="table_metadata2" frame="all" rowsep="1" colsep="1">
<title>メタデータを含むフローテーブルの例 2 (Table2)</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">マッチ</entry>
<entry align="left" valign="top">インストラクション</entry>
<entry align="left" valign="top">優先度</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>metadata = 1, dst_port = 25</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>metadata = 1, dst_port = 110</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>metadata = 2, dst_port = 80</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>metadata = 2, dst_port = 443</simpara></entry>
<entry align="left" valign="top"><simpara>Apply-Actions (Output 2)</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>メタデータは 64bit 長のビット列で、初期値は All 0 です。Write-Matadata インストラクションは、各ビットの値を変更します。Write-Metadata インストラクションを使うときは、値とマスクの組を指定します。マスクで指定されたビットの値がメタデータに反映されます。</simpara>
<simpara>例を使って説明します。実際にはメタデータは 64bit ですが、ここでは 8bit であるとします。メタデータの現在の値が 11111111 であり、Write-Metadata インストラクションでの指定した値は 00001010、マスクは 00001111 であったとします。マスクは下位 4bit が 1 であるため、値の下位 4bit 分だけをメタデータに反映します。その結果、メタデータは 11111010 となります。</simpara>
<simpara>また、メタデータをマッチフィールドで用いる場合にも、値とマスクを指定します。マスクで指定されたビットのみ、マッチに用います。</simpara>
</section>
</section>
<section xml:id="_まとめ_2">
<title>まとめ</title>
<simpara>OpenFlow 仕様の中でもとくにポイントとなる部分を見てきました。ここまでの章で学んできた内容だけで、すでに OpenFlow 専門家と言ってもよいほどの知識が身に付いたはずです。次の章では OpenFlow コントローラを開発するためのプログラミングフレームワークである Trema (トレマ) に触れてみましょう。</simpara>
</section>
</chapter>
<chapter xml:id="hello_trema">
<title>Hello, Trema!</title>
<simpara role="lead"><emphasis role="strong">Trema(トレマ)</emphasis>を使うと楽しくSDNの世界が味わえます。これでいよいよあなたもOpenFlowプログラマの仲間入りです!</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/hello_trema/izakaya.png"/>
</imageobject>
<textobject><phrase>izakaya</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_作ってわかるopenflow">
<title>作ってわかるOpenFlow</title>
<simpara>いよいよOpenFlowを使ってネットワークを実際にプログラムしていきます。職場や自宅のような小規模ネットワークでもすぐに試せるコードを通じ、OpenFlowの世界を体験しましょう。実際に手を動かし実行してみれば「OpenFlowってどんな場面で使えるの?」というよくある疑問も徐々に氷解していくでしょう。</simpara>
<simpara>実装はステップバイステップで進みます。最初はOpenFlowやプログラミングの基礎から始めます。そしてパッチパネルやイーサネットスイッチ、ファイアウォール、ルータの実装など徐々に複雑な機能へとステップアップしていきます。そして最終的には、データセンターでも動く本格的なネットワーク仮想化の実装を目標とします。</simpara>
<variablelist>
<varlistentry>
<term>Hello Trema (本章)</term>
<listitem>
<simpara>OpenFlow 版 Hello World</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>スイッチ監視ツール (<link linkend="switch_monitor">4章</link>)</term>
<listitem>
<simpara>スイッチの死活監視ツール</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Cbenchベンチマーク (<link linkend="cbench">5章</link>)</term>
<listitem>
<simpara>OpenFlow のマイクロベンチマークツール</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>パッチパネル (<link linkend="patch_panel">6章</link>)</term>
<listitem>
<simpara>ソフトウェアとして実装したインテリジェント・パッチパネル</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ラーニングスイッチ (<link linkend="learning_switch">7章</link>)</term>
<listitem>
<simpara>イーサネットスイッチをエミュレートするコントローラ</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ラーニングスイッチ OpenFlow1.3 (<link linkend="learning_switch13">8章</link>)</term>
<listitem>
<simpara>ラーニングスイッチの OpenFlow1.3 による実装</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>テスト駆動開発 (<link linkend="tdd">9章</link>)</term>
<listitem>
<simpara>コントローラのテスト駆動開発</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ブリッジ (<link linkend="one_way_bridge">10章</link>)</term>
<listitem>
<simpara>レガシーなネットワークとOpenFlowネットワークのブリッジ</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ファイアウォール (<link linkend="firewall">11章</link>)</term>
<listitem>
<simpara>透過型ファイアウォール</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ルータ (<link linkend="router_part1">12章</link>,<link linkend="router_part2">13章</link>,<link linkend="router13">14章</link>)</term>
<listitem>
<simpara>基本的なレイヤ3スイッチ (ルータ)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>トポロジ (<link linkend="topology">15章</link>)</term>
<listitem>
<simpara>中規模〜大規模ネットワークのトポロジ検知</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ルーティングスイッチ (<link linkend="routing_switch">16章</link>)</term>
<listitem>
<simpara>中規模〜大規模ネットワーク用の仮想レイヤ2スイッチ</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ネットワークスライス (<link linkend="sliceable_switch">17章</link>)</term>
<listitem>
<simpara>ルーティングスイッチに仮想ネットワーク機能を追加</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OpenVNet (<link linkend="openvnet">18章</link>)</term>
<listitem>
<simpara>Tremaベースの商用SDN</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>まずは、OpenFlowプログラミングのためのフレームワーク、Tremaを改めて紹介します。</simpara>
</section>
<section xml:id="_tremaとは">
<title>Tremaとは</title>
<simpara>TremaはOpenFlowコントローラを開発するためのフリーソフトウェアです。GitHub上でオープンに開発を進める、GPL2ライセンスのフリーソフトウェアです。その強力な機能や使いやすさから、国内外の企業・大学・研究機関などの幅広い組織が採用しています。</simpara>
<simpara>Tremaの情報はおもに次のURLから入手できます。</simpara>
<variablelist>
<varlistentry>
<term>Tremaホームページ</term>
<listitem>
<simpara><link xl:href="https://trema.github.com/trema/">https://trema.github.com/trema/</link></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>GitHubのプロジェクトページ</term>
<listitem>
<simpara><link xl:href="https://github.com/trema/">https://github.com/trema/</link></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>メーリングリスト</term>
<listitem>
<simpara><link xl:href="http://groups.google.com/group/trema-dev/">http://groups.google.com/group/trema-dev/</link></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Twitterアカウント</term>
<listitem>
<simpara><link xl:href="https://twitter.com/trema_news">https://twitter.com/trema_news</link></simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Tremaの特徴はRuby on Rails<footnote><simpara>Web プログラミングフレームワークの一つ。http://rubyonrails.org/</simpara></footnote>と同じく「プログラミングフレームワーク」を謳っていることです。でも、プログラミングフレームワークとはいったい何でしょうか。</simpara>
<simpara>Webサービスの世界では、90年代半ばには原始的なプログラミングが開発の主流でした。HTTPプロトコルを意識した低レベルなCGIをCやPerlで書かねばならず、ごく単純な掲示板サービスを作るのにも大量のコーディングが伴いました。</simpara>
<simpara>しかし2000年代に入り状況は一変します。より生産性の高い開発手法の登場 — プログラミングフレームワークによるアジャイル開発 — によって一気にWebサービスは「カンブリア爆発」を迎えました。Railsを代表とするWebプログラミングフレームワークは、HTTPプロトコルの詳細を抽象化した高レベルなAPIを提供します。また、RubyやPythonをはじめとするスクリプティング言語の採用や、開発全体をラップトップPC1台で完結できる数々の開発支援ツールの提供によって、生産性を劇的に向上します。</simpara>
<simpara>この流れをOpenFlow界にも吹き込んだのがTremaです。Tremaは「OpenFlow版Rails」を合言葉として、2011年に初のOpenFlowプログラミングフレームワークとして登場しました。開発言語にはRailsと同じくRubyを採用し、また高レベルなOpenFlow APIを提供することで、プログラマはごく短いコードでOpenFlowコントローラを実装できます。また強力なOpenFlow開発ツール群を提供することで、ソフトウェアテストを中心とした反復的で段階的なアジャイル開発を可能にします。</simpara>
<simpara>こうした強力なツールの一つがTremaの仮想ネットワーク機能です。OpenFlowスイッチを持っていない開発者でも、Tremaを使えばラップトップPC1台の中に仮想的なOpenFlowネットワークを作り、そこで自分の開発したコントローラを実行できます。この「作ったものをすぐに実行できる」という利点は、生産性の向上だけでなくSDNやOpenFlowのような新しい技術の習得にもつながります。正しい理解のためには概念の理解に加えて実践、つまり実際に手を動かすことが欠かせないからです。</simpara>
<simpara>ここからは実際にTremaを使ってOpenFlowコントローラを作り、そして動かしていきます。まずはTremaの実行環境をセットアップしましょう。</simpara>
<note>
<title>Tremaの由来は?</title>
<simpara>Tremaの名前は、著者の一人がファンである「とれまレコード」(<link xl:href="http://www.fumiyatanaka.com/toremarecords/">http://www.fumiyatanaka.com/toremarecords/</link>) という大阪の小さなレコードレーベルの名前から来ています。とれまレコードの楽曲は国内だけでなく海外でも人気があり、海外のクラブチャートにもよくランクインします。</simpara>
<simpara>この「とれまレコード」の名前には面白い由来があります。日本がバブルの頃、道路上の「とまれ」という標示がよく「とれま」と間違えて描かれており、これに目をつけたレーベルオーナーが「とれまレコード」と名付けたのだそうです。</simpara>
<simpara>このありえないミスの原因は、バブル景気時代にまでさかのぼります。当時の景気に乗って急増した外国人労働者達は、日本語もままならないまま工事現場で働いていました。そのおかげで道路に「とれま」と描いてしまう珍事が発生したのだそうです。</simpara>
<figure xml:id="trema_logo">
<title>Tremaの公式ロゴ</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/hello_trema/trema_logo.png"/>
</imageobject>
<textobject><phrase>trema logo</phrase></textobject>
</mediaobject>
</figure>
<simpara>この逸話にのっとって、Tremaの公式ロゴも<link linkend="trema_logo">図 3-A</link>のとおり道路標識の写真になっています。……ちなみに、こんな道路標識は日本中どこを探してもありません! 本書の編集者が画像編集ソフトで試しに作ってみたところ評判が良かったので、そのまま公式ロゴになりました。</simpara>
</note>
</section>
<section xml:id="_trema実行環境のセットアップ">
<title>Trema実行環境のセットアップ</title>
<simpara>TremaはLinux用のソフトウェアです。次のLinuxディストリビューションでの動作を確認しています。</simpara>
<itemizedlist>
<listitem>
<simpara>Ubuntu Linux</simpara>
</listitem>
<listitem>
<simpara>Debian GNU/Linux</simpara>
</listitem>
<listitem>
<simpara>CentOS 6 系, 7 系</simpara>
</listitem>
</itemizedlist>
<simpara>Tremaに必要なソフトウェアは次の4つです。</simpara>
<variablelist>
<varlistentry>
<term>sudo</term>
<listitem>
<simpara>Trema が root 権限でコマンドを実行するのに使います。あらかじめ、<literal>sudo</literal> コマンドを使って root 権限でコマンドを実行できるかどうか、sudo の設定ファイルを確認しておいてください。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Ruby</term>
<listitem>
<simpara>Trema の実行には Ruby のバージョン 2.0 以降が必要です。Trema を使ったコントローラの開発にも Ruby を使います。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Bundler <footnote><simpara><link xl:href="https://bundler.io/">https://bundler.io/</link></simpara></footnote></term>
<listitem>
<simpara>Ruby ライブラリのインストーラです。Trema 本体と実行に必要なライブラリ一式を自動的にインストールするのに使います。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Open vSwitch <footnote><simpara><link xl:href="http://openvswitch.org/">http://openvswitch.org/</link></simpara></footnote></term>
<listitem>
<simpara>OpenFlow に対応したソフトウェアスイッチの一種です。Trema の仮想ネットワーク機能で使用します。</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="_rubyのインストール">
<title>Rubyのインストール</title>
<simpara>Rubyのインストール方法は、Linuxディストリビューションごとに異なります。</simpara>
<section xml:id="_ubuntu_debianにインストールする場合">
<title>Ubuntu/Debianにインストールする場合</title>
<simpara>標準のパッケージマネージャ apt で以下のようにRuby関連パッケージをインストールします。</simpara>
<screen>$ sudo apt-get update
$ sudo apt-get install ruby2.0 ruby2.0-dev build-essential</screen>
<simpara>なお build-essential パッケージは Trema が依存する外部ライブラリのインストールに必要な gcc コンパイラなどを含んでいます。</simpara>
</section>
<section xml:id="_centos_にインストールする場合">
<title>CentOS にインストールする場合</title>
<simpara>標準のパッケージマネージャ yum で以下のようにRuby関連パッケージをインストールします。</simpara>
<screen>$ sudo yum update
$ sudo yum install ruby ruby-devel gcc gcc-c++</screen>
<simpara>なお gcc と gcc-c++ パッケージは Trema が依存する外部ライブラリのインストールに必要です。</simpara>
</section>
</section>
<section xml:id="_bundler_のインストール">
<title>Bundler のインストール</title>
<simpara>Bundler は次のコマンドでインストールできます。</simpara>
<screen>$ gem install bundler</screen>
<simpara>なお <literal>gem</literal> は Ruby の標準ライブラリ形式 .gem をインストールするコマンドです。ここでは最新版の Bundler の .gem を自動的にダウンロードしてインストールしています。</simpara>
</section>
<section xml:id="_open_vswitchのインストール">
<title>Open vSwitchのインストール</title>
<simpara>Open vSwitchのインストール方法も、Linuxディストリビューションごとに異なります。</simpara>
<section xml:id="_ubuntu_debian_にインストールする場合">
<title>Ubuntu/Debian にインストールする場合</title>
<simpara>Open vSwitchも <literal>apt-get</literal> コマンドで簡単にインストールできます。</simpara>
<screen>$ sudo apt-get install openvswitch-switch</screen>
</section>
<section xml:id="_centos_にインストールする場合_2">
<title>CentOS にインストールする場合</title>
<simpara><literal>yum</literal> コマンドでOpen vSwitchをインストールします。RDO(RPM Distribution of OpenStack)<footnote><simpara><link xl:href="https://www.rdoproject.org/Main_Page">https://www.rdoproject.org/Main_Page</link></simpara></footnote>というRedHat系Linux用のOpenStackパッケージリポジトリを使うと、簡単にインストールできます。</simpara>
<screen>$ sudo yum update
$ sudo yum install https://rdoproject.org/repos/rdo-release.rpm
$ sudo yum install openvswitch
$ sudo systemctl start openvswitch.service</screen>
<simpara>以上でTremaを使うための準備が整いました。それでは早速、入門の定番Hello, Worldを書いて実行してみましょう。</simpara>
</section>
</section>
</section>
<section xml:id="_hello_trema">
<title>Hello, Trema!</title>
<simpara>Hello Trema!はもっとも簡単なOpenFlowコントローラです。その唯一の機能は、スイッチと接続して <literal>Hello, 0xabc!</literal> (<literal>0xabc</literal> はスイッチのユニーク ID) と表示するだけです。このように機能は単純ですが、そのソースコードはTremaでコントローラを作るのに必要な基本知識をすべて含んでいます。</simpara>
<section xml:id="_hello_tremaを書く">
<title>Hello Tremaを書く</title>
<simpara>コントローラの実装はプロジェクト用ディレクトリを作ることから始めます。まずは次のように、Hello Trema!用の空のディレクトリ <literal>hello_trema/</literal> と、ソースコード用ディレクトリ <literal>hello_trema/lib/</literal> を <literal>mkdir -p</literal> コマンドで新たに作ってください。</simpara>
<screen>$ mkdir -p hello_trema/lib
$ cd hello_trema</screen>
<section xml:id="_プロジェクトディレクトリの中身">
<title>プロジェクトディレクトリの中身</title>
<simpara>プロジェクトディレクトリには、コントローラに関連するすべてのファイルを置きます。コントローラのソースコードをはじめ、README.mdやLICENSEといったドキュメント類、コントローラの動作をテストするためのテストファイル、そして各種設定ファイルがここに入ります。</simpara>
<simpara>プロジェクトディレクトリのお手本として、GitHub の <literal>trema/hello_trema</literal> リポジトリ (<link xl:href="https://github.com/trema/hello_trema">https://github.com/trema/hello_trema</link>) を見てみましょう。このリポジトリは、標準的な Ruby プロジェクトのファイル構成に従っています。次に主要なファイルを挙げます。</simpara>
<variablelist>
<varlistentry>
<term><literal>README.md</literal></term>
<listitem>
<simpara>メインのドキュメント</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>LICENSE</literal></term>
<listitem>
<simpara>配布ライセンスの指定</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>CHANGELOG.md</literal></term>
<listitem>
<simpara>開発履歴</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Gemfile</literal></term>
<listitem>
<simpara>実行に必要なgemパッケージの定義</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Rakefile</literal></term>
<listitem>
<simpara>開発用タスク</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>lib/</literal></term>
<listitem>
<simpara>コントローラの実装</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>features/</literal></term>
<listitem>
<simpara>受け入れテスト</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>spec/</literal></term>
<listitem>
<simpara>ユニットテスト</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>tasks/</literal></term>
<listitem>
<simpara>開発用タスク定義</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>このうち受け入れテスト関連の <literal>features/</literal> ディレクトリについては、9 章「<link linkend="tdd">Trema でテスト駆動開発</link>」で詳しく説明します。</simpara>
</note>
</section>
<section xml:id="_コントローラ本体の実装">
<title>コントローラ本体の実装</title>
<simpara>エディタで <literal>hello_trema</literal> ディレクトリ内の <literal>lib/hello_trema.rb</literal> を開き、次の Ruby コードを入力してください。<literal>.rb</literal> は Ruby プログラムの標準的な拡張子です。Ruby の文法は必要に応じておいおい説明しますので、もしわからなくても気にせずそのまま入力してください。</simpara>
<formalpara>
<title>lib/hello_trema.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># Hello World!
class HelloTrema &lt; Trema::Controller
  def start(_args)
    logger.info 'Trema started.'
  end

  def switch_ready(datapath_id)
    logger.info "Hello #{datapath_id.to_hex}!"
  end
end</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_スイッチの定義">
<title>スイッチの定義</title>
<simpara>Hello Trema! の実行には OpenFlow スイッチが 1 台必要です。さきほどインストールした Open vSwitch を Hello Trema コントローラに接続することにしましょう。次の設定ファイル <literal>trema.conf</literal> をエディタで <literal>hello_trema/</literal> ディレクトリ直下に作成してください。</simpara>
<formalpara>
<title>trema.conf</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">vswitch { datapath_id 0xabc }</programlisting>
</para>
</formalpara>
<simpara>コントローラを実行する際にこの設定ファイルを指定することで、Open vSwitch を起動しコントローラに接続できます。</simpara>
<simpara>この設定ファイルでは1台のソフトウェアスイッチを定義しています。<literal>vswitch</literal> で始まる行が1台の仮想スイッチに対応します。続く波括弧(<literal>{ }</literal>)内で指定している <literal>datapath_id</literal> (<literal>0xabc</literal>) は、仮想スイッチを識別するための16進数の値です。</simpara>
<simpara>この <emphasis role="strong">Daptapath ID</emphasis> とはちょうどMACアドレスのような存在で、スイッチを一意に特定するIDとして使います。OpenFlowの仕様では、この値には64ビットの一意な整数値を割り振ることになっています。仮想スイッチでは好きな値を設定できるので、もし複数台の仮想スイッチを作る場合にはお互いがぶつからないように注意してください。</simpara>
<note>
<title>Datapath ってどういう意味？</title>
<simpara>実用的には「Datapath = OpenFlowスイッチ」と考えて問題ありません。”データパス”で検索すると、「CPUは演算処理を行うデータパスと、指示を出すコントローラから構成されます」というハードウェア教科書の記述が見つかります。つまり、ハードウェアの世界では一般に</simpara>
<itemizedlist>
<listitem>
<simpara>筋肉にあたる部分 = データパス</simpara>
</listitem>
<listitem>
<simpara>脳にあたる部分 = コントローラ</simpara>
</listitem>
</itemizedlist>
<simpara>という分類をするようです。</simpara>
<simpara>OpenFlowの世界でも同じ用法を踏襲しています。OpenFlowのデータパスはパケット処理を行うスイッチを示し、その制御を行うソフトウェア部分をコントローラと呼びます。</simpara>
</note>
</section>
<section xml:id="_trema_のインストール">
<title>Trema のインストール</title>
<simpara>Hello Trema の実行にはもちろん Trema が必要です。実行に必要な Ruby のアプリケーションやライブラリの gem を <literal>hello_trema/</literal> ディレクトリ直下の <literal>Gemfile</literal> というファイルに次のように書くことで、Hello Trema の実行環境として Trema を使うということを指定します。</simpara>
<formalpara>
<title>Gemfile</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">source 'https://rubygems.org/' <co xml:id="CO1-1"/>

gem ‘trema’<co xml:id="CO1-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>gem の取得元として標準的な <link xl:href="https://rubygems.org">https://rubygems.org</link> を指定する</para>
</callout>
<callout arearefs="CO1-2">
<para>実行環境に Trema を追加する</para>
</callout>
</calloutlist>
<simpara>Gemfile に記述した実行環境のセットアップには Bundler を使います。<literal>hello_trema</literal> ディレクトリ直下で次の <literal>bundle install --binstubs</literal> コマンドを実行すると、<literal>Gemfile</literal> に記述した Trema と Trema が依存する <literal>.gem</literal> ファイル一式を自動的にインストールし、Trema の実行コマンド <literal>trema</literal> を <literal>bin/</literal> ディレクトリに生成します。</simpara>
<screen>$ bundle install --binstubs
$ ./bin/trema --version
trema version 0.9.0</screen>
<simpara>実行に最低限必要なコードはこれだけです。それでは細かい部分は後で説明するとして「習うより慣れろ」でさっそく実行してみましょう。</simpara>
</section>
<section xml:id="_実行してみよう_trema_run">
<title>実行してみよう(trema run)</title>
<simpara>作成したコントローラは <literal>trema run</literal> コマンドですぐに実行できます。Rubyはインタプリタ言語なので、コンパイルの必要はありません。ターミナルで次のように入力し、コントローラを起動してみてください。</simpara>
<screen>$ ./bin/trema run ./lib/hello_trema.rb -c trema.conf
Trema started.
Hello, 0xabc! <co xml:id="CO2-1"/>
$</screen>
<calloutlist>
<callout arearefs="CO2-1">
<para>kbd:[Ctrl+c] でコントローラを終了</para>
</callout>
</calloutlist>
<simpara>このように <literal>Trema started. Hello, 0xabc!</literal> と出力できたら成功です。</simpara>
<simpara>ここまで見てきたように、<literal>trema</literal> コマンドを使うと、とても簡単にコントローラを実行できます。<literal>trema</literal> コマンドには他にもいくつかの機能がありますので、ここで簡単に紹介しておきましょう。</simpara>
</section>
</section>
</section>
<section xml:id="_trema_コマンド">
<title>trema コマンド</title>
<simpara><literal>trema</literal> コマンドは Trema 唯一のコマンドラインツールであり、コントローラの起動やテストなどさまざまな用途に使います。</simpara>
<simpara>たとえばHello, Trema!で見たように、<literal>trema run</literal> はコントローラの起動コマンドです。起動したコントローラは OpenFlow スイッチと接続しメッセージをやりとりします。また、<literal>trema run</literal> コマンドに <literal>-c</literal> (<literal>--conf</literal>) オプションを指定することで、コントローラを仮想ネットワークのスイッチとも接続できます (<link linkend="trema_run_command">図 3-1</link>)。</simpara>
<figure xml:id="trema_run_command">
<title>trema runコマンドの実行イメージ</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/hello_trema/trema_overview.png"/>
</imageobject>
<textobject><phrase>trema overview</phrase></textobject>
</mediaobject>
</figure>
<simpara><literal>trema</literal> コマンドは <literal>git</literal> や <literal>svn</literal> コマンドと似たコマンド体系を持っています。<literal>trema</literal> に続けて <literal>run</literal> などのサブコマンドを指定することで、さまざまな機能を呼び出します。こうしたコマンド体系を一般に「コマンドスイート」と呼びます。</simpara>
<simpara>一般的なコマンドスイートと同じく、サブコマンドの一覧は <literal>trema help</literal> で表示できます。また、サブコマンド自体のヘルプは <literal>trema help サブコマンド名</literal> で表示できます。以下に、<literal>trema help</literal> で表示されるサブコマンド一覧をざっと紹介しておきます。それぞれの使い方は続く章で説明していきますので、今は目を通すだけでかまいません。</simpara>
<variablelist>
<varlistentry>
<term><literal>trema run</literal></term>
<listitem>
<simpara>コントローラをフォアグラウンドまたはバックグラウンド (デーモンモード) で実行する</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>trema killall</literal></term>
<listitem>
<simpara>バックグラウンドで起動している Trema プロセス全体を停止する</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>trema stop</literal></term>
<listitem>
<simpara>指定した仮想ホストまたは仮想スイッチを停止する</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>trema start</literal></term>
<listitem>
<simpara>指定した仮想ホストまたは仮想スイッチを再び有効にする</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>trema send_packets</literal></term>
<listitem>
<simpara>仮想ネットワーク内でテストパケットを送信する</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>trema show_stats</literal></term>
<listitem>
<simpara>仮想ホストで送受信したパケットの統計情報を表示する</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>trema reset_stats</literal></term>
<listitem>
<simpara>仮想ホストで送受信したパケットの統計情報をリセットする</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>trema port_down</literal></term>
<listitem>
<simpara>仮想スイッチのポートを落とす</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>trema port_up</literal></term>
<listitem>
<simpara>仮想スイッチのポートを上げる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>trema delete_link</literal></term>
<listitem>
<simpara>仮想ネットワーク内の仮想リンクを切る</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>trema netns</literal></term>
<listitem>
<simpara>仮想ホストのネットワークネームスペースでコマンドを実行する</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>trema dump_flows</literal></term>
<listitem>
<simpara>仮想スイッチのフローテーブルを表示する</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>では、気になっていた Ruby の文法にそろそろ進みましょう。今後はたくさん Ruby を使いますが、その都度必要な文法を説明しますので心配はいりません。しっかりついてきてください。</simpara>
</section>
<section xml:id="_即席ruby入門">
<title>即席Ruby入門</title>
<simpara>Rubyを習得する一番の近道は、コードを構成する各要素の種類(品詞)を押さえることです。これは、外国語を習得するコツに近いものがあります。ただし外国語と違い、Rubyの構成要素にはその品詞を見分けるための視覚的なヒントがかならずあります。このためRubyのコードはずいぶんと読みやすくなっています。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">品詞</entry>
<entry align="left" valign="top">例</entry>
<entry align="left" valign="top">視覚的ヒント</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>定数</simpara></entry>
<entry align="left" valign="top"><simpara><literal>HelloTrema</literal>, <literal>Trema::Controller</literal></simpara></entry>
<entry align="left" valign="top"><simpara>大文字で始まる</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>インスタンス変数</simpara></entry>
<entry align="left" valign="top"><simpara><literal>@switches</literal>, <literal>@name</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>@</literal> で始まる</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>シンボル</simpara></entry>
<entry align="left" valign="top"><simpara><literal>:match</literal>, <literal>:actions</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>:</literal> で始まる</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>インスタンス変数とシンボルについては<link linkend="switch_monitor">4 章「スイッチ監視ツール」</link>で詳しく説明します。</simpara>
</note>
<simpara>このように最初の文字を見れば、それがどんな品詞かすぐにわかります。たとえば、大文字で始まる名前はかならず定数です。品詞がわかれば、そのRubyコードがどんな構造かも見えてきます。これからそれぞれの品詞について順に説明していきますが、最初からすべてが理解できなくとも構いません。しばらくすればRubyコードのあらゆる部分が識別できるようになっているはずです。</simpara>
<section xml:id="_定数">
<title>定数</title>
<simpara><literal>HelloTrema</literal> や <literal>Trema::Controller</literal> など、大文字で始まる名前が<emphasis role="strong">定数</emphasis>です。Rubyの定数は英語や日本語といった自然言語における固有名詞にあたります。</simpara>
<formalpara>
<title>lib/hello_world.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># Hello World!
class HelloTrema &lt; Trema::Controller <co xml:id="CO3-1"/>
  def start(_args)
    logger.info 'Trema started.'
  end

  def switch_ready(datapath_id)
    logger.info "Hello #{datapath_id.to_hex}!"
  end
end</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO3-1">
<para><literal>HelloTrema</literal> と <literal>Trema::Controller</literal> が定数</para>
</callout>
</calloutlist>
<simpara>英語でも固有名詞は大文字で始めることになっています。たとえば英語のTokyo Tower(東京タワー)がそうです。東京タワーは動かすことができませんし、何か別なものに勝手に変えることもできません。このように、固有名詞は時間とともに変化しないものを指します。そして固有名詞と同様、Rubyの定数は一度セットすると変更できません。もし変更しようとすると、次のように警告が出ます。</simpara>
<screen>$ irb
&gt; TokyoTower = "東京都港区芝公園4丁目2-8"
&gt; TokyoTower = "増上寺の近く"
(irb):2: warning: already initialized constant TokyoTower
(irb):1: warning: previous definition of TokyoTower was here
=&gt; "東京都港区芝公園4丁目2-8"</screen>
<note>
<simpara>ここで使っている <literal>irb</literal> (Interactive Ruby) は Ruby のインタラクティブな実行ツールです。ちょっとしたサンプルコードを試したり、Rubyの挙動を調べるのに便利です。</simpara>
</note>
<simpara><literal>class</literal> に続く定数は<emphasis role="strong">クラス定義</emphasis>です。Hello, Trema!の例では <literal>HelloTrema</literal> がクラス名です。「<literal>class</literal> +クラス名」から始まるクラス定義は、同じ字下げレベルの <literal>end</literal> までの範囲です。</simpara>
<formalpara>
<title>lib/hello_trema.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">class HelloTrema &lt; Trema::Controller <co xml:id="CO4-1"/>
  def start(_args)
    logger.info "Trema started."
  end

  def switch_ready(datapath_id)
    logger.info "Hello #{datapath_id.to_hex}!"
  end
end <co xml:id="CO4-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO4-1">
<para>HelloTremaクラス定義の始まり</para>
</callout>
<callout arearefs="CO4-2">
<para>クラス定義の終わり</para>
</callout>
</calloutlist>
<section xml:id="_コントローラクラスの継承">
<title>コントローラクラスの継承</title>
<simpara>Tremaではすべてのコントローラはクラスとして定義し、Tremaの提供する <literal>Trema::Controller</literal> クラスをかならず継承します。クラスを継承するには、<literal>class クラス名 &lt; 親クラス名</literal> と書きます.</simpara>
<formalpara>
<title>lib/hello_trema.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">class HelloTrema &lt; Trema::Controller <co xml:id="CO5-1"/>
  ...
end</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO5-1">
<para><literal>Trema::Controller</literal> クラスを継承した <literal>HelloTrema</literal> クラスを定義</para>
</callout>
</calloutlist>
<simpara><literal>Trema::Controller</literal> クラスを継承することで、コントローラに必要な基本機能が <literal>HelloTrema</literal> クラスに追加されます。たとえば次に説明するハンドラもその基本機能の一つです。</simpara>
</section>
</section>
<section xml:id="_ハンドラの定義">
<title>ハンドラの定義</title>
<simpara>さて、こうして定義した <literal>HelloTrema</literal> クラスはどこから実行が始まるのでしょうか。C言語で言う <literal>main()</literal> 関数に当たるものがどこにも見あたりません。</simpara>
<simpara>その答はTremaの動作モデルであるイベントドリブンモデルにあります。Tremaのコントローラは、さまざまなイベントに反応するイベントハンドラ (以下、<emphasis role="strong">ハンドラ</emphasis>と呼びます) をいくつも持ちます。コントローラが動作するのは、さまざまなイベントに対してハンドラが反応したときです。</simpara>
<simpara>ハンドラの定義は <literal>def</literal> に続く名前から <literal>end</literal> までの部分で、実際には<emphasis role="strong">メソッド</emphasis>定義です。たとえば <literal>HelloTrema</literal> の例では <literal>start</literal> ハンドラと <literal>switch_ready</literal> ハンドラを定義しています。ハンドラ名の後のカッコで囲まれた部分 (<literal>_args</literal> と <literal>datapath_id</literal>) はそれぞれのメソッドに渡される引数です。</simpara>
<formalpara>
<title>lib/hello_trema.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">class HelloTrema &lt; Trema::Controller
  def start(_args) <co xml:id="CO6-1"/>
    logger.info "Trema started."
  end

  def switch_ready(datapath_id) <co xml:id="CO6-2"/>
    logger.info "Hello #{datapath_id.to_hex}!"
  end
end</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO6-1">
<para><literal>start</literal> ハンドラの定義</para>
</callout>
<callout arearefs="CO6-2">
<para><literal>switch_ready</literal> ハンドラの定義</para>
</callout>
</calloutlist>
<variablelist>
<varlistentry>
<term>start ハンドラ</term>
<listitem>
<simpara>コントローラの起動イベント発生時、つまり <literal>trema run</literal> でコントローラを起動したときに自動で呼び出します。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>switch_ready ハンドラ</term>
<listitem>
<simpara>スイッチがコントローラに接続し、初期化が完了したときに自動で呼び出します。</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<title>Rubyのイディオム: アンダーバー (<literal>_</literal>) で始まる引数名</title>
<simpara>メソッドの中で使わない引数は、<literal>_args</literal> のようにアンダーバーで始めます。これによって、この引数はメソッドの中で使われていないことが一目でわかります。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># メソッド内で _args は使っていない
def start(_args)
  logger.info "Trema started."
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># メソッド内で args を使っている
def start(args)
  logger.info "Arguments = #{args.join ', '}"
end</programlisting>
</note>
<simpara>このほかにTremaでよく使うハンドラをリストアップしておきます。</simpara>
<variablelist>
<varlistentry>
<term>switch_disconnected ハンドラ</term>
<listitem>
<simpara>スイッチがコントローラから切断したときに呼び出します。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>packet_in ハンドラ</term>
<listitem>
<simpara>Packet In メッセージ (<link linkend="cbench">5 章「マイクロベンチマークCbench」</link>で紹介) がコントローラへ到着したときに呼び出します。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>flow_removed ハンドラ</term>
<listitem>
<simpara>フローが消えたときのFlow Removedメッセージ到着時に呼び出します。</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<title>ハンドラの自動呼び出し</title>
<simpara>「ハンドラを定義しただけで、なぜ自動的に呼び出せるんだろう?」と不思議に思う人もいるでしょう。コード中にどんなメソッドがあるか、というコンパイル時情報をプログラム自身が実行時に知るためには、言語処理系の助けが必要です。</simpara>
<simpara>Rubyではオブジェクトが自らの持つメソッドを実行時に調べられます。これをイントロスペクション(リフレクションや自己反映計算などとも言う)と呼びます。たとえばPacket Inメッセージが到着したとき、コントローラはイントロスペクションして自分が <literal>packet_in</literal> メソッドを持っているかどうかを実行時に調べます。そしてもし見つかればそのメソッドを呼ぶというわけです。</simpara>
<simpara>この仕組みは <literal>Trema::Controller</literal> クラスを継承したとき、自動的にコントローラへ導入されます。</simpara>
</note>
</section>
<section xml:id="_キーワード">
<title>キーワード</title>
<simpara>Rubyにはたくさんの組込みの語 (<emphasis role="strong">キーワード</emphasis>) があり、それぞれに意味があります。これらのキーワードを変数として使ったり、自分の目的に合わせて意味を変えたりはできません。</simpara>
<screen>alias and BEGIN begin break case class def defined do else elsif END
end ensure false for if in module next nil not or redo rescue retry
return self super then true undef unless until when while yield</screen>
<simpara>このうち、Hello, Trema!では <literal>class</literal>・<literal>def</literal>・<literal>end</literal> の 3 つのキーワードを使いました。先ほど説明したように、<literal>class</literal> キーワードは続く名前のクラスを定義します。そして <literal>def</literal> キーワードは続く名前のメソッドを定義します。</simpara>
<simpara>この <literal>def</literal> や <literal>class</literal> で始まって <literal>end</literal> で終わる領域のことを<emphasis role="strong">ブロック</emphasis>と呼びます。すべてのRubyプログラムはこのブロックがいくつか組み合わさったものです。</simpara>
<simpara>さて、ここまででHello Trema!に必要なRubyの文法は学びました。再びHello Trema!のソースコードに戻りましょう。</simpara>
</section>
<section xml:id="_スイッチの起動を捕捉する">
<title>スイッチの起動を捕捉する</title>
<simpara>新しくスイッチが起動すると <literal>switch_ready</literal> ハンドラが起動します。<literal>switch_ready</literal> ハンドラは、接続したスイッチのDatapath IDを16進形式(0xで始まる文字列)でログに出力します。</simpara>
<formalpara>
<title>HelloTrema#switch_ready (lib/hello_trema.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def switch_ready(dpid)
  logger.info "Hello #{dpid.to_hex}!"
end</programlisting>
</para>
</formalpara>
<note>
<title>switch_readyの中身</title>
<simpara>実は OpenFlow の仕様には <literal>switch_ready</literal> というメッセージは定義されていません。実は、これは Trema が独自に定義するイベントなのです。<literal>switch_ready</literal> の裏では<link linkend="switch_ready">図 3-B</link>に示す一連の複雑な処理が行われていて、Trema がこの詳細をうまくカーペットの裏に隠してくれているというわけです。</simpara>
<figure xml:id="switch_ready">
<title>switch_ready イベントが起こるまで</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/hello_trema/switch_ready.png"/>
</imageobject>
<textobject><phrase>switch ready</phrase></textobject>
</mediaobject>
</figure>
<simpara>最初に、スイッチとコントローラがしゃべる OpenFlow プロトコルが合っているか確認します。OpenFlow の Hello メッセージを使ってお互いにプロトコルのバージョンを知らせ、うまく会話できそうか判断します。</simpara>
<simpara>次は、スイッチを識別するための Datapath ID の取得です。Datapath IDのようなスイッチ固有の情報は、スイッチに対して OpenFlow の Features Request メッセージを送ることで取得できます。成功した場合、Datapath IDや最大テーブル数などの情報が Features Reply メッセージに乗ってやってきます。</simpara>
<simpara>最後にスイッチを初期化します。スイッチに以前の状態が残っているとコントローラが管理する情報と競合が起こるので、スイッチを初期化することでこれを避けます。</simpara>
<simpara>これら一連の処理が終わると、ようやく <literal>switch_ready</literal> がコントローラに通知されるというわけです。</simpara>
</note>
<section xml:id="_datapath_idを16進形式にする">
<title>Datapath IDを16進形式にする</title>
<simpara><literal>to_hex</literal> は整数を16進形式の文字列に変換するメソッドです。<literal>switch_ready</literal> ハンドラの引数 <literal>dpid</literal> の値は64ビットの正の整数で、OpenFlowでは慣習的に <literal>0xfffb</literal> などと16進で表します。この慣習に従って、ターミナルやログに出力する場合には <literal>to_hex</literal> で16進形式に変換しておいたほうがよいでしょう。</simpara>
</section>
<section xml:id="_ログメッセージを出力する">
<title>ログメッセージを出力する</title>
<simpara>ログメッセージを出力するには、<literal>logger</literal> を使います。</simpara>
<formalpara>
<title>HelloTrema#start (lib/hello_trema.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def start(_args)
  logger.info 'Trema started.'
end</programlisting>
</para>
</formalpara>
<simpara><literal>logger</literal> はTrema標準のロガーで、ログメッセージの出力はこれを通じて行います。ログメッセージの重要度に応じて、<literal>unknown</literal> (重要度 最高) から <literal>debug</literal> (重要度 最低) までの次の6種類のメソッドを選べます。</simpara>
<variablelist>
<varlistentry>
<term>unknown</term>
<listitem>
<simpara>不明なエラー。重要度にかかわらず常にロギングする</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>fatal</term>
<listitem>
<simpara>回復不能なエラー</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>error</term>
<listitem>
<simpara>エラー</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>warn</term>
<listitem>
<simpara>警告</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>info</term>
<listitem>
<simpara>通常レベルの情報</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>debug</term>
<listitem>
<simpara>デバッグ出力</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><literal>trema run</literal> のオプションでロギングレベルを指定できます。たとえば次のコードを実行するとしましょう。</simpara>
<formalpara>
<title>ロギングレベルの確認用コード (try_logging.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">class TryLogging &lt; Trema::Controller
  def start(_args)
    logger.unknown 'UNKNOWN'
    logger.fatal 'FATAL'
    logger.error 'ERROR'
    logger.warn 'WARN'
    logger.info 'INFO'
    logger.debug 'DEBUG'
  end
end</programlisting>
</para>
</formalpara>
<simpara>このコードをたとえば次のようにロギングレベル <literal>warn</literal> で実行すると、<literal>info</literal> と <literal>debug</literal> メッセージは出力されません。</simpara>
<screen>$ ./bin/trema run try_logging.rb --logging_level warn
UNKNOWN
FATAL
ERROR
WARN</screen>
<simpara>ログメッセージはログファイルにも記録されます。ログファイルのデフォルトパスは <literal>/tmp/[コントローラのクラス名].log</literal> です。たとえばHelloTremaの場合には <literal>/tmp/HelloTrema.log</literal> になります。ログファイルの出力先ディレクトリを変更するには、<literal>trema run</literal> の <literal>--log_dir</literal> または <literal>-L</literal> オプションを指定します。たとえば次のようにすると、<literal>/var/log/HelloTrema.log</literal> が作られます。</simpara>
<screen>$ ./bin/trema run try_logging.rb --log_dir /var/log/</screen>
</section>
<section xml:id="_文字列に式を組込む">
<title>文字列に式を組込む</title>
<simpara><literal>logger.info</literal> に渡している文字列中の <literal>#{}</literal> は、文字列内にRubyの式を組込みます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">logger.info "Hello #{dpid.to_hex}!"
#=&gt; Hello 0xabc!</programlisting>
<simpara>これは次のコードと同じです。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">logger.info 'Hello ' + dpid.to_hex + '!'
#=&gt; Hello 0xabc!</programlisting>
<simpara>どちらを使っても構いませんが、文字列を <literal>+</literal> でつなげすぎると最終的な出力がコードからはわかりにくくなることがあります。その場合、このように <literal>#{}</literal> で組み込んだほうがよいでしょう。</simpara>
<simpara>これでHello, Trema!の説明はおしまいです。Tremaで作るコントローラは基本的にこのHello, Trema!と同じ構成をしています。これをベースにいくつか必要なハンドラメソッドを追加していけば、より複雑で実践的なコントローラも作れます。</simpara>
</section>
</section>
</section>
<section xml:id="_まとめ_3">
<title>まとめ</title>
<simpara>この章ではTremaの開発環境をセットアップし、すべてのコントローラのテンプレートとなるHello, Trema!コントローラを書きました。この章で学んだことを簡単にまとめてから、より実用的なコントローラの開発に入っていくことにしましょう。</simpara>
<itemizedlist>
<listitem>
<simpara>コントローラはクラスとして定義し、<literal>Trema::Controller</literal> クラスを継承することでコントローラの基本機能を取り込む</simpara>
</listitem>
<listitem>
<simpara>コントローラに機能を追加するには、各種イベントに対応するハンドラをコントローラクラスに定義する</simpara>
</listitem>
<listitem>
<simpara>コントローラは <literal>trema run</literal> コマンドでコンパイルなしにすぐ実行できる</simpara>
</listitem>
<listitem>
<simpara>仮想ネットワーク機能を使うと、OpenFlowスイッチを持っていなくてもコントローラを実行できる</simpara>
</listitem>
</itemizedlist>
<simpara>これでTremaの基礎知識は充分に身に付きました。次の章では、OpenFlowコントローラのためのマイクロベンチマークツール、Cbenchを計測するためのコントローラを書きます。</simpara>
</section>
<section xml:id="_参考文献">
<title>参考文献</title>
<simpara>Rubyプログラミングが初めてという人達のために、この章では入門に役立つサイトや本をいくつか紹介します。</simpara>
<variablelist>
<varlistentry>
<term>『Ruby 2.2.0 リファレンスマニュアル』(<link xl:href="http://docs.ruby-lang.org/ja/2.2.0/doc/">http://docs.ruby-lang.org/ja/2.2.0/doc/</link>)</term>
<listitem>
<simpara>Ruby の完全なリファレンスです。Ruby でプログラミングする際は参照しましょう。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>『メタプログラミングRuby 第2版』(Paolo Perrotta 著／角 征典 訳／オライリージャパン)</term>
<listitem>
<simpara>Ruby プログラムを短く簡潔に書くためのテクニックをたくさん紹介しています。「プロっぽい」 Ruby コードを書きたい人は必読です。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>『Why’s (Poignant) Guide to Ruby』(<link xl:href="http://mislav.uniqpath.com/poignant-guide/">http://mislav.uniqpath.com/poignant-guide/</link>) <footnote><simpara>日本語版は <link xl:href="http://www.aoky.net/articles/why_poignant_guide_to_ruby/">http://www.aoky.net/articles/why_poignant_guide_to_ruby/</link></simpara></footnote></term>
<listitem>
<simpara>Ruby界の伝説的ハッカー_why氏による風変わりで楽しいRuby入門です。この章のRubyの品詞の説明は、このドキュメントを参考にしました。</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</chapter>
<chapter xml:id="switch_monitor">
<title>スイッチ監視ツール</title>
<simpara role="lead">OpenFlowの特長の一つは、たくさんのスイッチを集中管理できることです。その雰囲気を簡単なOpenFlowコントローラを書いて体験してみましょう。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/switch_monitor/scope.png"/>
</imageobject>
<textobject><phrase>scope</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_ネットワークを集中管理しよう">
<title>ネットワークを集中管理しよう</title>
<simpara>OpenFlowではたくさんのスイッチを1つのコントローラで集中制御できます。スイッチにはフローテーブルに従ったパケットの転送という1つの仕事だけをやらせ、頭脳であるコントローラが全体のフローテーブルを統括するというわけです。これによって<link linkend="how_does_openflow_work">1 章「OpenFlow の仕組み」</link>で見てきたように、自動化やさまざまなシステム連携・トラフィック制御のしやすさ・ソフトウェア開発のテクニック適用・水平方向へのアップグレード、といったさまざまなメリットが生まれるのでした。</simpara>
<simpara>本章ではこの集中制御の一例として、スイッチ監視ツールを作ります。このツールは「今、ネットワーク中にどんなスイッチが動いていて、それぞれがどんな状態か」をリアルタイムに表示します。OpenFlowでの集中制御に必要な基本テクニックをすべて含んでいます。</simpara>
<simpara>スイッチ監視ツールは<link linkend="switch_monitor_tool">図 4-1</link>のように動作します。コントローラはスイッチの接続を検知すると、起動したスイッチの情報を表示します。逆にスイッチが予期せぬ障害など何らかの原因で接続を切った場合、コントローラはこれを検知して警告を表示します。</simpara>
<figure xml:id="switch_monitor_overview">
<title>スイッチ監視ツールの動作</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/switch_monitor/switch_monitor_overview.png"/>
</imageobject>
<textobject><phrase>switch monitor overview</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_インストール">
<title>インストール</title>
<simpara>スイッチ監視ツールのソースコードは GitHub から次のようにダウンロードできます。</simpara>
<screen>$ git clone https://github.com/trema/switch_monitor.git</screen>
<simpara>ダウンロードしたソースツリー上で <literal>bundle install --binstubs</literal> を実行すると、Tremaの <literal>./bin/trema</literal> コマンドなど必要な実行環境一式を自動的にインストールできます。</simpara>
<screen>$ cd switch_monitor
$ bundle install --binstubs</screen>
<simpara>以上でスイッチ監視ツールとTremaのセットアップは完了です。</simpara>
</section>
<section xml:id="_実行してみよう">
<title>実行してみよう</title>
<simpara>試しに仮想スイッチ3台の構成でスイッチ監視ツールを起動してみましょう。次の内容の設定ファイルを <literal>switch_monitor.conf</literal> として保存してください。なお、それぞれの <literal>datapath_id</literal> がかぶらないように <literal>0x1</literal>, <literal>0x2</literal>, <literal>0x3</literal> と連番を振っていることに注意してください。</simpara>
<formalpara>
<title>switch_monitor.conf</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">vswitch { datapath_id 0x1 }
vswitch { datapath_id 0x2 }
vswitch { datapath_id 0x3 }</programlisting>
</para>
</formalpara>
<simpara>この構成でスイッチ監視ツールを起動するには、この設定ファイルを <literal>trema run</literal> の <literal>-c</literal> オプションに渡すのでした。スイッチ監視ツールの出力は次のようになります。</simpara>
<screen>$ ./bin/trema run ./lib/switch_monitor.rb -c switch_monitor.conf
SwitchMonitor started.
All =
0x3 is up (All = 0x3) <co xml:id="CO7-1"/>
0x3 manufacturer = Nicira, Inc. <co xml:id="CO7-2"/>
0x3 hardware info = <co xml:id="CO7-3"/>
0x3 software info = <co xml:id="CO7-4"/>
0x3 serial number = <co xml:id="CO7-5"/>
0x3 description = <co xml:id="CO7-6"/>
0x1 is up (All = 0x1, 0x3)
0x1 manufacturer = Nicira, Inc.
0x1 hardware info =
0x1 software info =
0x1 serial number =
0x1 description =
0x2 is up (All = 0x1, 0x2, 0x3)
0x2 manufacturer = Nicira, Inc.
0x2 hardware info =
0x2 software info =
0x2 serial number =
0x2 description =
All = 0x1, 0x2, 0x3
All = 0x1, 0x2, 0x3</screen>
<calloutlist>
<callout arearefs="CO7-1">
<para>スイッチ 0x3 がコントローラに接続</para>
</callout>
<callout arearefs="CO7-2">
<para>スイッチの製造者情報</para>
</callout>
<callout arearefs="CO7-3">
<para>スイッチのハードウェア情報 (空)</para>
</callout>
<callout arearefs="CO7-4">
<para>スイッチのソフトウェア情報 (空)</para>
</callout>
<callout arearefs="CO7-5">
<para>スイッチのシリアル番号 (空)</para>
</callout>
<callout arearefs="CO7-6">
<para>スイッチの詳細情報 (空)</para>
</callout>
</calloutlist>
<simpara><literal>0x1 is up</literal> などの行から、仮想ネットワーク設定ファイルに定義したスイッチ3台をコントローラが検出していることがわかります。続く行では、スイッチの製造者といった詳細情報や、スイッチ一覧 (<literal>All = 0x1, 0x2, 0x3</literal> の行) も確認できます。</simpara>
<simpara>このように実際にスイッチを持っていなくても、設定ファイルを書くだけでスイッチを何台も使ったコントローラの動作テストができます。設定ファイルの <literal>vswitch { &#8230;&#8203; }</literal> の行を増やせば、スイッチをさらに5台、10台、…と足していくことも思いのままです。</simpara>
<section xml:id="_仮想スイッチを停止_再起動してみる">
<title>仮想スイッチを停止/再起動してみる</title>
<simpara>それでは、スイッチの切断をうまく検出できるか確かめてみましょう。仮想スイッチを停止するコマンドは <literal>trema stop</literal> です。<literal>trema run</literal> を実行したターミナルはそのままで別ターミナルを開き、次のコマンドで仮想スイッチ <literal>0x3</literal> を落としてみてください。</simpara>
<screen>$ ./bin/trema stop 0x3</screen>
<simpara>すると、<literal>trema run</literal> を実行したターミナルで新たに <literal>0x3 is down</literal> の行が出力されます。</simpara>
<screen>$ ./bin/trema run ./switch_monitor.rb -c ./switch_monitor.conf
SwitchMonitor started.
All =
0x3 is up (All = 0x3)
0x3 manufacturer = Nicira, Inc.
0x3 hardware info =
0x3 software info =
0x3 serial number =
0x3 description =
……
All = 0x1, 0x2, 0x3
All = 0x1, 0x2, 0x3
All = 0x1, 0x2, 0x3
0x3 is down (All = 0x1, 0x2) <co xml:id="CO8-1"/></screen>
<calloutlist>
<callout arearefs="CO8-1">
<para>スイッチ 0x3 が停止したことを示すログメッセージ</para>
</callout>
</calloutlist>
<simpara>うまくいきました! それでは逆に、さきほど落した仮想スイッチを再び起動してみましょう。仮想スイッチを起動するコマンドは <literal>trema start</literal> です。</simpara>
<screen>$ ./bin/trema start 0x3</screen>
<simpara><literal>0x3 is up</literal> の行が出力されれば成功です。</simpara>
<screen>$ ./bin/trema run ./switch_monitor.rb -c ./switch_monitor.conf
SwitchMonitor started.
All =
0x3 is up (All = 0x3)
0x3 manufacturer = Nicira, Inc.
0x3 hardware info =
0x3 software info =
0x3 serial number =
0x3 description =
……
All = 0x1, 0x2, 0x3
All = 0x1, 0x2, 0x3
0x3 is down (All = 0x1, 0x2)
All = 0x1, 0x2
……
All = 0x1, 0x2
All = 0x1, 0x2
0x3 is up (All = 0x1, 0x2, 0x3) <co xml:id="CO9-1"/></screen>
<calloutlist>
<callout arearefs="CO9-1">
<para>スイッチ 0x3 が再び起動したことを示すログメッセージ</para>
</callout>
</calloutlist>
<simpara>このように、<literal>trema stop</literal> と <literal>trema start</literal> は仮想ネットワークのスイッチを制御するためのコマンドです。引数にスイッチのDatapath IDを指定することで、スイッチを停止または起動してコントローラの反応を確かめられます。</simpara>
<variablelist>
<varlistentry>
<term>trema stop [Datapath ID]</term>
<listitem>
<simpara>指定した仮想スイッチを停止する</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>trema start [Datapath ID]</term>
<listitem>
<simpara>指定した仮想スイッチを再び起動する</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>スイッチ監視ツールの動作イメージがわかったところで、そろそろソースコードの解説に移りましょう。</simpara>
</section>
</section>
<section xml:id="_ソースコード解説">
<title>ソースコード解説</title>
<simpara>まずはざっとスイッチ監視ツールのソースコード(<link linkend="switch_monitor.rb">lib/switch_monitor.rb</link>)を眺めてみましょう。今までに学んできたRubyの品詞を頭の片隅に置きながら、次のコードに目を通してみてください。</simpara>
<formalpara xml:id="switch_monitor.rb">
<title>lib/switch_monitor.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># Switch liveness monitor.
class SwitchMonitor &lt; Trema::Controller
  timer_event :show_all_switches, interval: 10.sec

  def start(_args)
    @switches = []
    logger.info "#{name} started."
  end

  def switch_ready(dpid)
    @switches &lt;&lt; dpid
    logger.info "#{dpid.to_hex} is up (All = #{all_switches_in_string})"
    send_message dpid, DescriptionStats::Request.new
  end

  def switch_disconnected(dpid)
    @switches -= [dpid]
    logger.info "#{dpid.to_hex} is down (All = #{all_switches_in_string})"
  end

  def description_stats_reply(dpid, desc)
    logger.info "Switch #{dpid.to_hex} manufacturer = #{desc.manufacturer}"
    logger.info "Switch #{dpid.to_hex} hardware info = #{desc.hardware}"
    logger.info "Switch #{dpid.to_hex} software info = #{desc.software}"
    logger.info "Switch #{dpid.to_hex} serial number = #{desc.serial_number}"
    logger.info "Switch #{dpid.to_hex} description = #{desc.datapath}"
  end

  private

  def show_all_switches
    logger.info "All = #{all_switches_in_string}"
  end

  def all_switches_in_string
    @switches.sort.map(&amp;:to_hex).join(', ')
  end
end</programlisting>
</para>
</formalpara>
<simpara>新しい品詞や構文がいくつかありますが、今までに学んだ知識だけでこのRubyソースコードの構成はなんとなくわかったはずです。まず、スイッチ監視ツールの本体は <literal>SwitchMonitor</literal> という名前のクラスです。そしてこのクラスにはいくつかハンドラメソッドが定義してあるようです。おそらくそれぞれがスイッチの接続や切断、そして統計情報イベントを処理しているんだろう、ということが想像できれば上出来です。</simpara>
<section xml:id="_スイッチの起動を捕捉する_2">
<title>スイッチの起動を捕捉する</title>
<simpara><literal>switch_ready</literal> ハンドラでは、スイッチ一覧リスト <literal>@switches</literal> に新しく接続したスイッチのDatapath IDを追加し、接続したスイッチの情報を画面に表示します。</simpara>
<formalpara>
<title>SwitchMonitor#switch_ready (lib/switch_monitor.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def switch_ready(dpid)
  @switches &lt;&lt; dpid
  logger.info "#{dpid.to_hex} is up (All = #{all_switches_in_string})"
  send_message dpid, DescriptionStats::Request.new
end</programlisting>
</para>
</formalpara>
<simpara><literal>@switches</literal> は <literal>start</literal> ハンドラで空の配列に初期化されます。</simpara>
<formalpara>
<title>SwitchMonitor#start (lib/switch_monitor.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def start(_args)
  @switches = []
  logger.info "#{name} started."
end</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_インスタンス変数">
<title>インスタンス変数</title>
<simpara>アットマーク(<literal>@</literal>)で始まる語は<emphasis role="strong">インスタンス変数</emphasis>です。インスタンス変数はたとえば人間の歳や身長などといった、属性を定義するときによく使われます。アットマークはアトリビュート (属性) を意味すると考えれば覚えやすいでしょう。</simpara>
<simpara>インスタンス変数は同じクラスの中のメソッド定義内であればどこからでも使えます。具体的な例として次の <literal>Human</literal> クラスを見てください。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class Human
  def initialize
    @age = 0 <co xml:id="CO10-1"/>
  end

  def birthday <co xml:id="CO10-2"/>
    @age += 1
  end
end</programlisting>
<calloutlist>
<callout arearefs="CO10-1">
<para>インスタンス変数を初期化。生まれたときは 0 歳</para>
</callout>
<callout arearefs="CO10-2">
<para>一年に一度、歳をとる</para>
</callout>
</calloutlist>
<simpara><literal>Human</literal> クラスで定義される <literal>Human</literal> オブジェクトは、初期化したときにはそのインスタンス変数 <literal>@age</literal> は0、つまり0歳です。<literal>birthday</literal> を呼び出すたびに歳を取り、<literal>@age</literal> が 1 増えます。このように <literal>@age</literal> は <literal>initialize</literal> および <literal>birthday</literal> メソッドのどちらからでもその値を変更できます。</simpara>
<section xml:id="_配列">
<title>配列</title>
<simpara>配列は角カッコで囲まれたリストで、カンマで区切られています。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>[]</literal> は空の配列</simpara>
</listitem>
<listitem>
<simpara><literal>[1, 2, 3]</literal> は数字の配列</simpara>
</listitem>
<listitem>
<simpara><literal>["バナナ", "みかん", "りんご"]</literal> は文字列の配列</simpara>
</listitem>
</itemizedlist>
<simpara>Rubyの配列はとても直感的に要素を足したり取り除いたりできます。たとえば配列の最後に要素を加えるには <literal>&lt;&lt;</literal> を使います。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">fruits = ["バナナ", "みかん", "りんご"]
fruits &lt;&lt; "パイナップル"
#=&gt; ["バナナ", "みかん", "りんご", "パイナップル"]</programlisting>
<simpara>配列から要素を取り除くには <literal>-=</literal> を使います。これは左右の配列同士を見比べ、共通する要素を取り除いてくれます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">fruits = ["バナナ", "みかん", "テレビ", "りんご", "たわし"]
fruits -= ["テレビ", "たわし"]
#=&gt; ["バナナ", "みかん", "りんご"]</programlisting>
<simpara><emphasis role="strong">配列</emphasis>はRubyで多用するデータ構造で、この他にもたくさんのメソッドがあらかじめ定義されています。もし詳しく知りたい人は<link linkend="hello_trema">3 章「Hello, Trema!」</link>の参考文献で紹介したRubyのサイトや書籍を参照してください。</simpara>
</section>
</section>
<section xml:id="_スイッチの切断を捕捉する">
<title>スイッチの切断を捕捉する</title>
<simpara><literal>switch_disconnected</literal> ハンドラでは、スイッチ一覧リストから切断したスイッチのDatapath IDを削除し、切断したスイッチの情報を画面に表示します。</simpara>
<formalpara>
<title>SwitchMonitor#switch_disconnected (lib/switch_monitor.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def switch_disconnected(dpid)
  @switches -= [dpid]
  logger.info "#{dpid.to_hex} is down (All = #{all_switches_in_string})"
end</programlisting>
</para>
</formalpara>
<simpara>ここでは <literal>switch_ready</literal> とは逆に、配列の引き算 (<literal>-=</literal>) で切断したスイッチのDatapath IDを <literal>@switches</literal> から除いていることに注意してください。</simpara>
</section>
<section xml:id="_スイッチ一覧を一定時間ごとに表示する">
<title>スイッチ一覧を一定時間ごとに表示する</title>
<simpara>スイッチの一覧を一定時間ごとに表示するには、Tremaの<emphasis role="strong">タイマー機能</emphasis>を使います。次のように <literal>timer_event</literal> に続いて一定間隔ごとに呼び出したいメソッドと呼び出し間隔を指定しておくと、指定したメソッドが指定した間隔ごとに呼ばれます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># 1 年に一度、年をとるクラス
class Human &lt; Trema::Controller
  timer_event :birthday, interval: 1.year  <co xml:id="CO11-1"/>
  ...

  private  <co xml:id="CO11-2"/>

  def birthday  <co xml:id="CO11-3"/>
    @age += 1
  end</programlisting>
<calloutlist>
<callout arearefs="CO11-1">
<para>1 年ごとに <literal>birthday</literal> メソッドを呼ぶ</para>
</callout>
<callout arearefs="CO11-2">
<para>この行から下はプライベートメソッド</para>
</callout>
<callout arearefs="CO11-3">
<para>タイマーから呼ばれる <literal>birthday</literal> メソッド</para>
</callout>
</calloutlist>
<simpara>この定義は <literal>Human</literal> クラス定義の先頭に書けるので、まるで <literal>Human</literal> クラスの属性としてタイマーをセットしているように読めます。このようにTremaを使うとタイマー処理も短く読みやすく書けます。</simpara>
<simpara>タイマーから呼び出すメソッドは、クラスの中だけで使うのでよくプライベートなメソッドとして定義します。Rubyでは <literal>private</literal> と書いた行以降のメソッドはプライベートメソッドとして定義され、クラスの外からは見えなくなります。</simpara>
<simpara>これを踏まえてスイッチ監視ツールのソースコードのタイマー部分を見てみましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class SwitchMonitor &lt; Trema::Controller
  timer_event :show_all_switches, interval: 10.sec
  ...

  private

  def show_all_switches
    logger.info "All = #{all_switches_in_string}"
  end</programlisting>
<simpara>クラス名定義直後のタイマー定義より、10秒ごとに <literal>show_all_switches</literal> メソッドを呼んでいることがわかります。</simpara>
<section xml:id="_シンボル">
<title>シンボル</title>
<simpara><emphasis role="strong">シンボル</emphasis>は文字列の軽量版と言える品詞です。<literal>:a</literal>・<literal>:number</literal>・<literal>:show_all_switches</literal> のように必ずコロンで始まり、英字・数字・アンダースコアを含みます。シンボルは定数のように一度決めると変更できないので、文字列のようにいつの間にか書き変わっている心配がありません。このため、ハッシュテーブル (<link linkend="patch_panel">6 章「インテリジェントなパッチパネル」</link>参照) の検索キーとしてよく使われます。</simpara>
<simpara>また、シンボルは誰かにメソッドを名前で渡すときにも登場します。これだけですとわかりづらいと思うので、具体的な例を見ていきましょう。リスト <literal>switch_monitor.rb</literal> には、次のようにシンボルを使っている箇所がありました。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">timer_event :show_all_switches, interval: 10.sec</programlisting>
<simpara>この <literal>:show_all_switches</literal> は <literal>SwitchMonitor</literal> クラスのメソッド名をシンボルで書いたものです。</simpara>
<simpara>もしここでシンボルを使わずに、直接次のように指定するとどうなるでしょうか。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># まちがい!
timer_event show_all_switches, interval: 10.sec</programlisting>
<simpara>これではうまく動きません。なぜならば、ソースコードの中に <literal>show_all_switches</literal> とメソッドの名前を書いた時点でそのメソッドが実行されてしまい、その返り値が <literal>timer_event</literal> へと渡されてしまうからです。</simpara>
<simpara>もしメソッド名を何かに渡すときにはかならずシンボルにする、と覚えましょう。</simpara>
</section>
</section>
<section xml:id="_スイッチの詳細情報を表示する">
<title>スイッチの詳細情報を表示する</title>
<simpara>スイッチの情報を取得するには、取得したい情報をリクエストするメッセージを <literal>send_message</literal> でスイッチに送信し、そのリプライメッセージをハンドラで受け取ります。たとえば、今回のようにスイッチの詳細情報を取得するには、<literal>DescriptionStats::Request</literal> メッセージを送信し、対応するハンドラ <literal>description_stats_reply</literal> でメッセージを受け取ります。</simpara>
<formalpara>
<title>SwitchMonitor#switch_ready, SwitchMonitor#description_stats_reply (lib/switch_monitor.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def switch_ready(dpid)
  @switches &lt;&lt; dpid
  logger.info "#{dpid.to_hex} is up (All = #{all_switches_in_string})"
  send_message dpid, DescriptionStats::Request.new
end

def description_stats_reply(dpid, desc)
  logger.info "Switch #{dpid.to_hex} manufacturer = #{desc.manufacturer}"
  logger.info "Switch #{dpid.to_hex} hardware info = #{desc.hardware}"
  logger.info "Switch #{dpid.to_hex} software info = #{desc.software}"
  logger.info "Switch #{dpid.to_hex} serial number = #{desc.serial_number}"
  logger.info "Switch #{dpid.to_hex} description = #{desc.datapath}"
end</programlisting>
</para>
</formalpara>
<simpara>スイッチの詳細情報のほかにも、さまざまな統計情報を取得できます。OpenFlow 1.0がサポートしている統計情報の一覧は次のとおりです。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">取得できる情報</entry>
<entry align="left" valign="top">スイッチへ送るメッセージ</entry>
<entry align="left" valign="top">ハンドラ名</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>スイッチの詳細情報</simpara></entry>
<entry align="left" valign="top"><simpara><literal>DescriptionStats::Request</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>description_stats_reply</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>単一フローエントリの統計情報</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FlowStats::Request</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>flow_stats_reply</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>複数フローエントリの統計情報</simpara></entry>
<entry align="left" valign="top"><simpara><literal>AggregateStats::Request</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>aggregate_stats_reply</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>フローテーブルの統計情報</simpara></entry>
<entry align="left" valign="top"><simpara><literal>TableStats::Request</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>table_stats_reply</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>スイッチポートの統計情報</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PortStats::Request</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>port_stats_reply</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>キューの統計情報</simpara></entry>
<entry align="left" valign="top"><simpara><literal>QueueStats::Request</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>queue_stats_reply</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_まとめ_4">
<title>まとめ</title>
<simpara>この章ではスイッチの動作状況を監視するスイッチ監視ツールを作りました。また、作ったスイッチ監視ツールをテストするため Trema の仮想ネットワーク機能を使いました。</simpara>
<itemizedlist>
<listitem>
<simpara>スイッチの起動と切断を捕捉するには、<literal>switch_ready</literal> と <literal>switch_disconnected</literal> ハンドラメソッドを定義する</simpara>
</listitem>
<listitem>
<simpara>スイッチの詳細情報を取得するには、<literal>DescriptionStats::Request</literal> メッセージをスイッチへ送信し <literal>description_stats_reply</literal> ハンドラでリプライを受信する</simpara>
</listitem>
<listitem>
<simpara>タイマー (<literal>timer_event</literal>) を使うと一定間隔ごとに指定したメソッドを起動できる</simpara>
</listitem>
<listitem>
<simpara><literal>trema start</literal> と <literal>trema stop</literal> コマンドで仮想ネットワーク内のスイッチを起動/停止できる</simpara>
</listitem>
</itemizedlist>
<simpara>続く章では、いよいよ OpenFlow の最重要メッセージである Packet In と Flow Mod を使ったプログラミングに挑戦です。</simpara>
</section>
</chapter>
<chapter xml:id="cbench">
<title>マイクロベンチマークCbench</title>
<simpara role="lead">本格的なOpenFlowプログラミングの第一歩として、スイッチのフローテーブルを書き換えてみましょう。マイクロベンチマークツールCbenchを題材に、Packet InとFlow Modメッセージの使い方を学びます。</simpara>
<section xml:id="_cbenchベンチマークとは">
<title>Cbenchベンチマークとは</title>
<simpara>CbenchはOpenFlow1.0コントローラのためのベンチマークです。このベンチマークの内容は、1秒あたりにコントローラが出せるFlow Modの数を計測するというものです。これはOpenFlowプロトコル全体のうちのごく一部の性能だけを対象にしているので、ベンチマークの中でもマイクロベンチマークに分類できます。</simpara>
<simpara>Cbenchは<link linkend="cbench_overview">図 5-1</link>のように動作します。まずcbenchプロセスはOpenFlowスイッチのふりをしてコントローラに接続し、コントローラにPacket Inを連続して送ります。コントローラはPacket Inを受け取るとcbenchプロセスにFlow Modを返します。cbenchプロセスは決められた時間の間に受け取ったFlow Modの数をカウントし、ベンチマークのスコアとします。つまり大量のPacket Inに反応し素早くFlow Modを返せるコントローラほど「速い」とみなします。</simpara>
<figure xml:id="cbench_overview">
<title>cbenchプロセスとコントローラの動作</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/cbench/cbench_overview.png"/>
</imageobject>
<textobject><phrase>cbench overview</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_インストール_2">
<title>インストール</title>
<simpara>Cbenchの実行にはopenflow.org <footnote><simpara><link xl:href="http://archive.openflow.org/">http://archive.openflow.org/</link></simpara></footnote> の配布するベンチマークスイートOflopsを使います。GitHubのtrema/cbenchリポジトリには、Oflops一式とCbenchコントローラのソースコードが入っています。次のコマンドでダウンロードしてください。</simpara>
<screen>$ git clone https://github.com/trema/cbench.git</screen>
<simpara>ダウンロードしたソースツリー上で <literal>bundle install --binstubs</literal> を実行すると、Tremaの <literal>./bin/trema</literal> コマンドと Cbench の実行コマンド <literal>./bin/cbench</literal> など必要な実行環境一式を自動的にインストールできます。</simpara>
<screen>$ cd cbench
$ bundle install --binstubs</screen>
<simpara>以上でCbenchとTremaのセットアップは完了です。</simpara>
</section>
<section xml:id="_実行してみよう_2">
<title>実行してみよう</title>
<simpara>さっそくCbenchを実行してみましょう。まず、コントローラを次のように起動します。</simpara>
<screen>$ ./bin/trema run ./lib/cbench.rb</screen>
<simpara>そして別ターミナルを開き、次のコマンドでcbenchプロセスを実行しベンチマークを開始します<footnote><simpara>cbench コマンドの初回実行時には、自動的に cbench コマンドのコンパイルが始まります。二回目以降の実行ではコンパイルは起こりません</simpara></footnote>。</simpara>
<screen>$ ./bin/cbench --port 6653 --switches 1 --loops 10 --ms-per-test 10000 --delay 1000 --throughput
cbench: controller benchmarking tool
   running in mode 'latency'
   connecting to controller at localhost:6653
   faking 1 switches :: 10 tests each; 10000 ms per test
   with 100000 unique source MACs per switch
   starting test with 1000 ms delay after features_reply
   ignoring first 1 "warmup" and last 0 "cooldown" loops
   debugging info is off
1   switches: fmods/sec:  807   total = 0.080652 per ms
1   switches: fmods/sec:  797   total = 0.079694 per ms
1   switches: fmods/sec:  799   total = 0.079730 per ms
1   switches: fmods/sec:  797   total = 0.079698 per ms
1   switches: fmods/sec:  801   total = 0.080003 per ms
1   switches: fmods/sec:  800   total = 0.079965 per ms
1   switches: fmods/sec:  802   total = 0.080159 per ms
1   switches: fmods/sec:  802   total = 0.080182 per ms
1   switches: fmods/sec:  806   total = 0.080549 per ms
1   switches: fmods/sec:  801   total = 0.080082 per ms
RESULT: 1 switches 9 tests min/max/avg/stdev = 79.69/80.55/80.01/0.26 responses/s</screen>
<simpara>この例では、10秒間のベンチマークを10回実行しその結果を表示しています。<literal>fmods/sec</literal> の右側の数字が、実際に 1 秒間に打った Flow Mod の数です。実行環境によって値は変わりますが、Trema は秒間に数百回のFlow Modを打てることがわかります。</simpara>
</section>
<section xml:id="_ソースコード解説_2">
<title>ソースコード解説</title>
<simpara>Cbenchが正しく実行できたところで、CbenchのソースコードからPacket InとFlow Modメッセージの処理方法を見ていきましょう。ファイルは lib/cbench.rb です。</simpara>
<formalpara>
<title>lib/cbench.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># A simple openflow controller for benchmarking.
class Cbench &lt; Trema::Controller
  def start(_args)
    logger.info "#{name} started."
  end

  def packet_in(datapath_id, packet_in)
    send_flow_mod_add(
      datapath_id,
      match: ExactMatch.new(packet_in),
      buffer_id: packet_in.buffer_id,
      actions: SendOutPort.new(packet_in.in_port + 1)
    )
  end
end</programlisting>
</para>
</formalpara>
<simpara>Cbench のソースコードを眺めると、いくつか見慣れない品詞や構文が登場していることに気付きます。この節では順にそれぞれを紹介していきますが、最初からすべてを覚える必要はありません。もし後でわからなくなったときには見直すようにしてください。</simpara>
<section xml:id="_メソッド呼び出し">
<title>メソッド呼び出し</title>
<simpara>Cbench のソースコードにはいくつかの<emphasis role="strong">メソッド呼び出し</emphasis>があります。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>logger.info(&#8230;&#8203;)</literal> (<link linkend="hello_trema">3 章「Hello, Trema!」</link>で解説)</simpara>
</listitem>
<listitem>
<simpara><literal>ExactMatch.new(&#8230;&#8203;)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>packet_in.buffer_id</literal></simpara>
</listitem>
<listitem>
<simpara><literal>SendOutPort.new(&#8230;&#8203;)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>packet_in.in_port</literal></simpara>
</listitem>
</itemizedlist>
<simpara>このようにメソッドは普通、変数や定数の後にドットでつなげます。定数や変数が名詞なら、メソッドはちょうど動詞と同じです。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">door.open</programlisting>
<simpara>上の例では <literal>open</literal> がメソッドです。英語のopenは動詞なので、当然メソッドであるとも言えます。</simpara>
<simpara>ふつう、メソッド呼び出しによって何らかの動作をすると新しい結果が得られます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">'redrum'.reverse
#=&gt; "murder"</programlisting>
<simpara>この場合、文字が逆順になった新しい文字列が返ってきました。</simpara>
<simpara>メソッドは引数を取るものもあります。次の例は配列の各要素の間に指定した文字をはさんで連結 (<literal>join</literal>) します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">['M', 'A', 'S', 'H'].join('★')
#=&gt; "M★A★S★H"</programlisting>
<simpara>Rubyにはこのようなメソッドが何百種類もあります。それぞれの動作は名前から大体想像できるものがほとんどです。</simpara>
</section>
<section xml:id="_startハンドラ">
<title>startハンドラ</title>
<formalpara>
<title>Cbench#start (lib/cbench.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def start(_args)
  logger.info "#{name} started."
end</programlisting>
</para>
</formalpara>
<simpara>前章と同じく、<literal>start</literal> ハンドラでコントローラの起動をログに書き込みます。引数は今回も使っていないので、名前を <literal>_args</literal> のようにアンダースコアで始めます。</simpara>
</section>
<section xml:id="_packet_inハンドラ">
<title>packet_inハンドラ</title>
<simpara>コントローラに上がってくる未知のパケットを拾うには、Packet Inハンドラをコントローラクラスに実装します。Packet Inハンドラは次の形をしています。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in(datapath_id, packet_in)
  ...
end</programlisting>
<simpara><literal>packet_in</literal> ハンドラはその引数として、Packet Inを起こしたスイッチ(cbenchプロセス)の Datapath ID とPacket Inメッセージを受け取ります。</simpara>
<section xml:id="_packetin_クラス">
<title>PacketIn クラス</title>
<simpara><literal>packet_in</literal> ハンドラの2番目の引数はPacket Inメッセージオブジェクトで、<literal>PacketIn</literal> クラスのインスタンスです。この <literal>PacketIn</literal> クラスは主に次の3種類のメソッドを持っています。</simpara>
<itemizedlist>
<listitem>
<simpara>Packet Inを起こしたパケットのデータやその長さ、およびパケットが入ってきたスイッチのポート番号などOpenFlowメッセージ固有の情報を返すメソッド</simpara>
</listitem>
<listitem>
<simpara>Packet Inを起こしたパケットの種別 (TCPかUDPか。VLANタグがついているかどうか、など)を判定するための <literal>?</literal> で終わるメソッド</simpara>
</listitem>
<listitem>
<simpara>送信元や宛先のMACアドレスやIPアドレスなど、パケットの各フィールドを調べるためのアクセサメソッド</simpara>
</listitem>
</itemizedlist>
<simpara><literal>PacketIn</literal> クラスは非常に多くのメソッドを持っており、またTremaのバージョンアップごとにその数も増え続けているためすべては紹介しきれません。そのかわり、代表的でよく使うものを<link linkend="packet_in_class">表5-1</link>に紹介します。</simpara>
<table xml:id="packet_in_class" frame="all" rowsep="1" colsep="1">
<title>PacketIn クラスのメソッド (一部)</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">メソッド</entry>
<entry align="left" valign="top">説明</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>:raw_data</simpara></entry>
<entry align="left" valign="top"><simpara>パケットのデータ全体をバイナリ文字列で返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:in_port</simpara></entry>
<entry align="left" valign="top"><simpara>パケットが入ってきたスイッチのポート番号を返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:buffered?</simpara></entry>
<entry align="left" valign="top"><simpara>Packet Inを起こしたパケットがスイッチにバッファされているかどうかを返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:buffer_id</simpara></entry>
<entry align="left" valign="top"><simpara>バッファされている場合、そのバッファ領域の ID を返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:total_length</simpara></entry>
<entry align="left" valign="top"><simpara>パケットのデータ長を返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:source_mac_address</simpara></entry>
<entry align="left" valign="top"><simpara>パケットの送信元MACアドレスを返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:destination_mac_address</simpara></entry>
<entry align="left" valign="top"><simpara>パケットの宛先MACアドレスを返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:ipv4?</simpara></entry>
<entry align="left" valign="top"><simpara>パケットがIPv4である場合 <literal>true</literal> を返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:ipv4_protocol</simpara></entry>
<entry align="left" valign="top"><simpara>IPのプロトコル番号を返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:ipv4_source_address</simpara></entry>
<entry align="left" valign="top"><simpara>パケットの送信元IPアドレスを返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:ipv4_destination_address</simpara></entry>
<entry align="left" valign="top"><simpara>パケットの宛先IPアドレスを返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:ipv4_tos</simpara></entry>
<entry align="left" valign="top"><simpara>IPのToSフィールドを返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:tcp?</simpara></entry>
<entry align="left" valign="top"><simpara>パケットがTCPである場合 <literal>true</literal> を返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:tcp_source_port</simpara></entry>
<entry align="left" valign="top"><simpara>パケットのTCPの送信元ポート番号を返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:tcp_destination_port</simpara></entry>
<entry align="left" valign="top"><simpara>パケットのTCP宛先ポート番号を返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:udp?</simpara></entry>
<entry align="left" valign="top"><simpara>パケットがUDPである場合 <literal>true</literal> を返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:udp_source_port</simpara></entry>
<entry align="left" valign="top"><simpara>パケットのUDPの送信元ポート番号を返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:udp_destination_port</simpara></entry>
<entry align="left" valign="top"><simpara>パケットのUDPの宛先ポート番号を返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:vlan?</simpara></entry>
<entry align="left" valign="top"><simpara>パケットにVLANヘッダが付いている場合 <literal>true</literal> を返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:vlan_vid</simpara></entry>
<entry align="left" valign="top"><simpara>VLANのVIDを返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:vlan_priority</simpara></entry>
<entry align="left" valign="top"><simpara>VLANの優先度を返す</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:ether_type</simpara></entry>
<entry align="left" valign="top"><simpara>イーサタイプを返す</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>このようなメソッドは他にもたくさんあります。完全なメソッドのリストや詳しい情報を知りたい場合には、<link linkend="hello_trema">3 章「Hello, Trema!」</link>で紹介した Trema ホームページを参照してください。</simpara>
</section>
</section>
<section xml:id="_flow_mod_の送り方">
<title>Flow Mod の送り方</title>
<simpara>Cbenchの仕様によると、コントローラからCbenchへと送るFlow Modメッセージは、次の内容にセットする必要があります。</simpara>
<itemizedlist>
<listitem>
<simpara>マッチフィールド: Packet In メッセージのExactMatch (後述)</simpara>
</listitem>
<listitem>
<simpara>アクション: Packet In メッセージのin_portに+1したポートへ転送</simpara>
</listitem>
<listitem>
<simpara>バッファID: Packet In メッセージのバッファID</simpara>
</listitem>
</itemizedlist>
<simpara>それぞれの指定方法を順に見ていきましょう。</simpara>
<section xml:id="_マッチフィールド_openflow_1_0">
<title>マッチフィールド (OpenFlow 1.0)</title>
<simpara>マッチフィールドを指定するには、<literal>send_flow_mod_add</literal> の引数に <literal>match:</literal> オプションとしてマッチフィールドオブジェクト (<literal>Match.new(&#8230;&#8203;)</literal> または <literal>ExactMatch.new(&#8230;&#8203;)</literal>) を渡します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">send_flow_mod_add(
  datapath_id,
  match: Match.new(...), <co xml:id="CO12-1"/>
  ...
)</programlisting>
<calloutlist>
<callout arearefs="CO12-1">
<para>マッチフィールドを指定する <literal>match:</literal> オプション</para>
</callout>
</calloutlist>
<simpara>マッチフィールドを作るには、<literal>Match.new</literal> に指定したい条件のオプションを渡します。たとえば、送信元 MAC アドレスが 00:50:56:c0:00:08 で VLAN ID が 3 というルールを指定したマッチフィールドを Flow Mod に指定するコードは、次のようになります。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">send_flow_mod_add(
  datapath_id,
  match: Match.new(
           source_mac_address: '00:50:56:c0:00:08'
           vlan_vid: 3
         )
  ...</programlisting>
<simpara>OpenFlow 1.0 において指定できるマッチフィールドは 12 種類です。<literal>Match.new</literal> のオプションには、以下の12種類の条件を指定できます(<link linkend="match_field_1.0">表5-2</link>)。</simpara>
<table xml:id="match_field_1.0" frame="all" rowsep="1" colsep="1">
<title>マッチフィールドを作る Match.new のオプション</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">オプション</entry>
<entry align="left" valign="top">説明</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>:in_port</simpara></entry>
<entry align="left" valign="top"><simpara>スイッチの物理ポート番号</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:source_mac_address</simpara></entry>
<entry align="left" valign="top"><simpara>送信元MACアドレス</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:destination_mac_address</simpara></entry>
<entry align="left" valign="top"><simpara>宛先MACアドレス</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:ether_type</simpara></entry>
<entry align="left" valign="top"><simpara>イーサネットの種別</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:source_ip_address</simpara></entry>
<entry align="left" valign="top"><simpara>送信元IPアドレス</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:destination_ip_address</simpara></entry>
<entry align="left" valign="top"><simpara>宛先IPアドレス</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:ip_protocol</simpara></entry>
<entry align="left" valign="top"><simpara>IPのプロトコル種別</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:tos</simpara></entry>
<entry align="left" valign="top"><simpara>IPのToSフィールド</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:transport_source_port</simpara></entry>
<entry align="left" valign="top"><simpara>TCP/UDPの送信元ポート番号</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:transport_destination_port</simpara></entry>
<entry align="left" valign="top"><simpara>TCP/UDPの宛先ポート番号</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:vlan_vid</simpara></entry>
<entry align="left" valign="top"><simpara>VLAN IDの値</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:vlan_priority</simpara></entry>
<entry align="left" valign="top"><simpara>VLANのプライオリティ</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara><link linkend="openflow_spec">2章「OpenFlow の仕様」</link>で説明したように、OpenFlow 1.3 でマッチフィールドは 40 種類に増えました。しかし、OpenFlow 1.3 での Match オブジェクトのオプションの指定方法は、OpenFlow 1.0 の場合と変わりません。詳しくは OpenFlow 1.3 を扱う <link linkend="learning_switch13">8章「OpenFlow1.3版ラーニングスイッチ」</link>や<link linkend="router13">14章「ルータ (マルチプルテーブル編)」</link>を参照してください。</simpara>
</note>
<section xml:id="_exact_matchの作り方_openflow_1_0">
<title>Exact Matchの作り方 (OpenFlow 1.0)</title>
<simpara>マッチフィールドの中でもすべての条件を指定したものをExact Matchと呼びます。たとえばPacket Inとしてコントローラに入ってきたパケットとマッチフィールドが定義する12個の条件がすべてまったく同じ、というのがExact Matchです。</simpara>
<simpara>マッチフィールドを作る構文 <literal>Match.new</literal> にこの12種類の条件すべてを渡せば、次のようにExact Matchを作れます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in(datapath_id, packet_in)
  ...
  send_flow_mod_add(
    datapath_id,
    match: Match.new(
             in_port: packet_in.in_port,
             source_mac_address: packet_in.source_mac_address,
             destination_mac_address: packet_in.destination_mac_address,
             ...</programlisting>
<simpara>しかし、マッチフィールドを1つ作るだけで12行も書いていたら大変です。そこで、TremaではPacket InメッセージからExact Matchを楽に書ける次のショートカットを用意しています。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def packet_out(datapath_id, packet_in)
  send_flow_mod_add(
    datapath_id,
    match: ExactMatch.new(packet_in),
    ...</programlisting>
<simpara>たった1行で書けました! Tremaにはこのようにコードを短く書ける工夫がたくさんあります。</simpara>
<note>
<simpara>ExactMatch が使えるのは OpenFlow 1.0 のみです。OpenFlow 1.3 ではマッチフィールドの種類が増えたため、ExactMatch は廃止されました。</simpara>
</note>
</section>
</section>
<section xml:id="_アクション_openflow1_0">
<title>アクション (OpenFlow1.0)</title>
<simpara>アクションを指定するには、<literal>send_flow_mod_add</literal> の引数に <literal>actions:</literal> オプションとして単体のアクションまたはアクションのリストを渡します<footnote><simpara>OpenFlow1.0 にはインストラクションはありません。そのかわりパケットに適用したいアクションを、このように Flow Mod に直接指定します</simpara></footnote>。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">send_flow_mod_add(
  datapath_id,
  ...
  actions: アクション <co xml:id="CO13-1"/>
)

または

send_flow_mod_add(
  datapath_id,
  ...
  actions: [アクション0, アクション1, アクション2, ...] <co xml:id="CO13-2"/>
)</programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para><literal>actions:</literal> オプションでアクションを 1 つ指定</para>
</callout>
<callout arearefs="CO13-2">
<para><literal>actions:</literal> オプションにアクションを複数指定</para>
</callout>
</calloutlist>
<simpara>たとえば、「VLAN ヘッダを除去しポート2番に転送」というアクションを Flow Mod に指定するコードは、次のようになります。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">send_flow_mod_add(
  datapath_id,
  ...
  actions: [StripVlanHeader.new, SendOutPort.new(2)] <co xml:id="CO14-1"/>
)</programlisting>
<calloutlist>
<callout arearefs="CO14-1">
<para>アクションを 2 つ指定</para>
</callout>
</calloutlist>
<simpara>アクションには<link linkend="flow_mod_actions">表5-3</link>の13種類のアクションを単体で、または組み合わせて指定できます。</simpara>
<table xml:id="flow_mod_actions" frame="all" rowsep="1" colsep="1">
<title>指定できるアクション</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">アクション</entry>
<entry align="left" valign="top">説明</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>SendOutPort</simpara></entry>
<entry align="left" valign="top"><simpara>指定したスイッチポートにパケットを出力する</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetEtherSourceAddress</simpara></entry>
<entry align="left" valign="top"><simpara>送信元MACアドレスを指定した値に書き換える</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetEtherDestinationAddress</simpara></entry>
<entry align="left" valign="top"><simpara>宛先MACアドレスを指定した値に書き換える</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetIpSourceAddress</simpara></entry>
<entry align="left" valign="top"><simpara>送信元のIPアドレスを指定した値に書き換える</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetIpDstinationAddress</simpara></entry>
<entry align="left" valign="top"><simpara>宛先のIPアドレスを指定した値に書き換える</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetIpTos</simpara></entry>
<entry align="left" valign="top"><simpara>IPのToSフィールドを書き換える</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetTransportSourcePort</simpara></entry>
<entry align="left" valign="top"><simpara>TCP/UDPの送信元ポート番号を書き換える</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetTransportDestinationPort</simpara></entry>
<entry align="left" valign="top"><simpara>TCP/UDPの宛先ポート番号を書き換える</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>StripVlanHeader</simpara></entry>
<entry align="left" valign="top"><simpara>VLANのヘッダを除去する</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetVlanVid</simpara></entry>
<entry align="left" valign="top"><simpara>指定したVLAN IDをセットする、または既存のものがあれば書き換える</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetVlanPriority</simpara></entry>
<entry align="left" valign="top"><simpara>指定したVLANプライオリティをセットする、または既存のものがあれば書き換える</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Enqueue</simpara></entry>
<entry align="left" valign="top"><simpara>指定したスイッチポートのキューにパケットを入れる</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>VendorAction</simpara></entry>
<entry align="left" valign="top"><simpara>ベンダ定義の独自拡張アクションを実行する</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>まだ使っていないアクションについては、続く章で具体的な使い方を見ていきます。</simpara>
</section>
<section xml:id="_send_flow_mod_add_のオプション">
<title>send_flow_mod_add のオプション</title>
<simpara>バッファIDを指定するには、<literal>buffer_id:</literal> オプションを <literal>send_flow_mod_add</literal> の引数に指定します。たとえば次のコードは、バッファ ID に Packet Inメッセージのバッファ ID を指定する典型的な例です。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">send_flow_mod_add(
  datapath_id,
  match: ...,
  actions: ...,
  buffer_id: packet_in.buffer_id <co xml:id="CO15-1"/>
)</programlisting>
<calloutlist>
<callout arearefs="CO15-1">
<para>Flow Mod のオプションにバッファ ID を指定</para>
</callout>
</calloutlist>
<simpara><literal>send_flow_mod_add</literal> で指定できるすべてのオプションは<link linkend="send_flow_mod_add_options">表5-4</link>の通りです。</simpara>
<table xml:id="send_flow_mod_add_options" frame="all" rowsep="1" colsep="1">
<title>send_flow_mod_addで指定できるオプション</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">オプション</entry>
<entry align="left" valign="top">説明</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>:match</simpara></entry>
<entry align="left" valign="top"><simpara>フローエントリのマッチフィールドを指定する。本章で紹介した <literal>Match</literal> オブジェクトまたは <literal>ExactMatch</literal> オブジェクトを指定する</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:actions</simpara></entry>
<entry align="left" valign="top"><simpara>フローエントリのアクションを指定する。アクションには単体のアクションまたは複数のアクションを配列 (<link linkend="switch_monitor">4章</link>で解説) によって指定できる</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:buffer_id</simpara></entry>
<entry align="left" valign="top"><simpara>アクションが参照するパケットがバッファされている領域の ID を指定する</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:idle_timeout</simpara></entry>
<entry align="left" valign="top"><simpara>フローエントリが一定時間参照されなかった場合に破棄されるまでの秒数を指定する。デフォルトは0秒で、この場合フローエントリは破棄されない</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:hard_timeout</simpara></entry>
<entry align="left" valign="top"><simpara>フローエントリの寿命を秒数で指定する。デフォルトは0秒で、この場合フローエントリは破棄されない</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:priority</simpara></entry>
<entry align="left" valign="top"><simpara>フローエントリの優先度(符号なし16ビット、大きいほど優先度高)。Packet Inメッセージはこの優先度順にフローエントリのマッチフィールドと照らし合わされる。デフォルトは <literal>0xffff</literal> (最高優先度)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:send_flow_removed</simpara></entry>
<entry align="left" valign="top"><simpara>タイムアウトでフローエントリが消えるときに、Flow Removedメッセージをコントローラに送るかどうかを指定する。デフォルトは <literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:check_overlap</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal> にセットすると、フローテーブルの中に同じ優先度で競合するものがあった場合、フローエントリを追加せずにエラーを起こす。デフォルトは <literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:emerg</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal> にセットすると、フローエントリを緊急エントリとして追加する。緊急エントリはスイッチが何らかの障害でコントローラと切断したときにのみ有効となる。デフォルトは <literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>:cookie</simpara></entry>
<entry align="left" valign="top"><simpara>任意の用途に使える64ビットの整数。使い道としては、同じクッキー値を持つフローエントリ同士をまとめて管理するなどといった用途がある</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>こうしたオプションも、続くいくつかの章で具体的な使い方を紹介します。</simpara>
<note>
<simpara>OpenFlow1.0 では<link linkend="openflow_spec">2章「OpenFlow の仕様」</link>で解説したインストラクションは使いません。そのためインストラクションの代わりに、アクションを直接フローエントリに指定します。OpenFlow 1.3 でのインストラクションの使い方は、<link linkend="learning_switch13">8章「OpenFlow1.3版ラーニングスイッチ」</link>にて詳しく説明します。</simpara>
</note>
</section>
</section>
</section>
<section xml:id="_マルチスレッド化する">
<title>マルチスレッド化する</title>
<simpara>Tremaはシングルスレッドで動作するので、実のところ Cbench の結果はあまり速くありません。シングルスレッドとはつまり、同時に1つの <literal>packet_in</literal> ハンドラしか実行できないという意味です。たとえ cbench プロセスがたくさん Packet In メッセージを送ってきても、Trema は順に 1 つひとつ処理するため遅くなります。</simpara>
<simpara>Trema がシングルスレッドである理由は、マルチスレッドプログラミング由来のやっかいなバグを避けるためです。たとえば次のようなマルチスレッドで動作する <literal>multi_threaded_packet_in</literal> というハンドラがあったとして、この中でスレッドセーフでない変数の内容を変更すると、タイミングや環境に起因するやっかいなバグが発生してしまいます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def start(_args)
  @db = DB.new  <co xml:id="CO16-1"/>
end

# マルチスレッド版 packet_in ハンドラ
def multi_threaded_packet_in(datapath_id, packet_in)  <co xml:id="CO16-2"/>
  # !!! ここで @db の読み書きは危険 !!!
  return if @db.lookup(packet_in.in_port)
  @db.add packet_in.source_mac_address, packet_in.in_port
end</programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para>スレッドセーフでないインスタンス変数</para>
</callout>
<callout arearefs="CO16-2">
<para>独立したスレッドで動く Packet In ハンドラ</para>
</callout>
</calloutlist>
<simpara>マルチスレッドプログラミングでは、スレッド間で共有するリソースに競合が起こらないように、注意深くコードを書く必要があるのです。</simpara>
<section xml:id="_排他制御">
<title>排他制御</title>
<simpara>スレッド間の競合を解決する代表的な方法が Mutex による排他制御です。スレッド間で競合の起こる箇所を Mutex で囲むことで、その箇所へは同時に 1 つのスレッドしか入れなくなります。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def start(_args)
  @db = DB.new
  @mutex = Mutex.new  <co xml:id="CO17-1"/>
end

def multi_threaded_packet_in(datapath_id, packet_in)
  @mutex.synchronize do  <co xml:id="CO17-2"/>
    # この中で@dbを読み書きすれば安全
    return if @db.lookup(packet_in.in_port)
    @db.add packet_in.source_mac_address, packet_in.in_port
  end
end</programlisting>
<calloutlist>
<callout arearefs="CO17-1">
<para>排他制御用の Mutex</para>
</callout>
<callout arearefs="CO17-2">
<para><literal>do&#8230;&#8203;end</literal> の中には同時に 1 つのスレッドしか入れない</para>
</callout>
</calloutlist>
<simpara>これでひとまず競合は回避できたので、<literal>packet_in</literal> をスレッド化してみましょう。次のように高速化したいハンドラメソッドの中身を別スレッドで起動し、インスタンス変数へのアクセスを Mutex で排他制御してやります。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def start(_args)
  @db = DB.new
  @mutex = Mutex.new
end

def packet_in(datapath_id, packet_in)
  Thread.start do  <co xml:id="CO18-1"/>
    @mutex.synchronize do
      return if @db.lookup(packet_in.in_port)
      @db.add packet_in.source_mac_address, packet_in.in_port
    end
  end
end</programlisting>
<calloutlist>
<callout arearefs="CO18-1">
<para><literal>packet_in</literal> ハンドラの中身をスレッドで起動</para>
</callout>
</calloutlist>
<simpara>しかし、これでもまだ問題は残ります。<literal>Thread.start</literal> によるスレッド起動はそれなりにコストのかかる処理なので、Packet In が届くたびに <literal>Tread.new</literal> でスレッドを作っていては速くなりません。</simpara>
<simpara>そこで、次のようにあらかじめいくつかワーカースレッドを作って待機させておく、いわゆるスレッドプールという手法が使えます。そして <literal>packet_in</literal> ハンドラが呼ばれるたびに待機中のスレッドに <literal>packet_in</literal> の処理をまかせます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def start(_args)
  @db = DB.new
  @mutex = Mutex.new
  @work_queue = Queue.new  <co xml:id="CO19-1"/>
  10.times { start_worker_thread }  <co xml:id="CO19-2"/>
end

def packet_in(datapath_id, packet_in)
  @work_queue.push [datapath_id, packet_in]  <co xml:id="CO19-3"/>
end

private

# ワーカースレッドを開始
def start_worker_thread  <co xml:id="CO19-4"/>
  Thread.new do
    loop do
      datapath_id, packet_in = @work_queue.pop  <co xml:id="CO19-5"/>
      @mutex.synchronize do
        next if @db.lookup(packet_in.in_port)
        @db.add packet_in.source_mac_address, packet_in.in_port
      end
    end
  end
end</programlisting>
<calloutlist>
<callout arearefs="CO19-1">
<para>スレッドにまかせたい仕事を入れておくキュー</para>
</callout>
<callout arearefs="CO19-2">
<para>スレッドプールに 10 個のスレッドを追加</para>
</callout>
<callout arearefs="CO19-3">
<para>Packet In が届いたら datapath_id と Packet In をキューに入れる</para>
</callout>
<callout arearefs="CO19-4">
<para>ワーカースレッドを起動するプライベートメソッド</para>
</callout>
<callout arearefs="CO19-5">
<para>スレッドの中でキューから datapath_id と Packet In を取り出す。Queue クラスはスレッドセーフなので、<literal>@mutex.synchronize do &#8230;&#8203; end</literal> の中に入れる必要はないことに注意</para>
</callout>
</calloutlist>
<simpara>このスレッドプールを使った、最終的なマルチスレッド版 Cbench コントローラは次のようになります。</simpara>
<formalpara>
<title>lib/multi_threaded_cbench.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># A simple openflow controller for benchmarking (multi-threaded version).
class MultiThreadedCbench &lt; Trema::Controller
  def start(_args)
    @work_queue = Queue.new
    10.times { start_worker_thread }
    logger.info 'Cbench started.'
  end

  def packet_in(datapath_id, packet_in)
    @work_queue.push [datapath_id, packet_in]
  end

  private

  def start_worker_thread
    Thread.new do
      loop do
        datapath_id, packet_in = @work_queue.pop
        send_flow_mod_add(datapath_id,
                          match: ExactMatch.new(packet_in),
                          buffer_id: packet_in.buffer_id,
                          actions: SendOutPort.new(packet_in.in_port + 1))
      end
    end
  end
end</programlisting>
</para>
</formalpara>
<simpara>実際に性能を計測してみましょう。</simpara>
<screen>$ ./bin/trema run lib/multi_threaded_cbench.rb</screen>
<simpara>別ターミナルで Cbench を起動します。</simpara>
<screen>$ ./bin/cbench --port 6653 --switches 1 --loops 10 --ms-per-test 10000 --delay 1000 --throughput
cbench: controller benchmarking tool
   running in mode 'throughput'
   connecting to controller at localhost:6653
   faking 1 switches :: 10 tests each; 10000 ms per test
   with 100000 unique source MACs per switch
   starting test with 1000 ms delay after features_reply
   ignoring first 1 "warmup" and last 0 "cooldown" loops
   debugging info is off
1   switches: fmods/sec:  748   total = 0.074746 per ms
1   switches: fmods/sec:  714   total = 0.071319 per ms
1   switches: fmods/sec:  705   total = 0.070448 per ms
1   switches: fmods/sec:  704   total = 0.070376 per ms
1   switches: fmods/sec:  718   total = 0.071747 per ms
1   switches: fmods/sec:  734   total = 0.073346 per ms
1   switches: fmods/sec:  739   total = 0.073763 per ms
1   switches: fmods/sec:  736   total = 0.073487 per ms
1   switches: fmods/sec:  732   total = 0.073146 per ms
1   switches: fmods/sec:  730   total = 0.072917 per ms
RESULT: 1 switches 9 tests min/max/avg/stdev = 70.38/73.76/72.28/1.25 responses/s</screen>
<simpara>おや？シングルスレッド版よりも若干遅くなってしまいました。これには 2 つの原因があります。まず、Ruby のスレッドは OS のネイティブスレッドであるため、スレッド切り替えのオーバーヘッドが大きくかかります。しかも、Packet In 処理は一瞬で終わるため、マルチスレッド化しても並列性はあまり上がりません。これらの原因から、マルスレッド化によって新たにスレッド切り替えのオーバーヘッドがかかった分、元のバージョンより遅くなってしまったのです。</simpara>
</section>
</section>
<section xml:id="_無理やり高速化する">
<title>無理やり高速化する</title>
<simpara>ほかに高速化の方法はないでしょうか。実は cbench プロセスが送ってくる Packet In はすべて同じ中身なので、cbench プロセスへ送る Flow Mod メッセージを何度も使いまわすことで簡単に高速化できます。最初のコードでは Packet In ハンドラの中で <literal>send_flow_mod_add</literal> で毎回 Flow Mod メッセージを作り直していました。この無駄な処理をなくすために、一度作った Flow Mod メッセージをキャッシュしておいて、2 回目以降はキャッシュした Flow Mod を <literal>send_message</literal> で送るのです。</simpara>
<simpara>このキャッシュによって高速化したものがこちらです。ただしこれはただ Cbench のために無理やり高速化したコードなので、すべてを理解する必要はありません。</simpara>
<formalpara>
<title>lib/fast_cbench.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># A simple openflow controller for benchmarking (fast version).
class FastCbench &lt; Trema::Controller
  def start(_args)
    logger.info "#{name} started."
  end

  def packet_in(dpid, packet_in)
    @flow_mod ||= create_flow_mod_binary(packet_in) <co xml:id="CO20-1"/>
    send_message dpid, @flow_mod <co xml:id="CO20-2"/>
  end

  private

  def create_flow_mod_binary(packet_in)
    options = {
      command: :add,
      priority: 0,
      transaction_id: 0,
      idle_timeout: 0,
      hard_timeout: 0,
      buffer_id: packet_in.buffer_id,
      match: ExactMatch.new(packet_in),
      actions: SendOutPort.new(packet_in.in_port + 1)
    }
    FlowMod.new(options).to_binary.tap do |flow_mod| <co xml:id="CO20-3"/>
      def flow_mod.to_binary
        self
      end
    end
  end
end</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO20-1">
<para>最初は <literal>@flow_mod</literal> が <literal>nil</literal> なので、最初だけ <literal>create_flow_mod_binary</literal> で Flow Mod メッセージを作る。二回目以降は呼ばれない</para>
</callout>
<callout arearefs="CO20-2">
<para>キャッシュした Flow Mod メッセージを cbench プロセスに送る</para>
</callout>
<callout arearefs="CO20-3">
<para><literal>send_message</literal> のときに Trema が呼び出す <literal>FlowMod#to_binary</literal> を軽くするため、キャッシュしたバイナリを返す特異メソッドを定義</para>
</callout>
</calloutlist>
<simpara>実行結果は次のようになります。秒間約 6000 発の Flow Mod が打てており、元のバージョンに比べて 10 倍近く高速化できました!</simpara>
<screen>cbench: controller benchmarking tool
   running in mode 'throughput'
   connecting to controller at localhost:6653
   faking 1 switches :: 10 tests each; 10000 ms per test
   with 100000 unique source MACs per switch
   starting test with 1000 ms delay after features_reply
   ignoring first 1 "warmup" and last 0 "cooldown" loops
   debugging info is off
1   switches: fmods/sec:  6741   total = 0.674018 per ms
1   switches: fmods/sec:  6400   total = 0.639859 per ms
1   switches: fmods/sec:  6508   total = 0.650710 per ms
1   switches: fmods/sec:  6334   total = 0.633349 per ms
1   switches: fmods/sec:  6325   total = 0.632465 per ms
1   switches: fmods/sec:  6293   total = 0.629207 per ms
1   switches: fmods/sec:  6276   total = 0.627579 per ms
1   switches: fmods/sec:  6332   total = 0.633133 per ms
1   switches: fmods/sec:  6219   total = 0.621860 per ms
1   switches: fmods/sec:  6293   total = 0.629266 per ms
RESULT: 1 switches 9 tests min/max/avg/stdev = 621.86/650.71/633.05/7.77 responses/s</screen>
<warning>
<title>Cbenchの注意点</title>
<simpara>Cbench のスコアを盲信しないようにしてください。現在、OpenFlow コントローラの多くがその性能指標として Cbench のスコアを使っているのをよく見掛けます。たとえば Floodlight (<link xl:href="http://www.projectfloodlight.org/">http://www.projectfloodlight.org/</link>) は 1 秒間に 100 万発の Flow Mod を打てると宣伝しています。実際にこれはなかなかすごい数字です。スレッドを駆使してめいっぱい I/O を使い切るようにしなければなかなかこの数字は出ません。でも、この数字はほとんど無意味です。</simpara>
<simpara>Flow Mod を 1 秒間に 100 万発打たなければならない状況を考えてみてください。それは、Packet In が 1 秒間に 100 万回起こるということになります。Packet In が 1 秒間に 100 万発起こるとはどういうことでしょうか。スイッチで処理できないパケットがすべてコントローラへやってくる、これが 1 秒間に 100 万回も起こるということです。明らかにフローテーブルの設計がうまく行っていません。</simpara>
<simpara>コントローラが Packet In を何発さばけるかという性能は、極端に遅くない限りは重要ではありません。データセンターのように、どこにどんなマシンがありどういう通信をするか把握できている場合は、フローテーブルをちゃんと設計していれば Packet In はそんなに起こらないからです。力技で Packet In をさばくよりも、いかに Packet In が起こらないフローテーブル設計をするかの方がずっと大事です。</simpara>
<simpara>Cbench のようなマイクロベンチマークでは、測定対象が何でその結果にはどんな意味があるかを理解しないと、針小棒大な結論を招きます。Cbench のスコアは参考程度にとどめましょう。</simpara>
</warning>
</section>
<section xml:id="_まとめ_5">
<title>まとめ</title>
<simpara>Packet InとFlow Modの最初の一歩として、ベンチマークツールCbenchと接続できるコントローラを書きました。</simpara>
<itemizedlist>
<listitem>
<simpara>フローエントリを追加するための <literal>send_flow_mod_add</literal> を使って、スイッチのフローテーブルを書き換える方法を学んだ</simpara>
</listitem>
<listitem>
<simpara>マッチフィールドの作り方と、指定できるルールを学んだ</simpara>
</listitem>
<listitem>
<simpara>SendOutPort アクションによるパケットの転送と、その他のアクションを学んだ</simpara>
</listitem>
<listitem>
<simpara>コントローラをマルチスレッド化する方法を学んだ</simpara>
</listitem>
</itemizedlist>
<simpara>OpenFlow プログラミングの基礎はできたので、そろそろ実用的なツールを作ってみましょう。続く章では、遠隔操作可能なソフトウェアパッチパネルを作ります。もう、ネットワークケーブルを挿し替えるためだけにサーバルームまで出向く必要はなくなります。</simpara>
</section>
</chapter>
<chapter xml:id="patch_panel">
<title>インテリジェントなパッチパネル</title>
<simpara role="lead">日々のネットワーク管理に役立ち、さらにネットワーク仮想化の入門にもなるのがこのOpenFlowで作るパッチパネルです。そのうえソースコードも簡単とくれば、試さない手はありません。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/patch_panel/cables.png"/>
</imageobject>
<textobject><phrase>cables</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_便利なインテリジェント_パッチパネル">
<title>便利なインテリジェント・パッチパネル</title>
<simpara>無計画にネットワークを構築すると、ケーブルの配線は悲惨なまでにごちゃごちゃになります。からみあったケーブルのせいで見通しが悪くなり、そのままさらにスイッチやサーバを増築していくと配線のやり直しとなります。こうなってしまう一番の原因は、スイッチとスイッチ、スイッチとサーバをケーブルで直接つないでしまうことです。これでは、つなぐものを増やせば増やすほどごちゃごちゃになっていくのは当然です。</simpara>
<simpara>これを解消するのがパッチパネルという装置です (<link linkend="patch_panel_overview">図 6-1</link>)。パッチパネルの仕組みはシンプルで、ケーブルを挿すためのコネクタがずらりと並んでいて、配線をいったんパッチパネルで中継できるようになっています。スイッチやサーバをいったん中継点となるパッチパネルにつなぎ、パッチパネル上の変更だけで全体の配線を自由に変更できるので、ケーブルがすっきりし拡張性も向上します。</simpara>
<figure xml:id="patch_panel_overview">
<title>ごちゃごちゃした配線をパッチパネルですっきりと</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/patch_panel/patch_panel.png"/>
</imageobject>
<textobject><phrase>patch panel</phrase></textobject>
</mediaobject>
</figure>
<simpara>パッチパネルをさらに便利にしたのが、いわゆるインテリジェント・パッチパネルです。インテリジェント・パッチパネルとは、パッチパネルをネットワーク経由で操作できるようにしたものです。従来のパッチパネルでは、メンテナンス性は向上できるとしても、配線を変更するたびにサーバ室まで足を運ぶという面倒さがありました。インテリジェント・パッチパネルを使えば、居室にいながらリモートでパッチパネルの配線を変更できるようになります。</simpara>
</section>
<section xml:id="_openflow版インテリジェント_パッチパネル">
<title>OpenFlow版インテリジェント・パッチパネル</title>
<simpara>インテリジェント・パッチパネルはOpenFlowで簡単に実装できます。パッチパネルでの中継のように、パケットを指定したコネクタからコネクタへ転送するというのは、フローエントリの代表的な使い方の一つだからです。</simpara>
<simpara>OpenFlowで実装したパッチパネルは<link linkend="openflow_patch_panel">図 6-2</link> のようになります。OpenFlowスイッチをパッチパネルに見立てて、接続を中継したいデバイス(ホストまたはスイッチ)をつなげます。コントローラはパケット転送のルールをフローエントリとしてOpenFlowスイッチに書き込むことで、仮想的なパッチを作ります。</simpara>
<figure xml:id="openflow_patch_panel">
<title>OpenFlowで実現するパッチパネルの仕組み</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/patch_panel/openflow_patch_panel.png"/>
</imageobject>
<textobject><phrase>openflow patch panel</phrase></textobject>
</mediaobject>
</figure>
<simpara>たとえば<link linkend="openflow_patch_panel">図 6-2</link> のように、ポート1番と5番をつなげる場合を考えましょう。必要なフローエントリは次の2つです。</simpara>
<itemizedlist>
<listitem>
<simpara>ポート1番に入力したパケットをポート5番に出力する</simpara>
</listitem>
<listitem>
<simpara>ポート5番に入力したパケットをポート1番に出力する</simpara>
</listitem>
</itemizedlist>
<simpara>フローエントリの構成要素には、「こういうパケットが届いたとき」というマッチフィールドと、「こうする」というアクションがあるのでした。パッチパネルの場合、「ポートx番に入力」がマッチフィールドで、「ポートy番に出力」がアクションです。</simpara>
<simpara>それでは仕組みがわかったところで、パッチパネルコントローラを動かしてみましょう。</simpara>
</section>
<section xml:id="_実行してみよう_3">
<title>実行してみよう</title>
<simpara>パッチパネルのソースコードはGitHubのtrema/patch_panelリポジトリ (<link xl:href="https://github.com/trema/patch_panel">https://github.com/trema/patch_panel</link>) からダウンロードできます。</simpara>
<screen>$ git clone https://github.com/trema/patch_panel.git</screen>
<simpara>ダウンロードしたソースツリー上で <literal>bundle install --binstubs</literal> を実行すると、Tremaなどの実行環境一式を自動的にインストールできます。</simpara>
<screen>$ cd patch_panel
$ bundle install --binstubs</screen>
<simpara>以上でパッチパネルとTremaのセットアップは完了です。</simpara>
<simpara>パッチパネルのソースコードで主なファイルは次の 3 つです。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>lib/patch_panel.rb</literal>: パッチパネル本体</simpara>
</listitem>
<listitem>
<simpara><literal>patch_panel.conf</literal>: 仮想ネットワーク設定ファイル</simpara>
</listitem>
<listitem>
<simpara><literal>bin/patch_panel</literal>: パッチパネルの操作コマンド</simpara>
</listitem>
</itemizedlist>
<section xml:id="_仮想ネットワークの設定">
<title>仮想ネットワークの設定</title>
<simpara>仮想ネットワーク設定ファイル <literal>patch_panel.conf</literal> では、パッチパネルの動作テストのためにパケットを送受信できる仮想ホストを定義しています。<literal>vhost</literal> で始まる行が仮想ホスト、そして <literal>link</literal> で始まる行がスイッチやホストをつなげるための仮想リンクです。</simpara>
<formalpara>
<title>patch_panel.conf</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">vswitch('patch_panel') { datapath_id 0xabc }

vhost ('host1') { ip '192.168.0.1' }
vhost ('host2') { ip '192.168.0.2' }
vhost ('host3') { ip '192.168.0.3' }

link 'patch_panel', 'host1'
link 'patch_panel', 'host2'
link 'patch_panel', 'host3'</programlisting>
</para>
</formalpara>
<simpara>この設定ファイルでは仮想スイッチ <literal>0xabc</literal> に 3 つの仮想ホスト <literal>host1</literal>, <literal>host2</literal>, <literal>host3</literal> を接続しています (<link linkend="patch_panel_configuration">図 6-3</link>)。仮想スイッチと仮想ホストの接続は、仮想リンク (<literal>link</literal> で始まる行) によって記述できます。<literal>link</literal> を書いた順で、それぞれのホストはスイッチのポート 1 番、ポート 2 番、ポート 3 番、&#8230;&#8203; に接続されます。</simpara>
<figure xml:id="patch_panel_configuration">
<title>設定ファイル patch_panel.conf の仮想ネットワーク構成</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/patch_panel/configuration.png"/>
</imageobject>
<textobject><phrase>configuration</phrase></textobject>
</mediaobject>
</figure>
<simpara>パッチパネルをこの仮想ネットワーク内で実行するには、仮想ネットワーク設定ファイルを <literal>trema run</literal> の <literal>-c</literal> オプションに渡します。次のように <literal>trema run</literal> コマンドでパッチパネルコントローラを起動してください。</simpara>
<screen>$ ./bin/trema run ./lib/patch_panel.rb -c patch_panel.conf</screen>
<simpara>パッチパネルは起動しただけではまだパッチングされていないので、ホスト間でのパケットは通りません。これを確認するために、<literal>trema send_packets</literal> コマンドを使ってhost1とhost2の間でテストパケットを送ってみましょう。</simpara>
<screen>$ ./bin/trema send_packets --source host1 --dest host2
$ ./bin/trema send_packets --source host2 --dest host1</screen>
<simpara>正常に動いていれば、それぞれのホストでの受信パケット数は0になっているはずです。これを確認できるのが <literal>trema show_stats</literal> コマンドです。</simpara>
<screen>$ ./bin/trema show_stats host1
Packets sent:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
$ ./bin/trema show_stats host2
Packets sent:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet</screen>
<simpara><literal>trema show_stats</literal> コマンドは引数として渡したホストの送受信パケットを表示します。host1 と host2 の両ホストともパケットを 1 つ送信していますが、どちらにもパケットは届いていません。</simpara>
<simpara>パッチパネルの設定は <literal>./bin/patch_panel</literal> コマンドで指定できます。たとえば、スイッチ 0xabc のポート 1 番とポート 2 番をつなぐには次のコマンドを実行します。</simpara>
<screen>$ ./bin/patch_panel create 0xabc 1 2</screen>
<simpara>これで、host1 と host2 が通信できるはずです。もういちどパケットの送受信を試してみましょう。</simpara>
<screen>$ ./bin/trema send_packets --source host1 --dest host2
$ ./bin/trema send_packets --source host2 --dest host1
$ ./bin/trema show_stats host1
Packets sent:
  192.168.0.1 -&gt; 192.168.0.2 = 2 packets
Packets received:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet
$ ./bin/trema show_stats host2
Packets sent:
  192.168.0.2 -&gt; 192.168.0.1 = 2 packets
Packets received:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet</screen>
<simpara>たしかにパケットが届いています。パッチパネルの動作イメージがわかったところで、ソースコードを見ていきます。</simpara>
</section>
</section>
<section xml:id="_ソースコード解説_3">
<title>ソースコード解説</title>
<simpara>パッチパネルのソースコードは<xref linkend="patch_panel.rb"/>です。</simpara>
<formalpara xml:id="patch_panel.rb">
<title>lib/patch_panel.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># Software patch-panel.
class PatchPanel &lt; Trema::Controller
  def start(_args)
    @patch = Hash.new([].freeze)
    logger.info "#{name} started."
  end

  def switch_ready(dpid)
    @patch[dpid].each do |port_a, port_b|
      delete_flow_entries dpid, port_a, port_b
      add_flow_entries dpid, port_a, port_b
    end
  end

  def create_patch(dpid, port_a, port_b)
    add_flow_entries dpid, port_a, port_b
    @patch[dpid] += [port_a, port_b].sort
  end

  def delete_patch(dpid, port_a, port_b)
    delete_flow_entries dpid, port_a, port_b
    @patch[dpid] -= [port_a, port_b].sort
  end

  private

  def add_flow_entries(dpid, port_a, port_b)
    send_flow_mod_add(dpid,
                      match: Match.new(in_port: port_a),
                      actions: SendOutPort.new(port_b))
    send_flow_mod_add(dpid,
                      match: Match.new(in_port: port_b),
                      actions: SendOutPort.new(port_a))
  end

  def delete_flow_entries(dpid, port_a, port_b)
    send_flow_mod_delete(dpid, match: Match.new(in_port: port_a))
    send_flow_mod_delete(dpid, match: Match.new(in_port: port_b))
  end
end</programlisting>
</para>
</formalpara>
<simpara>今までに学んだ知識で、このコードをできるだけ解読してみましょう。</simpara>
<itemizedlist>
<listitem>
<simpara>パッチパネルの本体はPatchPanelという名前の小さなクラスである</simpara>
</listitem>
<listitem>
<simpara>このクラスには<link linkend="hello_trema">3 章「Hello, Trema!」</link>で学んだ <literal>switch_ready</literal> ハンドラが定義してあり、この中で <literal>delete_flow_entries</literal> と <literal>add_flow_entries</literal> いうプライベートメソッドを呼んでいる。どうやらこれがパッチ処理の本体だ</simpara>
</listitem>
<listitem>
<simpara><literal>create_patch</literal> と <literal>delete_patch</literal> というメソッドが定義してある。これらがパッチの作成と削除に対応していると予想できる</simpara>
</listitem>
<listitem>
<simpara><literal>add_flow_entries</literal> メソッドでは <literal>send_flow_mod_add</literal> を2回呼んでいる。1つのパッチを作るのに2つのフローエントリが必要なので、2回呼んでいるのだろうと推測できる</simpara>
</listitem>
</itemizedlist>
<simpara>ここまでわかればしめたものです。あらかじめパッチパネルの仕組みを押さえていたので、ソースコードを読むのも簡単です。それでは、各部分のソースコードを詳しく見ていきましょう。</simpara>
<section xml:id="_startハンドラ_2">
<title>startハンドラ</title>
<simpara>startハンドラではコントローラを初期化します。</simpara>
<formalpara>
<title>PatchPanel#start (lib/patch_panel.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def start(_args)
  @patch = Hash.new([].freeze)
  logger.info "#{name} started."
end</programlisting>
</para>
</formalpara>
<simpara><literal>@patch</literal> は現在のパッチング情報を入れておくハッシュテーブル (後述) です。このハッシュテーブルは、キーにスイッチの Datapath ID、バリューに現在のパッチ情報を持ちます。たとえば、スイッチ 0x1 のポート 1 番と 4 番をパッチングし、スイッチ 0x2 のポート 1 番と 2 番、および 3 番と 4 番をパッチングした場合、<literal>@patch</literal> の中身は次のようになります。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Datapath ID (キー)</simpara></entry>
<entry align="left" valign="top"><simpara>パッチ情報 (バリュー)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0x1</simpara></entry>
<entry align="left" valign="top"><simpara>[[1, 4]]</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0x2</simpara></entry>
<entry align="left" valign="top"><simpara>[[1, 2], [3, 4]]</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<title>Rubyのイディオム <literal>Hash.new([].freeze)</literal></title>
<simpara><literal>Hash.new</literal> の引数 (バリューの初期値) である <literal>[].freeze</literal> はハッシュテーブルの初期値が変わらないようにするための Ruby のイディオムです。もしも、<literal>.freeze</literal> していない初期値 <literal>[]</literal> に対して <literal>&lt;&lt;</literal> などの破壊的な操作をすると、次のように初期値が壊れてしまいます。</simpara>
<screen>hash = Hash.new([])

p hash[1]          #=&gt; []
p hash[1] &lt;&lt; "bar" #=&gt; ["bar"]
p hash[1]          #=&gt; ["bar"]

p hash[2]          #=&gt; ["bar"] #初期値が ["bar"] になってしまった</screen>
<simpara>そこで、初期値を <literal>.freeze</literal> することで破壊的操作を禁止できます。</simpara>
<screen>hash = Hash.new([].freeze)
hash[0] += [0] #破壊的でないメソッドはOK
hash[1] &lt;&lt; 1
# エラー `&lt;&lt;': can't modify frozen array (TypeError)</screen>
</note>
</section>
<section xml:id="_ハッシュテーブル">
<title>ハッシュテーブル</title>
<simpara><emphasis role="strong">ハッシュテーブル</emphasis>は中カッコで囲まれた (<literal>{}</literal>) 辞書です。辞書とは「言葉をその定義に対応させたデータベース」です。Rubyでは、この対応を <literal>:</literal> という記号で次のように表します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">animals = { armadillo: 'アルマジロ', boar: 'イノシシ' }</programlisting>
<simpara>たとえば ”boar” を日本語で言うと何だろう? と辞書で調べたくなったら、次のようにして辞書を引きます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">animals[:boar] #=&gt; "イノシシ"</programlisting>
<simpara>この辞書を引くときに使う言葉 (この場合は <literal>:boar</literal>) をキーと言います。そして、見つかった定義 (この場合はイノシシ) をバリューと言います。</simpara>
<simpara>新しい動物を辞書に加えるのも簡単です。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">animals[:cow] = 'ウシ'</programlisting>
<simpara>Rubyのハッシュテーブルはとても高機能なので、文字列だけでなく好きなオブジェクトを格納できます。たとえば、パッチパネルでは Datapath ID をキーとして、パッチング情報 (配列) をバリューにします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">@patch[0x1] = [[1, 2], [3, 4]]</programlisting>
<simpara>実は、すでにいろんなところでハッシュテーブルを使ってきました。たとえば、<literal>send_flow_mod_add</literal> などの省略可能なオプションは、コロン (<literal>:</literal>) を使っていることからもわかるように実はハッシュテーブルなのです。Rubyでは、引数の最後がハッシュテーブルである場合、その中カッコを次のように省略できます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def flow_mod(message, port_no)
  send_flow_mod_add(
    message.datapath_id,
    match: ExactMatch.new(message),
    actions: SendOutPort.new(port_no)
  )
end

# これと同じ

def flow_mod(message, port_no)
  send_flow_mod_add(
    message.datapath_id,
    { match: ExactMatch.new(message),
      actions: SendOutPort.new(port_no) }
  )
end</programlisting>
</section>
<section xml:id="_switch_readyハンドラ">
<title>switch_readyハンドラ</title>
<simpara><literal>switch_ready</literal> ハンドラは、起動してきたスイッチに対してパッチング用のフローエントリを書き込みます。すでにパッチ情報 <literal>@patch</literal> にフローエントリ情報が入っていた場合(スイッチがいったん停止して再接続した場合など)のみ、フローエントリを入れ直します。</simpara>
<formalpara>
<title>PatchPanel#switch_ready (lib/patch_panel.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def switch_ready(dpid)
  @patch[dpid].each do |port_a, port_b| <co xml:id="CO21-1"/>
    delete_flow_entries dpid, port_a, port_b <co xml:id="CO21-2"/>
    add_flow_entries dpid, port_a, port_b <co xml:id="CO21-3"/>
  end
end</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO21-1">
<para><literal>@patch[dpid].each</literal> はパッチング設定を 1 つずつ処理するイテレータ (後述)。仮引数は <literal>port_a</literal> と <literal>port_b</literal> の2つで、それぞれにパッチでつなぐポート番号が 1 つずつ入る</para>
</callout>
<callout arearefs="CO21-2">
<para>プライベートメソッド <literal>delete_flow_entries</literal> は古いフローエントリを消す。</para>
</callout>
<callout arearefs="CO21-3">
<para>プライベートメソッド <literal>add_flow_entries</literal> がパッチング追加処理の本体。起動してきたスイッチのDatapath ID、およびパッチングするポート番号2つを引数に取る</para>
</callout>
</calloutlist>
</section>
<section xml:id="_イテレータ">
<title>イテレータ</title>
<simpara><emphasis role="strong">イテレータ</emphasis>とは繰り返すものという意味で、繰り返し処理を短く書きたいときに使います。イテレータは一般に次の形をしています。</simpara>
<formalpara>
<title>よくあるイテレータの使用例</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">fruits = ["バナナ", "みかん", "りんご"]

fruits.each do |each|
  puts each
end

実行結果:
バナナ
みかん
りんご</programlisting>
</para>
</formalpara>
<simpara>ここでは配列 <literal>fruits</literal> の <literal>each</literal> というイテレータで <literal>fruits</literal> の各要素をプリントアウトしています。<literal>do</literal> のあとにある <literal>each</literal> は fruits の各要素が入る仮引数です。この <literal>each</literal> にバナナ・みかん・りんごが順にセットされ、続くブロック (<literal>do&#8230;&#8203;end</literal>) が呼び出されます。</simpara>
<simpara>イテレータの利点は、同じ繰り返し処理をループで書いた場合よりもずっと簡単に書けることです。</simpara>
<formalpara>
<title>C 言語っぽい for ループで書いた場合</title>
<para>
<screen>for (int i = 0; i &lt; 3; i++) {
  puts fruits[i];
}</screen>
</para>
</formalpara>
<simpara>このように for ループで書くと、配列の要素にアクセスするための変数 <literal>i</literal> やループの終了条件 <literal>i &lt; 3</literal> などが必要になります。一方、イテレータはこうした煩雑なものを抽象化で見えなくしてくれるので、プログラマは各要素についてやりたいことだけをブロックに書けば動きます。</simpara>
<simpara>実は、<link linkend="cbench">5 章「マイクロベンチマークCbench」</link>で登場した次のコードもイテレータです。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># start_worker_thread メソッドを 10 回実行
10.times { start_worker_thread }

# または、下のようにも書ける

# n には 1〜10 が入る。ただしここでは n は使っていない
10.times { |n| start_worker_thread }</programlisting>
<simpara>この <literal>times</literal> がイテレータで、続くブロックの内容を 10 回実行します。もし仮引数を使わない場合は書かなくても OK です。これによって、「<literal>10.times { start_worker_thread }</literal> (10 回 start_worker_thread を呼ぶ)」といったふうに繰り返しを非常に直感的に書けます。</simpara>
</section>
<section xml:id="_add_flow_entriesメソッド">
<title>add_flow_entriesメソッド</title>
<simpara>1つのパッチ(2つのフローエントリ)を実際に書き込むのが <literal>add_flow_entries</literal> プライベートメソッドです。</simpara>
<formalpara>
<title>PatchPanel#add_flow_entries (lib/patch_panel.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def add_flow_entries(dpid, port_a, port_b)
  send_flow_mod_add(dpid,
                    match: Match.new(in_port: port_a),
                    actions: SendOutPort.new(port_b))
  send_flow_mod_add(dpid,
                    match: Match.new(in_port: port_b),
                    actions: SendOutPort.new(port_a))
end</programlisting>
</para>
</formalpara>
<simpara><literal>add_flow_entries</literal> の中で2回呼び出している <literal>send_flow_mod_add</literal> のうち、最初の呼び出し部分を詳しく見てみましょう。</simpara>
<formalpara>
<title>PatchPanel#add_flow_entries (lib/patch_panel.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">send_flow_mod_add(dpid,
                  match: Match.new(in_port: port_a),
                  actions: SendOutPort.new(port_b))</programlisting>
</para>
</formalpara>
<simpara>ここでは、ポート <literal>port_a</literal> 番へ上がってきたパケットをポート <literal>port_b</literal> 番へ出力するフローエントリを書き込んでいます。ここでは次の2つのオプションを指定しています。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>match</literal>: 「入力ポート(<literal>:in_port</literal>)が <literal>port_a</literal> であった場合」という <literal>Match</literal> オブジェクト</simpara>
</listitem>
<listitem>
<simpara><literal>actions</literal>: 「ポート <literal>port_b</literal> 番へ出力する」という <literal>SendOutPort</literal> アクション</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_delete_flow_entriesメソッド">
<title>delete_flow_entriesメソッド</title>
<simpara><literal>delete_flow_entries</literal> は古いフローエントリを消すメソッドです。<literal>add_flow_entries</literal> でフローエントリを足す前に、いったん <literal>delete_flow_entries</literal> で古いフローエントリを消すことでフローエントリが重複しないようにします。</simpara>
<formalpara>
<title>PatchPanel#delete_flow_entries (lib/patch_panel.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def delete_flow_entries(dpid, port_a, port_b)
  send_flow_mod_delete(dpid, match: Match.new(in_port: port_a))
  send_flow_mod_delete(dpid, match: Match.new(in_port: port_b))
end</programlisting>
</para>
</formalpara>
<simpara>ここで呼び出している <literal>send_flow_mod_delete</literal> は <literal>send_flow_mod_add</literal> とは逆のメソッドで、<literal>match:</literal> に対応するフローエントリを削除します。</simpara>
</section>
<section xml:id="_create_patch_delete_patchメソッド">
<title>create_patch, delete_patchメソッド</title>
<simpara><literal>create_patch</literal> と <literal>delete_patch</literal> メソッドは、<literal>bin/patch_panel</literal> コマンドからパッチの作成と削除を行うためのAPIです。</simpara>
<simpara><literal>create_patch</literal> メソッドは、<literal>add_flow_entries</literal> メソッドでフローエントリを追加し、パッチ設定 <literal>@patch</literal> にパッチ情報を追加します。</simpara>
<formalpara>
<title>PatchPanel#create_patch (lib/patch_panel.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def create_patch(dpid, port_a, port_b)
  add_flow_entries dpid, port_a, port_b
  @patch[dpid] += [port_a, port_b].sort
end</programlisting>
</para>
</formalpara>
<simpara>逆に <literal>delete_patch</literal> メソッドはフローエントリを削除しパッチ設定からパッチ情報を削除します。</simpara>
<formalpara>
<title>PatchPanel#delete_patch (lib/patch_panel.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def delete_patch(dpid, port_a, port_b)
  delete_flow_entries dpid, port_a, port_b
  @patch[dpid] -= [port_a, port_b].sort
end</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_bin_patch_panel_コマンド">
<title>bin/patch_panel コマンド</title>
<simpara><literal>PatchPanel</literal> クラスの操作コマンドが <literal>bin/patch_panel</literal> です。<literal>PatchPanel</literal> クラスの <literal>create_patch</literal> と <literal>delete_patch</literal> メソッドを呼び出します。<literal>patch_panel create</literal> と <literal>patch_panel delete</literal> という 2 つのサブコマンドを持っています。</simpara>
<simpara>サブコマンドの実装には gli (<link xl:href="https://github.com/davetron5000/gli">https://github.com/davetron5000/gli</link>) というRubyライブラリを使っています。gli を使うと、<literal>patch_panel create</literal> や <literal>patch_panel delete</literal> といったサブコマンド体系、いわゆるコマンドスイートを簡単に実装できます。詳細は gli のドキュメントにゆずりますが、書きかたを簡単に紹介しておきます。</simpara>
<formalpara xml:id="patch_panel_command">
<title>bin/patch_panel</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">#!/usr/bin/env ruby

require 'rubygems'
require 'bundler'
Bundler.setup :default

require 'gli'
require 'trema'

# patch_panel command
module PatchPanelApp
  extend GLI::App

  desc 'Creates a new patch' <co xml:id="CO22-1"/>
  arg_name 'dpid port#1 port#2'
  command :create do |c|
    c.desc 'Location to find socket files'
    c.flag [:S, :socket_dir], default_value: Trema::DEFAULT_SOCKET_DIR

    c.action do |_global_options, options, args|
      dpid = args[0].hex
      port1 = args[1].to_i
      port2 = args[2].to_i
      Trema.trema_process('PatchPanel', options[:socket_dir]).controller.
        create_patch(dpid, port1, port2)
    end
  end

  desc 'Deletes a patch' <co xml:id="CO22-2"/>
  arg_name 'dpid port#1 port#2'
  command :delete do |c|
    c.desc 'Location to find socket files'
    c.flag [:S, :socket_dir], default_value: Trema::DEFAULT_SOCKET_DIR

    c.action do |_global_options, options, args|
      dpid = args[0].hex
      port1 = args[1].to_i
      port2 = args[2].to_i
      Trema.trema_process('PatchPanel', options[:socket_dir]).controller.
        delete_patch(dpid, port1, port2)
    end
  end

  exit run(ARGV)
end</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO22-1">
<para><literal>create</literal> サブコマンドの実装</para>
</callout>
<callout arearefs="CO22-2">
<para><literal>delete</literal> サブコマンドの実装</para>
</callout>
</calloutlist>
<simpara>gli を使ったサブコマンドの実装は、<literal>command サブコマンド名 do &#8230;&#8203; end</literal> のブロックを記述するだけです。それぞれのブロック内で、サブコマンドに渡されたオプションの処理と実際の動作を記述します。</simpara>
<formalpara>
<title>create サブコマンドの実装</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">desc 'Creates a new patch' <co xml:id="CO23-1"/>
arg_name 'dpid port#1 port#2' <co xml:id="CO23-2"/>
command :create do |c|
  c.desc 'Location to find socket files' <co xml:id="CO23-3"/>
  c.flag [:S, :socket_dir], default_value: Trema::DEFAULT_SOCKET_DIR <co xml:id="CO23-4"/>

  c.action do |_global_options, options, args|
    dpid = args[0].hex <co xml:id="CO23-5"/>
    port1 = args[1].to_i <co xml:id="CO23-6"/>
    port2 = args[2].to_i <co xml:id="CO23-7"/>
    Trema.trema_process('PatchPanel', options[:socket_dir]).controller.
      create_patch(dpid, port1, port2) <co xml:id="CO23-8"/>
  end
end</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO23-1">
<para><literal>create</literal> サブコマンドの説明</para>
</callout>
<callout arearefs="CO23-2">
<para>オプションの説明</para>
</callout>
<callout arearefs="CO23-3">
<para><literal>-S</literal> (<literal>--socket_dir</literal>) オプションの説明</para>
</callout>
<callout arearefs="CO23-4">
<para><literal>-S</literal> (<literal>--socket_dir</literal>) オプションとデフォルト値の定義</para>
</callout>
<callout arearefs="CO23-5 CO23-6 CO23-7">
<para>オプションのパース</para>
</callout>
<callout arearefs="CO23-8">
<para><literal>PatchPanel</literal> クラスの <literal>create_patch</literal> メソッドの呼び出し</para>
</callout>
</calloutlist>
<simpara>ポイントは、サブコマンド定義内での <literal>PatchPanel</literal> クラスのメソッド呼び出し部分です。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">Trema.trema_process('PatchPanel', options[:socket_dir]).controller.create_patch(dpid, port1, port2)</programlisting>
<simpara>この <literal>Trema.trema_process.controller</literal> メソッドは、現在動いているコントローラオブジェクト(<literal>PatchPanel</literal> クラスオブジェクト)を返します。そしてその返り値に対して <literal>create_patch</literal> などのメソッドを呼び出すことで、コントローラのメソッドを呼び出せます。</simpara>
</section>
</section>
<section xml:id="_まとめ_6">
<title>まとめ</title>
<simpara>フローを使ってパケットを転送する方法の入門編として、OpenFlowで実現するインテリジェント・パッチパネルを書きました。</simpara>
<itemizedlist>
<listitem>
<simpara>仮想スイッチに仮想ホストを接続してテストパケットを送信する方法を学んだ</simpara>
</listitem>
<listitem>
<simpara>フローエントリの削除方法を学んだ</simpara>
</listitem>
<listitem>
<simpara>コントローラ操作用の外部コマンドの書き方を学んだ</simpara>
</listitem>
</itemizedlist>
<simpara>実は、今回作ったOpenFlow版パッチパネルはSDNの一種です。なぜならば、OpenFlow版パッチパネルを使えばホストの所属するネットワークをソフトウェア的に切り替えられるからです。これは、物理ネットワークの上にそれぞれ独立したネットワークをいくつも作れるという意味で、もっとも単純なネットワーク仮想化に他なりません。</simpara>
<simpara>続く章では、これまで使ってきた 3 つの重要な OpenFlow メッセージである Flow Mod, Packet In, Packet Out を組み合わせてイーサネットスイッチ作りに挑戦です。</simpara>
</section>
</chapter>
<chapter xml:id="learning_switch">
<title>すべての基本、ラーニングスイッチ</title>
<simpara role="lead">データセンターのような複雑に入り組んだネットワークも、もしケーブルを抜いてバラバラにできたなら、スイッチやサーバなどの意外とシンプルな部品に分解できます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/learning_switch/learn.png"/>
</imageobject>
<textobject><phrase>learn</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_ラーニングスイッチとは何か">
<title>ラーニングスイッチとは何か</title>
<simpara>OpenFlowの世界では、コントローラとしてソフトウェア実装したイーサネットスイッチをよく<emphasis role="strong">ラーニングスイッチ</emphasis>と呼びます。なぜ、ラーニング（学習）スイッチと呼ぶのでしょうか。それは、イーサネットスイッチが次のように動くからです。</simpara>
<itemizedlist>
<listitem>
<simpara>学習：ホストから出たパケットに含まれる、ネットワーク上でのホストの位置情報を学習する</simpara>
</listitem>
<listitem>
<simpara>転送：今まで学習してきた位置情報を使って、パケットを宛先のホストまで転送する</simpara>
</listitem>
</itemizedlist>
<simpara>この「学習し、転送する」というラーニングスイッチの仕組みは応用が広く効きます。たとえば後半で紹介するいくつかのデータセンターネットワークも、基本はラーニングスイッチと同じく「学習し、転送する」という動作をします。自宅ネットワークであろうが最新鋭のデータセンターであろうが、基本的な考え方は同じなのです。</simpara>
<simpara>ラーニングスイッチを作れるようになれば、それをベースに改造することでいろいろなアプリケーションを作れるようになります。</simpara>
<itemizedlist>
<listitem>
<simpara>ルータ (<link linkend="router_part1">12章</link>,<link linkend="router_part2">13章</link>,<link linkend="router13">14章</link>)</simpara>
</listitem>
<listitem>
<simpara>ルーティングスイッチ (<link linkend="routing_switch">16章</link>)</simpara>
</listitem>
<listitem>
<simpara>ネットワークスライス (<link linkend="sliceable_switch">17章</link>)</simpara>
</listitem>
</itemizedlist>
<simpara>ではさっそく、ネットワークの基本部品であるラーニングスイッチをTremaで実装してみましょう。まずは一般的なイーサネットスイッチの動作原理を理解し、次にOpenFlowでの実現方法を見ていきます。</simpara>
</section>
<section xml:id="_イーサネットスイッチの仕組み">
<title>イーサネットスイッチの仕組み</title>
<simpara>簡単なネットワークを例にしてイーサネットスイッチの動作を説明します(<link linkend="switch_network">図 7-1</link>)。</simpara>
<figure xml:id="switch_network">
<title>イーサネットスイッチ1台とホスト2台からなるネットワークとFDBの内容</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/learning_switch/switch_network.png"/>
</imageobject>
<textobject><phrase>switch network</phrase></textobject>
</mediaobject>
</figure>
<simpara>イーサネットスイッチのポート1番と5番に、ホスト1と2をそれぞれ接続しています。また、それぞれのホストのネットワークカードは図に示したMACアドレスを持つとします。</simpara>
<simpara>イーサネットスイッチはホストから届いたパケットを宛先のホストまで転送するために、イーサネットスイッチにつながる各ホストの位置情報をためておくデータベースを持っています。これをフォワーディングデータベース(FDB)と呼び、FDBは「ホストのMACアドレス」+「ポート番号」の組を保持します。</simpara>
<simpara>ここでホスト2がホスト1へパケットを送信すると、イーサネットスイッチは<link linkend="host2to1">図 7-2</link>のようにパケットをホスト1まで転送します。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>届いたパケットの宛先MACアドレス(00:11:11:11:11:11)を見て、このMACアドレスを持つホストがつながるポート番号をFDBから探す</simpara>
</listitem>
<listitem>
<simpara>FDBには「MACアドレス00:11:11:11:11:11=ポート1」と学習しているので、ポート1にパケットを出力する</simpara>
</listitem>
</orderedlist>
<figure xml:id="host2to1">
<title>FDBの情報からパケットをホスト1に届ける</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/learning_switch/host2to1.png"/>
</imageobject>
<textobject><phrase>host2to1</phrase></textobject>
</mediaobject>
</figure>
<simpara>ここまでの仕組みがわかれば、イーサネットスイッチの機能を実現するコントローラ (ラーニングスイッチ) をOpenFlowで実現するのは簡単です。</simpara>
</section>
<section xml:id="_openflow版イーサネットスイッチ_ラーニングスイッチ_の仕組み">
<title>OpenFlow版イーサネットスイッチ(ラーニングスイッチ)の仕組み</title>
<simpara>OpenFlowによるイーサネットスイッチの構成は<link linkend="switch_network_openflow">図 7-3</link>のようになります。一般的なイーサネットスイッチとの違いは次の2つです。</simpara>
<itemizedlist>
<listitem>
<simpara>FDBをソフトウェアとして実装し、コントローラがFDBを管理する</simpara>
</listitem>
<listitem>
<simpara>パケットの転送は、コントローラがフローテーブルにフローエントリを書き込むことで制御する</simpara>
</listitem>
</itemizedlist>
<figure xml:id="switch_network_openflow">
<title>OpenFlowによるイーサネットスイッチ(ラーニングスイッチ)の構成</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/learning_switch/switch_network_openflow.png"/>
</imageobject>
<textobject><phrase>switch network openflow</phrase></textobject>
</mediaobject>
</figure>
<simpara>なお、初期状態でのFDBとフローテーブルの中身はどちらも空です。</simpara>
<section xml:id="_packet_inからホストの位置情報を学習">
<title>Packet Inからホストの位置情報を学習</title>
<simpara>この状態でホスト1がホスト2へパケットを送信すると、コントローラは次のようにホスト1のネットワーク上での位置情報を学習します(<link linkend="host1to2_openflow">図 7-4</link>)。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>フローテーブルはまだ空なので、パケットはPacket Inとしてコントローラまで上がる</simpara>
</listitem>
<listitem>
<simpara>コントローラはPacket Inメッセージからパケットの送信元MACアドレスとパケットの入ってきたポート番号を調べ、「ポート1番にはMACアドレスが00:11:11:11:11:11のホストがつながっている」とFDBに保存する</simpara>
</listitem>
</orderedlist>
<figure xml:id="host1to2_openflow">
<title>Packet Inの送信元MACアドレスとスイッチのポート番号をFDBに学習する</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/learning_switch/host1to2_openflow.png"/>
</imageobject>
<textobject><phrase>host1to2 openflow</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_packet_outでパケットを転送_フラッディング">
<title>Packet Outでパケットを転送(フラッディング)</title>
<simpara>学習が終わると次はパケットの転送です。もちろん、パケットの宛先はまだ学習していないので、コントローラは次のようにパケットをばらまくことで宛先まで届けます。このばらまく処理をフラッディングと呼びます(<link linkend="host1to2_flood_openflow">図 7-5</link>)。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>コントローラはPacket Inメッセージの宛先MACアドレスを調べ、FDBから送出先のポート番号を探す。しかし、ホスト2のMACアドレスとポート番号はまだFDBに入っていないのでわからない</simpara>
</listitem>
<listitem>
<simpara>コントローラは出力ポートをフラッディングに指定したPacket Outメッセージでパケットをばらまくようにスイッチに指示する。その結果、ポート5につながるホスト2にパケットが届く</simpara>
</listitem>
</orderedlist>
<figure xml:id="host1to2_flood_openflow">
<title>出力ポートがFDBから見つからないため、出力ポートをフラッディングに指定したPacket Outメッセージでパケットをばらまく</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/learning_switch/host1to2_flood_openflow.png"/>
</imageobject>
<textobject><phrase>host1to2 flood openflow</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_再び学習と転送_flow_modとpacket_out">
<title>再び学習と転送(Flow ModとPacket Out)</title>
<simpara>この状態でホスト2がホスト1へパケットを送信すると次のようになります(<link linkend="host2to1_openflow">図 7-6</link>)。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>フローテーブルが空なためコントローラまで再びPacket Inメッセージが上がる</simpara>
</listitem>
<listitem>
<simpara>コントローラはこのPacket Inメッセージから「ポート5番にはMACアドレスが00:22:22:22:22:22のホストがつながっている」とFDBに保存する</simpara>
</listitem>
<listitem>
<simpara>Packet Inの宛先MACアドレスとFDBを照らし合わせ、出力先のポート番号を探す。すでに「ポート1=MACアドレス00:11:11:11:11:11」と学習しているので、出力ポートは1と決定できる</simpara>
</listitem>
<listitem>
<simpara>「ホスト2からホスト1へのパケットはポート1へ出力せよ」というフローエントリをFlow Modメッセージでフローテーブルに書き込む。加えて、Packet Outメッセージ(出力ポート = 1)でPacket Inを起こしたパケットをポート1へ出力する</simpara>
</listitem>
</orderedlist>
<figure xml:id="host2to1_openflow">
<title>ホスト2のMACアドレスとポート番号をFDBに学習し、フローエントリを書き込むとともにパケットをホスト1に届ける</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/learning_switch/host2to1_openflow.png"/>
</imageobject>
<textobject><phrase>host2to1 openflow</phrase></textobject>
</mediaobject>
</figure>
<simpara>さて、ここまでの段階でフローテーブルには「ホスト2からホスト1へのパケットはポート1へ出力せよ」というフローエントリが入りました。もし、ホスト2がホスト1へ再びパケットを送信すると、今度はPacket Inがコントローラまで上がることはなく、スイッチ側だけでパケットを転送します。</simpara>
<simpara>残りのホスト1からホスト2へのフローエントリはどうでしょう。すでにFDBはすべてのホストのMACアドレスとポート番号を学習しています。もし、再びホスト1からホスト2へパケットを送信すると、<link linkend="host2to1_openflow">図 7-6</link>と同様にコントローラが「ホスト1からホスト2へのパケットはポート5へ出力せよ」というフローエントリを書き込みます。もちろん、それ以降の通信ではPacket Inはまったく上がらずにすべてスイッチ側だけでパケットを処理します。</simpara>
</section>
</section>
<section xml:id="_実行してみよう_4">
<title>実行してみよう</title>
<simpara>今回も仮想ネットワークを使ってラーニングスイッチを起動してみます。ソースコードと仮想ネットワークの設定ファイルはGitHubのtrema/learning_switchリポジトリ (<link xl:href="https://github.com/trema/learning_switch">https://github.com/trema/learning_switch</link>) からダウンロードできます。</simpara>
<screen>$ git clone https://github.com/trema/learning_switch.git</screen>
<simpara>ダウンロードしたソースツリー上で <literal>bundle install --binstubs</literal> を実行すると、Tremaなどの実行環境一式を自動的にインストールできます。</simpara>
<screen>$ cd learning_switch
$ bundle install --binstubs</screen>
<simpara>GitHubから取得したラーニングスイッチのソースリポジトリ内に、仮想スイッチ1台、仮想ホスト2台の構成を持つ設定ファイル <literal>trema.conf</literal> が入っています。</simpara>
<formalpara>
<title>trema.conf</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">vswitch('lsw') {
  datapath_id 0xabc
}

vhost ('host1') {
  ip '192.168.0.1'
}

vhost ('host2') {
  ip '192.168.0.2'
}

link 'lsw', 'host1'
link 'lsw', 'host2'</programlisting>
</para>
</formalpara>
<simpara>次のように <literal>trema run</literal> の <literal>-c</literal> オプションにこの設定ファイルを渡してラーニングスイッチを実行します。</simpara>
<screen>$ ./bin/trema run ./lib/learning_switch.rb -c trema.conf</screen>
<simpara>別ターミナルを開き、<literal>trema send_packets</literal> コマンドを使ってhost1とhost2の間でテストパケットを送ってみます。</simpara>
<screen>$ ./bin/trema send_packets --source host1 --dest host2
$ ./bin/trema send_packets --source host2 --dest host1</screen>
<simpara><literal>trema show_stats</literal> コマンドでhost1とhost2の受信パケット数をチェックし、それぞれでパケットを受信していれば成功です。</simpara>
<screen>$ ./bin/trema show_stats host1
Packets sent:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
Packets received:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet
$ ./bin/trema show_stats host2
Packets sent:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet
Packets received:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet</screen>
<simpara>ラーニングスイッチの動作イメージがわかったところで、ソースコードの解説に移りましょう。</simpara>
</section>
<section xml:id="_ラーニングスイッチのソースコード">
<title>ラーニングスイッチのソースコード</title>
<simpara>ラーニングスイッチのソースコードは <link linkend="learning_switch.rb">lib/learning_switch.rb</link> と <link linkend="fdb.rb">lib/fdb.rb</link> の 2 つからなります。まずはメインのソースコード (<link linkend="learning_switch.rb">lib/learning_switch.rb</link>) をざっと眺めてみましょう。 とくに、<literal>private</literal> の行よりも上のパブリックなメソッドに注目してください。</simpara>
<formalpara xml:id="learning_switch.rb">
<title>lib/learning_switch.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">require 'fdb'

# An OpenFlow controller that emulates an ethernet switch.
class LearningSwitch &lt; Trema::Controller
  timer_event :age_fdb, interval: 5.sec

  def start(_argv)
    @fdb = FDB.new
    logger.info "#{name} started."
  end

  def switch_ready(datapath_id)
    # Drop BPDU frames
    send_flow_mod_add(
      datapath_id,
      priority: 100,
      match: Match.new(destination_mac_address: '01:80:C2:00:00:00')
    )
  end

  def packet_in(_datapath_id, packet_in)
    @fdb.learn packet_in.source_mac, packet_in.in_port
    flow_mod_and_packet_out packet_in
  end

  def age_fdb
    @fdb.age
  end

  private

  def flow_mod_and_packet_out(packet_in)
    port_no = @fdb.lookup(packet_in.destination_mac)
    flow_mod(packet_in, port_no) if port_no
    packet_out(packet_in, port_no || :flood)
  end

  def flow_mod(packet_in, port_no)
    send_flow_mod_add(
      packet_in.datapath_id,
      match: ExactMatch.new(packet_in),
      actions: SendOutPort.new(port_no)
    )
  end

  def packet_out(packet_in, port_no)
    send_packet_out(
      packet_in.datapath_id,
      packet_in: packet_in,
      actions: SendOutPort.new(port_no)
    )
  end
end</programlisting>
</para>
</formalpara>
<simpara>今までの知識だけでも、このソースコードからいろいろなことがわかります。</simpara>
<itemizedlist>
<listitem>
<simpara>ラーニングスイッチの本体は <literal>LearningSwitch</literal> という名前のクラス</simpara>
</listitem>
<listitem>
<simpara>起動時に呼ばれる <literal>start</literal> ハンドラでFDBのインスタンス変数を作っている。FDBの実装は別ファイル <literal>lib/fdb.rb</literal> に分かれている</simpara>
</listitem>
<listitem>
<simpara>スイッチ接続時に呼ばれる <literal>swtich_ready</literal> ハンドラでは、宛先 MAC アドレスが <literal>01:80:C2:00:00:00</literal> のパケットを落とすフローエントリを打ち込んでいる</simpara>
</listitem>
<listitem>
<simpara><literal>packet_in</literal> ハンドラで呼ぶ <literal>flow_mod_and_packet_out</literal> メソッドの中では、<literal>@fdb</literal> を使ってポート番号を調べたり、<literal>flow_mod</literal> と <literal>packet_out</literal> メソッドでそれぞれFlow ModとPacket Outメッセージを送っている。また、先述した「パケットをばらまく(フラッディング)」処理に対応する <literal>:flood</literal> も見つかる</simpara>
</listitem>
</itemizedlist>
<simpara>ラーニングスイッチの心臓部は <literal>packet_in</literal> ハンドラだけで、その中身もたった 3 行のみと単純です。ラーニングスイッチの仕組みを思い出しながら、ソースコードを詳しく読み解いていきましょう。今回のポイントとなるのは、Packet In ハンドラでの次の処理です。</simpara>
<itemizedlist>
<listitem>
<simpara>FDBの更新とポート番号の検索</simpara>
</listitem>
<listitem>
<simpara>ポート番号が見つかった場合の、Flow ModとPacket Outの処理</simpara>
</listitem>
<listitem>
<simpara>ポート番号が見つからなかった場合の、フラッディング処理</simpara>
</listitem>
</itemizedlist>
<simpara>それでは、最初にPacket Inハンドラの内容から見ていきましょう。</simpara>
<section xml:id="_未知のパケット_packet_in_の処理">
<title>未知のパケット(Packet In)の処理</title>
<simpara>知らないパケットがPacket Inとして入ってきたとき、ラーニングスイッチは次のようにFDBにホストの位置情報を学習し、宛先のポート番号を調べます。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>パケットの送信元MACアドレスとパケットが入ってきたポート番号をPacket Inメッセージから取り出し、FDB (<literal>@fdb</literal>) に保存する</simpara>
</listitem>
<listitem>
<simpara>パケットの宛先MACアドレスとFDBから、パケットを出力するポート番号を調べる (<literal>@fdb.lookup</literal> メソッド)</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>LearningSwitch#packet_in, LearningSwitch#flow_mod_and_packet_out (lib/learning_switch.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in(_datapath_id, packet_in)
  @fdb.learn packet_in.source_mac, packet_in.in_port
  flow_mod_and_packet_out packet_in
end

def flow_mod_and_packet_out(packet_in)
  port_no = @fdb.lookup(packet_in.destination_mac)
  flow_mod(packet_in, port_no) if port_no
  packet_out(packet_in, port_no || :flood)
end</programlisting>
</para>
</formalpara>
<section xml:id="_宛先ポート番号が見つかった場合_flowmodとpacket_out">
<title>宛先ポート番号が見つかった場合(FlowModとPacket Out)</title>
<simpara>もし宛先ポートが見つかった場合、以降は同じパケットは同様に転送せよ、というフローエントリをスイッチに書き込みます (<literal>flow_mod</literal> メソッド)。また、Packet Inを起こしたパケットも忘れずにそのポートへ出力します (<literal>packet_out</literal> メソッド)。</simpara>
<formalpara>
<title>LearningSwitch#flow_mod_and_packet_out (lib/learning_switch.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def flow_mod_and_packet_out(packet_in)
  port_no = @fdb.lookup(packet_in.destination_mac)
  flow_mod(packet_in, port_no) if port_no
  packet_out(packet_in, port_no || :flood)
end</programlisting>
</para>
</formalpara>
<simpara>この <literal>flow_mod</literal> メソッドと <literal>packet_out</literal> メソッドはそれぞれ <literal>send_flow_mod_add</literal> (<link linkend="cbench">5 章「マイクロベンチマークCbench」</link>で紹介) および <literal>send_packet_out</literal> (Packet Outの送信) メソッドを次のように呼び出します。</simpara>
<formalpara>
<title>LearningSwitch#flow_mod, LearningSwitch#packet_out (lib/learning_switch.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def flow_mod(packet_in, port_no)
  send_flow_mod_add(
    packet_in.datapath_id,
    match: ExactMatch.new(packet_in),
    actions: SendOutPort.new(port_no)
  )
end

def packet_out(packet_in, port_no)
  send_packet_out(
    packet_in.datapath_id,
    packet_in: packet_in,
    actions: SendOutPort.new(port_no)
  )
end</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="_packet_out_api">
<title>Packet Out API</title>
<simpara>Packet OutはOpenFlowメッセージの1つで、スイッチの指定したポートからパケットを出力させるためのものです。TremaでPacket Outを送るためのメソッド <literal>send_packet_out</literal> は、次の2つの引数を取ります。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">send_packet_out(datapath_id, options)</programlisting>
<simpara>それぞれの引数の意味は次のとおりです。</simpara>
<variablelist>
<varlistentry>
<term><literal>datapath_id</literal></term>
<listitem>
<simpara>Packet Outメッセージの届け先となるスイッチのDatapath ID</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>options</literal></term>
<listitem>
<simpara>Packet Outメッセージの中身を決めるためのオプション。アクションによるパケットの書き換えや出力するポートをハッシュテーブルで指定する。それぞれのオプションにはデフォルト値が設定されているので、必要なオプションのみを指定すればよい</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Packet Outの使い道は、Packet Inメッセージとして入ってきたパケットをそのままスイッチのポートから送り出す場合がほとんどです。この場合、パケットの送信にスイッチのバッファを使う場合と使わない場合とで呼び出し方が変わります。</simpara>
<section xml:id="_スイッチのバッファを使ってpacket_outする場合">
<title>スイッチのバッファを使ってPacket Outする場合</title>
<simpara>パケットのデータがスイッチのバッファに乗っていることが期待できる場合には、次のように <literal>buffer_id</literal> オプションでバッファに乗っているパケットデータのIDを指定してやることでPacket Outできます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">send_packet_out(
  datapath_id,
  buffer_id: packet_in.buffer_id,
  raw_data: packet_in.raw_data,
  actions: SendOutPort.new(port_number)
)</programlisting>
<simpara>この場合コントローラからスイッチへのパケットデータのコピーが起こらないため、若干のスピードアップが期待できます。ただし、<link linkend="openflow_spec">2 章「OpenFlow の仕様」</link>のコラムで説明したとおり、バッファの中身は観測不能でデータがいつ消えるかもわからないため、この方法は推奨しません。</simpara>
</section>
<section xml:id="_スイッチのバッファを使わずにpacketoutする場合">
<title>スイッチのバッファを使わずにPacketOutする場合</title>
<simpara>スイッチのバッファを使わずに Packet Out する場合、次のように <literal>raw_data</literal> オプションでパケットのデータを指定する必要があります。バッファに乗っているいないにかかわらず Packet Out できるので、若干遅くはなりますが安全です。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">send_packet_out(
  datapath_id,
  raw_data: packet_in.raw_data,
  actions: SendOutPort.new(port_number)
)</programlisting>
<simpara>これは、次のように <literal>packet_in</literal> オプションを使うことで若干短くできます (<literal>.raw_data</literal> を書かなくてよくなります)。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">send_packet_out(
  datapath_id,
  packet_in: packet_in,
  actions: SendOutPort.new(port_number)
)</programlisting>
</section>
</section>
<section xml:id="_主なオプション一覧">
<title>主なオプション一覧</title>
<simpara><literal>options</literal> に指定できる主なオプションは次のとおりです。</simpara>
<variablelist>
<varlistentry>
<term><literal>buffer_id</literal></term>
<listitem>
<simpara>スイッチでバッファされているパケットの ID を指定する。この値を使うと、スイッチでバッファされているパケットを指定して Packet Out できるので効率が良くなる (ただし、スイッチにバッファされていない時はエラーになる)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>raw_data</literal></term>
<listitem>
<simpara>Packet Out するパケットの中身を指定する。もし <literal>buffer_id</literal> オプションが指定されておりスイッチにバッファされたパケットを Packet Out する場合、この値は使われない</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>packet_in</literal></term>
<listitem>
<simpara><literal>raw_data</literal> および <literal>in_port</literal> オプションを指定するためのショートカット。Packet In ハンドラの引数として渡される Packet In メッセージを指定する</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>actions</literal></term>
<listitem>
<simpara>Packet Out のときに実行したいアクションの配列を指定する。アクションが 1 つの場合は配列でなくてかまわない</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="_宛先ポート番号が見つからなかった場合_フラッディング">
<title>宛先ポート番号が見つからなかった場合 (フラッディング)</title>
<simpara>もし宛先ポートが見つからなかった場合、コントローラは Packet In したパケットをフラッディングしてばらまきます。これをやるのが <literal>flow_mod_and_packet_out</literal> メソッドで、ポート番号に予約ポート番号の <literal>:flood</literal> を指定して <literal>packet_out</literal> メソッドを呼び出します。<literal>:flood</literal> を指定した Packet Out メッセージをスイッチが受け取ると、Packet In したパケットをフラッディングします。</simpara>
<formalpara>
<title>LearningSwitch#flow_mod_and_packet_out (lib/learning_switch.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def flow_mod_and_packet_out(packet_in)
  port_no = @fdb.lookup(packet_in.destination_mac)
  flow_mod(packet_in, port_no) if port_no
  packet_out(packet_in, port_no || :flood)
end</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="_fdb_の実装">
<title>FDB の実装</title>
<simpara>learning_switch.rb の一行目の <literal>require 'fdb'</literal> は、同じディレクトリ内の fdb.rb を読み込みます。<literal>require</literal> はちょうど、C の <literal>#include</literal> や Java の <literal>import</literal> みたいなものと思ってください。Ruby では、たとえば fdb.rb というファイルを読み込みたいときは、拡張子の .rb を外して <literal>require 'fdb'</literal> と書きます。読み込む対象のファイルは、lib/ ディレクトリを起点とした相対パスで書きます。たとえば lib/learning_switch/extensions.rb を読み込みたいときには <literal>require 'learning_switch/extensions'</literal> と書きます。</simpara>
<simpara>fdb.rb もざっと目を通しておきましょう。このファイルは FDB の機能をカプセル化する <literal>FDB</literal> クラスを提供します。</simpara>
<formalpara>
<title>lib/fdb.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># A database that keeps pairs of a MAC address and a port number
class FDB
  # Forwarding database (FDB) entry.
  class Entry
    DEFAULT_AGE_MAX = 300

    attr_reader :mac
    attr_reader :port_no

    def initialize(mac, port_no, age_max = DEFAULT_AGE_MAX)
      @mac = mac
      @port_no = port_no
      @age_max = age_max
      @last_update = Time.now
    end

    def update(port_no)
      @port_no = port_no
      @last_update = Time.now
    end

    def aged_out?
      Time.now - @last_update &gt; @age_max
    end
  end

  def initialize
    @db = {}
  end

  def lookup(mac)
    entry = @db[mac]
    entry &amp;&amp; entry.port_no
  end

  def learn(mac, port_no)
    entry = @db[mac]
    if entry
      entry.update port_no
    else
      @db[mac] = Entry.new(mac, port_no)
    end
  end

  def age
    @db.delete_if { |_mac, entry| entry.aged_out? }
  end
end</programlisting>
</para>
</formalpara>
<simpara><literal>FDB</literal> クラスは3つのメソッド <literal>lookup</literal>・<literal>learn</literal>・<literal>age</literal> を持ちます。<literal>lookup</literal> メソッドを使うと MAC アドレスからポート番号を検索できます。逆に <literal>learn</literal> メソッドでは MAC アドレスとポート番号の組を学習できます。タイマで定期的に呼ばれる <literal>age</literal> メソッドでは、FDB に入っているすべてのエントリをエージングし、寿命を過ぎたもの (<literal>FDB::Entry#aged_out?</literal> で判定) を消します。</simpara>
</section>
<section xml:id="_不要なパケットを転送しない">
<title>不要なパケットを転送しない</title>
<simpara><literal>switch_ready</literal> ハンドラでは宛先 MAC アドレスが <literal>01:80:C2:00:00:00</literal> のパケットを落とすフローエントリを打ち込んでいました。</simpara>
<formalpara>
<title>lib/learning_switch.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def switch_ready(datapath_id)
  # Drop BPDU frames
  send_flow_mod_add(
    datapath_id,
    priority: 100,
    match: Match.new(destination_mac_address: '01:80:C2:00:00:00')
  )
end</programlisting>
</para>
</formalpara>
<simpara>コードコメントにもあるように、ここで落としているのはスパニングツリーの制御フレームである BPDU フレームです。OpenFlow ではスイッチを集中制御できるため、ループを防ぎたい場合には分散アルゴリズムの一種であるスパニングツリーは不要だからです。OpenFlow でループを防ぐ方法について詳しくは、<link linkend="routing_switch">16 章「たくさんのスイッチを制御する」</link>で解説します。</simpara>
</section>
</section>
<section xml:id="_まとめ_7">
<title>まとめ</title>
<simpara>実用的なOpenFlowアプリケーションのベースとなるラーニングスイッチの動作と作り方を学びました。</simpara>
<itemizedlist>
<listitem>
<simpara>コントローラは、Packet Inメッセージから送信元ホストのMACアドレスとホストのつながるスイッチポート番号をFDBに学習する</simpara>
</listitem>
<listitem>
<simpara>Packet Inの転送先がFDBからわかる場合、Flow Modで以降の転送情報をスイッチに書き込みPacketOutする</simpara>
</listitem>
<listitem>
<simpara>Packet Inの転送先がFDBからわからない場合は、入力ポート以外のすべてのポートにPacket Outでフラッディングする</simpara>
</listitem>
</itemizedlist>
<simpara>続く章ではこのラーニングスイッチを OpenFlow 1.3 のマルチプルテーブル機能を使って実装します。パケットの処理内容ごとにフローテーブルを分けることで、コントローラをすっきりと設計できます。</simpara>
</section>
</chapter>
<chapter xml:id="learning_switch13">
<title>OpenFlow1.3版ラーニングスイッチ</title>
<simpara role="lead">ラーニングスイッチを OpenFlow1.3 で実装し、OpenFlow1.0版のラーニングスイッチの欠点を解消します。</simpara>
<section xml:id="_openflow1_0版ラーニングスイッチの問題点">
<title>OpenFlow1.0版ラーニングスイッチの問題点</title>
<simpara><link linkend="learning_switch">7章</link>で実装したラーニングスイッチには、実は以下の問題点があります。</simpara>
<variablelist>
<varlistentry>
<term>フローテーブルが煩雑になる</term>
<listitem>
<simpara>OpenFlow1.0では同時に使えるフローテーブルは 1 つという制限があります。このため、ラーニングスイッチのようにBPDUフレームなどのフィルタリング用のフローエントリとパケット転送用のフローエントリが一つのフローテーブルに混在すると、後から見たときに解読が大変です。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>起動時の大量のPacketInを防げない</term>
<listitem>
<simpara>OpenFlow1.0ではフローエントリにマッチしないパケットはすべてPacket Inします。このため、<literal>switch_ready</literal> ハンドラでフィルタリング用のフローエントリを設定するよりも前にパケットがコントローラへ大量に到着すると、<literal>packet_in</literal> ハンドラの大量呼び出しによりコントローラがパンクしてしまいます。</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_マルチプルテーブル_2">
<title>マルチプルテーブル</title>
<simpara>フローテーブルは 1 つという OpenFlow1.0 の制限は、OpenFlow1.3 でなくなっています。OpenFlow1.3 では 1 つのパケットを処理を複数のフローテーブルを使って処理できます。このようなパケット処理をパイプライン処理と呼びます。ちょうどCPUの命令パイプラインのように、パケット処理を「フィルタリング」→「書き換え」→ &#8230;&#8203; →「転送」とステージごとに進めていくイメージです。フローテーブルごとに役割を明確にできるので、プログラマから見てフローエントリを整理しやすいというメリットがあります。</simpara>
<figure xml:id="pipeline">
<title>OpenFlow1.3でのマルチプルテーブルによるパイプライン処理</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/learning_switch13/pipeline.png"/>
</imageobject>
<textobject><phrase>pipeline</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_テーブルの移動">
<title>テーブルの移動</title>
<simpara>このパイプライン処理は、テーブル ID が 0 のテーブルから始まり GotoTable インストラクションによって次のテーブルに移動することで進みます。パイプライン処理の入口となるテーブル、つまり Packet In したときに最初に入るテーブルの ID は 0 と決まっています。現在のテーブルから次のテーブルへと処理を移行するには GotoTable インストラクションに次のテーブル ID を指定します。このとき指定するテーブル ID は、現在のテーブル ID よりも大きい必要があります。</simpara>
<figure xml:id="pipeline_goto">
<title>テーブル ID 0 から始まり GotoTable インストラクションで次のテーブルへ処理を移動</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/learning_switch13/pipeline_goto.png"/>
</imageobject>
<textobject><phrase>pipeline goto</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_openflow1_3_のアクション">
<title>OpenFlow1.3 のアクション</title>
<simpara>さて「GotoTable インストラクション」という用語を今まで断りなく使ってきましたが、OpenFlow1.3 ではパケットに対する処理を「アクション」と「インストラクション」に分けて書きます。まずはアクションから説明しましょう。</simpara>
<simpara>アクションの1つの用途はパケットの書き換えです。書き換えアクションの種類は OpenFlow1.0 に比べて大幅に増えており、マッチフィールドで指定できるフィールドの書き換えや VLAN ヘッダの操作に加え、TTL や MPLS, IPv6 パケット等への操作が追加されています (<link linkend="actions1.3_modify_fields">表8-1</link>)。</simpara>
<table xml:id="actions1.3_modify_fields" frame="all" rowsep="1" colsep="1">
<title>OpenFlow 1.3 で使えるアクション一覧 (パケットのフィールド書き換え)</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">アクションのクラス名</entry>
<entry align="left" valign="top">説明</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>SetField</literal></simpara></entry>
<entry align="left" valign="top"><simpara>マッチ条件で指定できるフィールドをパケットにセットする</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CopyTtlOut</literal></simpara></entry>
<entry align="left" valign="top"><simpara>2番目に外側のTTLの値を一番外側のTTLにコピーする</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CopyTtlIn</literal></simpara></entry>
<entry align="left" valign="top"><simpara>一番外側のTTLの値を1つ内側のTTLにコピーする</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SetMplsTtl</literal></simpara></entry>
<entry align="left" valign="top"><simpara>MPLSシムヘッダのTTLをセットする</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DecrementMplsTtl</literal></simpara></entry>
<entry align="left" valign="top"><simpara>MPLSシムヘッダのTTLを1つ減らす</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PushVlanHeader</literal></simpara></entry>
<entry align="left" valign="top"><simpara>新しいVLANヘッダをパケットに追加する</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PopVlanHeader</literal></simpara></entry>
<entry align="left" valign="top"><simpara>一番外側のVLANヘッダをパケットから取り除く</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PushMpls</literal></simpara></entry>
<entry align="left" valign="top"><simpara>新しいMPLSシムヘッダをパケットに追加する</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PopMpls</literal></simpara></entry>
<entry align="left" valign="top"><simpara>一番外側のMPLSタグまたはシムヘッダをパケットから取り除く</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>指定したグループテーブルでパケットを処理する</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SetIpTtl</literal></simpara></entry>
<entry align="left" valign="top"><simpara>IPv4のTTLまたはIPv6のhop limitをセットする</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DecrementIpTtl</literal></simpara></entry>
<entry align="left" valign="top"><simpara>IPv4のTTLまたはIPv6のhop limitを1つ減らす</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PushPbb</literal></simpara></entry>
<entry align="left" valign="top"><simpara>新しいPBBサービスインスタンスヘッダ (I-TAG TCI) をパケットに追加する</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PopPbb</literal></simpara></entry>
<entry align="left" valign="top"><simpara>一番外側のPBBサービスインスタンスヘッダ (I-TAG TCI) をパケットから取り除く</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>もう1つのアクションの用途はパケットの出力です。指定したポートへ出力したり、ポートに関連付けられたキューにパケットを追加するのに使います (<link linkend="actions1.3_output">表8-2</link>)。</simpara>
<table xml:id="actions1.3_output" frame="all" rowsep="1" colsep="1">
<title>OpenFlow 1.3 で使えるアクション一覧 (パケットの出力)</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">アクションのクラス名</entry>
<entry align="left" valign="top">説明</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>SendOutPort</literal></simpara></entry>
<entry align="left" valign="top"><simpara>指定したスイッチの (論理) ポートにパケットを出力する</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SetQueue</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>SendOutPort</literal> で指定したポートの指定したキューにパケットを追加する</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="_インストラクション_2">
<title>インストラクション</title>
<simpara>インストラクションはアクションよりも一段上の処理で、フローテーブルの移動とアクションの実行方法を記述できます。たとえば GotoTable インストラクションは、次のように Flow Mod の <literal>instructions</literal> パラメータに指定しておくことで、マッチしたパケットが到着するとそのパケット処理を指定したフローテーブルへと続けます。</simpara>
<formalpara>
<title>GotoTable インストラクションの指定方法</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># テーブル 0 番から 1 番へ GotoTable
send_flow_mod_add(
  datapath_id,
  table_id: 0,
    ...
  instructions: GotoTable.new(1)
)</programlisting>
</para>
</formalpara>
<simpara>インストラクションのもう1つの用途は、アクションを適用するタイミングの指定です。指定方法は次の 2 通りです。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Apply</literal> 指定したアクションを直ちにパケットへ適用する</simpara>
</listitem>
<listitem>
<simpara><literal>WriteActions</literal> 指定したアクションを後で適用するために、パケットに関連付ける</simpara>
</listitem>
</itemizedlist>
<simpara><literal>Apply</literal> を使うと指定したアクションを直ちにパケットへ適用できます。これはちょうど、OpenFlow1.0 の Flow Mod で <literal>actions</literal> を指定した場合と同じ効果を持ちます。</simpara>
<formalpara>
<title>Apply で指定したアクションをパケットへ直ちに適用</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># ポート 1 番へ出力
send_flow_mod_add(
  datapath_id,
    ...
  instructions: Apply.new(SendOutPort.new(1))
)</programlisting>
</para>
</formalpara>
<simpara><literal>WriteActions</literal> は指定したアクションを後でまとめて適用するために使います。GotoTable でテーブルを移動しながら、パケットに <literal>WriteActions</literal> で指定したアクションを「後で適用するアクション」に追加していきます。そして GotoTable を含まないフローエントリにパケットがマッチしたタイミングで、そのパケットの「後で適用するアクション」をまとめて適用します。</simpara>
<figure xml:id="pipeline_write_actions">
<title>WriteActions でアクションを後でまとめて適用</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/learning_switch13/pipeline_write_actions.png"/>
</imageobject>
<textobject><phrase>pipeline write actions</phrase></textobject>
</mediaobject>
</figure>
<simpara>「この後で適用するアクション」を<emphasis role="strong">アクションセット</emphasis>と呼びます。アクションセットはいわゆる集合なので、同じアクションを複数入れることはできません。<literal>WriteActions</literal> 以外にも、アクションセットを空にする <literal>Clear</literal> インストラクションがあります。ここまでのインストラクションを含めてインストラクション一覧を紹介しましょう。</simpara>
<table xml:id="instructions1.3" frame="all" rowsep="1" colsep="1">
<title>OpenFlow 1.3 で使えるインストラクション一覧</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">インストラクションのクラス名</entry>
<entry align="left" valign="top">説明</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GotoTable</literal></simpara></entry>
<entry align="left" valign="top"><simpara>マッチしたパケットの処理を指定したテーブルに引き継ぐ</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Apply</literal></simpara></entry>
<entry align="left" valign="top"><simpara>指定したアクションを実行する</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>WriteActions</literal></simpara></entry>
<entry align="left" valign="top"><simpara>アクションセットに指定したアクションを追加する</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Clear</literal></simpara></entry>
<entry align="left" valign="top"><simpara>アクションセットを空にする</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>WriteMetadata</literal></simpara></entry>
<entry align="left" valign="top"><simpara>テーブル間で引き継げる 64bit のメタデータをセット</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Meter</literal></simpara></entry>
<entry align="left" valign="top"><simpara>パケットを指定したメーターに適用する</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="_openflow1_3_での_packet_in">
<title>OpenFlow1.3 での Packet In</title>
<simpara>OpenFlow1.3では、フローエントリにマッチしないパケットはPacket Inしません。このため OpenFlow1.0 で問題となった、フローエントリの設定前にパケットが大量に到着しうるという問題を解決できます。OpenFlow1.3でPacketInを起こすためには、アクションに <literal>SendOutPort.new(:controller)</literal> (コントローラへパケットを送り PacketIn を起こす) を指定したフローエントリを明示的に追加します。</simpara>
</section>
<section xml:id="_openflow1_3版ラーニングスイッチの仕組み">
<title>OpenFlow1.3版ラーニングスイッチの仕組み</title>
<simpara>OpenFlow1.3版ラーニングスイッチでは、役割の異なる2つのフローテーブルを用いてイーサネットスイッチを実現します。</simpara>
<variablelist>
<varlistentry>
<term>フィルタリングテーブル</term>
<listitem>
<simpara>転送しないパケットをドロップする。それ以外のパケットは転送テーブルに送る</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>転送テーブル</term>
<listitem>
<simpara>学習したMACアドレスを使ってパケットを転送する。宛先MACアドレスが見つからない場合にはフラッディングする</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_ソースコード解説_4">
<title>ソースコード解説</title>
<simpara>OpenFlow1.3版パッチパネルのソースコードは<xref linkend="learning_switch13.rb"/>になります。</simpara>
<formalpara xml:id="learning_switch13.rb">
<title>lib/learning_switch13.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">require 'fdb'

# An OpenFlow controller that emulates an ethernet switch.
class LearningSwitch13 &lt; Trema::Controller
  timer_event :age_fdb, interval: 5.sec

  INGRESS_FILTERING_TABLE_ID = 0
  FORWARDING_TABLE_ID = 1

  AGING_TIME = 180

  def start(_args)
    @fdb = FDB.new
    logger.info "#{name} started."
  end

  def switch_ready(datapath_id)
    add_bpdu_drop_flow_entry(datapath_id)
    add_default_broadcast_flow_entry(datapath_id)
    add_default_flooding_flow_entry(datapath_id)
    add_default_forwarding_flow_entry(datapath_id)
  end

  def packet_in(_datapath_id, packet_in)
    @fdb.learn(packet_in.source_mac, packet_in.in_port)
    add_forwarding_flow_and_packet_out(packet_in)
  end

  def age_fdb
    @fdb.age
  end

  private

  def add_forwarding_flow_and_packet_out(packet_in)
    port_no = @fdb.lookup(packet_in.destination_mac)
    add_forwarding_flow_entry(packet_in, port_no) if port_no
    packet_out(packet_in, port_no || :flood)
  end

  def add_forwarding_flow_entry(packet_in, port_no)
    send_flow_mod_add(
      packet_in.datapath_id,
      table_id: FORWARDING_TABLE_ID,
      idle_timeout: AGING_TIME,
      priority: 2,
      match: Match.new(in_port: packet_in.in_port,
                       destination_mac_address: packet_in.destination_mac,
                       source_mac_address: packet_in.source_mac),
      instructions: Apply.new(SendOutPort.new(port_no))
    )
  end

  def packet_out(packet_in, port_no)
    send_packet_out(
      packet_in.datapath_id,
      packet_in: packet_in,
      actions: SendOutPort.new(port_no)
    )
  end

  def add_default_broadcast_flow_entry(datapath_id)
    send_flow_mod_add(
      datapath_id,
      table_id: FORWARDING_TABLE_ID,
      idle_timeout: 0,
      priority: 3,
      match: Match.new(destination_mac_address: 'ff:ff:ff:ff:ff:ff'),
      instructions: Apply.new(SendOutPort.new(:flood))
    )
  end

  def add_default_flooding_flow_entry(datapath_id)
    send_flow_mod_add(
      datapath_id,
      table_id: FORWARDING_TABLE_ID,
      idle_timeout: 0,
      priority: 1,
      match: Match.new,
      instructions: Apply.new(SendOutPort.new(:controller))
    )
  end

  def add_bpdu_drop_flow_entry(datapath_id)
    send_flow_mod_add(
      datapath_id,
      table_id: INGRESS_FILTERING_TABLE_ID,
      idle_timeout: 0,
      priority: 2,
      match: Match.new(destination_mac_address: '01:80:C2:00:00:00')
    )
  end

  def add_default_forwarding_flow_entry(datapath_id)
    send_flow_mod_add(
      datapath_id,
      table_id: INGRESS_FILTERING_TABLE_ID,
      idle_timeout: 0,
      priority: 1,
      match: Match.new,
      instructions: GotoTable.new(FORWARDING_TABLE_ID)
    )
  end
end</programlisting>
</para>
</formalpara>
<section xml:id="_switch_ready_ハンドラ">
<title>switch_ready ハンドラ</title>
<simpara><literal>switch_ready</literal> ハンドラでは、まだ学習していないパケットのデフォルト処理を新しく起動したスイッチのフローテーブルに書き込みます。</simpara>
<formalpara>
<title>LearningSwitch13#switch_ready (lib/learning_switch13.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def switch_ready(datapath_id)
  add_bpdu_drop_flow_entry(datapath_id)
  add_default_broadcast_flow_entry(datapath_id)
  add_default_flooding_flow_entry(datapath_id)
  add_default_forwarding_flow_entry(datapath_id)
end</programlisting>
</para>
</formalpara>
<simpara>最初に呼び出す <literal>add_bpdu_drop_flow_entry</literal> では、不要なスパニングツリーの BPDU フレームをドロップするフローエントリを書き込みます。</simpara>
<formalpara>
<title>LearningSwitch13#add_bpdu_drop_flow_entry (lib/learning_switch13.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def add_bpdu_drop_flow_entry(datapath_id)
  send_flow_mod_add(
    datapath_id,
    table_id: INGRESS_FILTERING_TABLE_ID,
    idle_timeout: 0,
    priority: 2,
    match: Match.new(destination_mac_address: '01:80:C2:00:00:00')
  )
end</programlisting>
</para>
</formalpara>
<simpara>Flow Mod に指定するパラメータのうち、ポイントとなるのは次の 3 つです。</simpara>
<variablelist>
<varlistentry>
<term><literal>table_id</literal></term>
<listitem>
<simpara>スイッチに入ってきたパケットの種類を見てドロップするかどうかを最初にフィルタリングする必要があるので、<literal>table_id</literal> には 0 (<literal>INGRESS_FILTERING_TABLE_ID</literal>) を指定します。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>idle_timeout</literal></term>
<listitem>
<simpara>BPDU フレームのドロップはスイッチの起動中はずっと有効なので、<literal>idle_timeout</literal> には 0 (フローエントリを消さない) を指定します。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>priority</literal></term>
<listitem>
<simpara>ドロップ処理は入ってきたパケットに対して最初に行うフィルタリングなので、テーブルID = 0 のフローエントリのうち最大優先度にします。ここでは 2 を指定します。</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>続く <literal>add_default_forwarding_flow_entry</literal> では、BPDU フレーム以外のパケットを <literal>FORWARDING_TABLE_ID</literal> で処理します。</simpara>
<formalpara>
<title>LearningSwitch13#add_default_forwarding_flow_entry (lib/learning_switch13.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def add_default_forwarding_flow_entry(datapath_id)
  send_flow_mod_add(
    datapath_id,
    table_id: INGRESS_FILTERING_TABLE_ID,
    idle_timeout: 0,
    priority: 1,
    match: Match.new,
    instructions: GotoTable.new(FORWARDING_TABLE_ID)
  )
end</programlisting>
</para>
</formalpara>
<simpara>ここで重要なパラメータは次の 3 つです。</simpara>
<variablelist>
<varlistentry>
<term><literal>priority</literal></term>
<listitem>
<simpara>優先度を 1 に設定することで、より優先度の高いBPDUフレーム処理 (優先度 = 2) が終わったあとにこの処理を行う</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>match</literal></term>
<listitem>
<simpara>空のマッチを指定することで、BPDUフレームでないパケットをすべてこのフローエントリで拾う</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>instructions</literal></term>
<listitem>
<simpara><literal>GotoTable(FORWARDING_TABLE_ID)</literal> を指定することで、以降の処理をテーブル 1 に移す</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>最後の <literal>add_default_flooding_flow_entry</literal> では、宛先 MAC アドレスをまだ学習していない場合のデフォルト処理をフローテーブルに書き込みます。</simpara>
<formalpara>
<title>LearningSwitch13#add_default_flooding_flow_entry (lib/learning_switch13.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def add_default_flooding_flow_entry(datapath_id)
  send_flow_mod_add(
    datapath_id,
    table_id: FORWARDING_TABLE_ID,
    idle_timeout: 0,
    priority: 1,
    match: Match.new,
    instructions: Apply.new(SendOutPort.new(:controller))
  )
end</programlisting>
</para>
</formalpara>
<variablelist>
<varlistentry>
<term><literal>table_id</literal></term>
<listitem>
<simpara>ここで追加するフローエントリは、直前の GotoTable でテーブル ID <literal>INGRESS_FILTERING_TABLE_ID</literal> から <literal>FORWARDING_TABLE_ID</literal> に移動した後に処理さる。このため、<literal>table_id</literal> には <literal>FORWARDING_TABLE_ID</literal> を指定する</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>priority</literal></term>
<listitem>
<simpara>フラッディング処理は宛先 MAC アドレスをまだ学習していなかった場合のデフォルト処理なので、優先度は低めの 1 を指定する</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>instructions</literal></term>
<listitem>
<simpara>フラッディングのための <literal>SendOutPort.new(:flood)</literal> アクションと、Packet In を起こするための <literal>SendOutPort.new(:controller)</literal> を <literal>Apply</literal> インストラクションで適用する</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_packet_in_ハンドラ">
<title>packet_in ハンドラ</title>
<simpara><literal>packet_in</literal> ハンドラでは、Packet In したパケットの送信元 MAC アドレス + In Port の組を学習します。学習した組はテーブル ID が FORWARDING_TABLE_ID であるフローテーブルにフローエントリとして追加します。</simpara>
<formalpara>
<title>LearningSwitch13#switch_ready (lib/learning_switch13.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in(_datapath_id, packet_in)
  @fdb.learn(packet_in.source_mac, packet_in.in_port)
  add_forwarding_flow_and_packet_out(packet_in)
end

private

def add_forwarding_flow_and_packet_out(packet_in)
  port_no = @fdb.lookup(packet_in.destination_mac)
  add_forwarding_flow_entry(packet_in, port_no) if port_no
  packet_out(packet_in, port_no || :flood)
end

def add_forwarding_flow_entry(packet_in, port_no)
  send_flow_mod_add(
    packet_in.datapath_id,
    table_id: FORWARDING_TABLE_ID,
    idle_timeout: AGING_TIME,
    priority: 2,
    match: Match.new(in_port: packet_in.in_port,
                     destination_mac_address: packet_in.destination_mac,
                     source_mac_address: packet_in.source_mac),
    instructions: Apply.new(SendOutPort.new(port_no))
  )
end</programlisting>
</para>
</formalpara>
<simpara>ここでの Flow Mod パラメータのポイントは次のとおりです。</simpara>
<variablelist>
<varlistentry>
<term><literal>priority</literal></term>
<listitem>
<simpara>優先度を <literal>FORWARDING_TABLE_ID</literal> の他のフローエントリ (フラッディング) よりも高くすることで、このフローエントリにマッチしない場合だけフラッディングするようにする</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>idle_timeout</literal></term>
<listitem>
<simpara>フローエントリの寿命を指定しておくことで、OpenFlow1.0 版のラーニングスイッチで行ったタイマによるエイジングと同じ効果を出せる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>match</literal>, <literal>instructions</literal></term>
<listitem>
<simpara>宛先が Packet In の送信元 MAC アドレスと同じだったら、Packet In の <literal>in_port</literal> から入ったパケットをそちらに送る、というエントリを入れる</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_まとめ_8">
<title>まとめ</title>
<simpara>ラーニングスイッチを OpenFlow1.3 で実装することで、OpenFlow1.0 版での問題点を解決しました。</simpara>
<itemizedlist>
<listitem>
<simpara>マルチプルテーブルを使うことで、フローテーブルごとにパケット処理を分けデバッグしやすくできる</simpara>
</listitem>
<listitem>
<simpara><literal>GotoTable</literal> インストラクションを使うことで、1つのパケットを複数のフローテーブルで処理できる</simpara>
</listitem>
<listitem>
<simpara>OpenFlow1.3 ではデフォルトで Packet In が起こらない。このため、OpenFlow1.0 で問題となるフローエントリ設定前の <literal>packet_in</literal> ハンドラの大量呼び出しが起こらない</simpara>
</listitem>
</itemizedlist>
<simpara>続く章ではアジャイル開発手法を使って、コントローラを反復的に開発する手法を紹介します。テストコードを書きながら徐々に機能を追加していくことで、バグの少ないコントローラを着実に開発できます。</simpara>
</section>
</chapter>
<chapter xml:id="tdd">
<title>Trema でテスト駆動開発</title>
<simpara role="lead">ソフトウェアテストは総合的なスキルを必要とする最高峰の奥義です。「テストを書き、コードを直す」この正確なくりかえしを身に付ければ、将来的にプロジェクトに豊富な見返りをもたらします。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/tdd/yutaro_test.png"/>
</imageobject>
<textobject><phrase>yutaro test</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_仕様書としてのテストコード">
<title>仕様書としてのテストコード</title>
<simpara>きちんと整備したテストコードは、元のコードの仕様書のようなものです。ふつうの仕様書は読むだけですが、テストコードは実行してみることでソフトウェアの動作をチェックできます。</simpara>
<simpara>OpenFlowネットワークとコントローラの保守をまかされたとしましょう。もし前任者からテストコードをもらえなければ、コントローラを何度も実行しながら苦労して解読しなければなりません。逆に、テストさえもらえればコード本体を理解しやすくなりますし、気楽にリファクタリングや修正ができます。とくにOpenFlowではスイッチとコントローラが複雑に絡み合い、しかもそれぞれがステートを持つので、ソフトウェアで自動化したテストがないとやってられません。</simpara>
<simpara>TremaはOpenFlowコントローラ開発のためのテストツールが充実しています。たとえばアジャイル開発者の大事な仕事道具、<emphasis role="strong">テスト駆動開発</emphasis>もTremaはサポートしています。本章ではテスト駆動を使ったコントローラの開発風景を紹介します。要点をつかみやすくするため、動作の単純なリピータハブを取り上げます。ではさっそく実際のテスト駆動開発の流れを見て行きましょう。</simpara>
<note>
<title>テスト駆動開発とテストファーストの違いは？</title>
<simpara>テスト駆動開発やテストファーストなど似たような用語に混乱している人も多いと思います。この2つの違いは何でしょうか。</simpara>
<simpara><emphasis role="strong">テストファースト</emphasis>はテスト駆動開発のステップの一部なので、テスト駆動開発のほうがより大きな概念になります。テスト駆動開発では、まずは失敗する見込みでテストを書き (このステップがテストファースト)、次にこのテストを通すためのコードを書きます。最後にコードをリファクタリングして、クリーンにします。この3ステップを数分間隔で何度も回しながら開発するのがテスト駆動開発です。</simpara>
</note>
</section>
<section xml:id="_リピータハブの動き">
<title>リピータハブの動き</title>
<simpara>まずは、リピータハブがどのように動くか見て行きましょう。リピータハブにホスト 3 台をつなげた<link linkend="repeater_hub">図 9-1</link>のネットワークを考えてください。ホスト 1 からホスト 2 へパケットを送信すると、リピータハブは入ってきたパケットを複製し他のすべてのホストにばらまきます。つまり、通信に関係のないホスト 3 もホスト 2 宛のパケットを受信します。このように、リピータハブはラーニングスイッチ (<link linkend="learning_switch">7 章「すべての基本、ラーニングスイッチ」</link>) のような MAC アドレスの学習は行わず、とにかくすべてのホストへパケットを送ってしまうので、バカハブとかダムハブとも呼びます。</simpara>
<figure xml:id="repeater_hub">
<title>ホスト 3 台をつなげたリピータハブの動作</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/tdd/repeater_hub.png"/>
</imageobject>
<textobject><phrase>repeater hub</phrase></textobject>
</mediaobject>
</figure>
<simpara>これを OpenFlow で実装すると<link linkend="repeater_hub_openflow">図 9-2</link>のようになります。ホスト 1 がパケットを送信すると、スイッチからコントローラに Packet In が起こります。ここでコントローラは「今後は同様のパケットを他の全ポートへばらまけ (フラッディング)」という Flow Mod を打ちます。また、Packet In を起こしたホスト 1 からのパケットを他の全ポートへ Packet Out でフラッディングします。</simpara>
<figure xml:id="repeater_hub_openflow">
<title>OpenFlow 版リピータハブ</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/tdd/repeater_hub_openflow.png"/>
</imageobject>
<textobject><phrase>repeater hub openflow</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_どこまでテストするか">
<title>どこまでテストするか？</title>
<simpara>おおまかな仕組みはわかったので、テストを書き始める前にテスト戦略を決めます。テスト戦略とは言い換えると「どこまでテストするか？」ということです。これは経験が必要なむずかしい問題なので、ソフトウェアテスト界の賢人達の言葉を借りることにしましょう。</simpara>
<simpara>テスト駆動開発の第一人者、ケント・ベックは stackoverflow.com の「どこまでテストするか？」というトピック <footnote><simpara><link xl:href="http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests">http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests</link></simpara></footnote> に次の投稿をしています。</simpara>
<blockquote>
<simpara>私はテストコードではなく動くコードに対してお金をもらっているので、ある程度の確信が得られる最低限のテストをするというのが私の主義だ (このレベルは業界水準からすると高いのではと思うが、ただの思い上がりかもしれない)。ふつうある種のミスを自分は犯さないとわかっていれば (コンストラクタで間違った変数をセットするとか)、そのためのテストはしない。</simpara>
</blockquote>
<simpara>Ruby on Rails の作者として有名な David Heinemeier Hansson 氏 (以下、DHH) は、彼の勤める Basecamp 社のブログ <footnote><simpara><link xl:href="https://signalvnoise.com/posts/3159-testing-like-the-tsa">https://signalvnoise.com/posts/3159-testing-like-the-tsa</link></simpara></footnote> で次のように語っています。</simpara>
<blockquote>
<simpara>コードのすべての行にはコストがかかる。テストを書くのにも、更新するのにも、読んで理解するのにも時間がかかる。したがってテストを書くのに必要なコストよりも、テストから得られる利益を大きくしなければいけない。テストのやりすぎは当然ながら間違っている。</simpara>
</blockquote>
<simpara>2人の言葉をまとめるとこうなります。</simpara>
<itemizedlist>
<listitem>
<simpara>目的はテストコードではなく、コードが正しく動くこと</simpara>
</listitem>
<listitem>
<simpara>正しく動くと確信が得られる、最低限のテストコードを書こう</simpara>
</listitem>
</itemizedlist>
<simpara>リピータハブのテスト戦略もこれに従いましょう。最低限のテストシナリオはこうなるはずです。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>ホスト 1・ホスト 2・ホスト 3 をスイッチにつなげ、</simpara>
</listitem>
<listitem>
<simpara>リピータハブのコントローラを起動したとき、</simpara>
</listitem>
<listitem>
<simpara>ホスト 1 がホスト 2 へパケットを送ると、</simpara>
</listitem>
<listitem>
<simpara>ホスト 2・ホスト 3 がパケットを受け取る</simpara>
</listitem>
</orderedlist>
<simpara>それぞれのステップを順にテストコードに起こしていきます。</simpara>
</section>
<section xml:id="_テストに使うツール">
<title>テストに使うツール</title>
<simpara>コントローラのテストには次の 3 つのツールを使います。</simpara>
<variablelist>
<varlistentry>
<term>Cucumber<footnote><simpara><link xl:href="https://cucumber.io">https://cucumber.io</link></simpara></footnote></term>
<listitem>
<simpara>受け入れテストの定番ツール。ブラックボックステストをシナリオ形式で簡潔に記述できる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Aruba<footnote><simpara><link xl:href="https://github.com/cucumber/aruba">https://github.com/cucumber/aruba</link></simpara></footnote></term>
<listitem>
<simpara>コマンドラインツールのテストツール。コマンドの起動と出力、終了ステータスなどのテストができる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>trema/cucumber_step_definitions<footnote><simpara><link xl:href="https://github.com/trema/cucumber_step_definitions">https://github.com/trema/cucumber_step_definitions</link></simpara></footnote></term>
<listitem>
<simpara>ArubaのTrema用ライブラリ。コントローラの起動やパケットの送受信といった、コントローラのテストを記述できる</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_パケット受信をテストする">
<title>パケット受信をテストする</title>
<simpara>では、リピータハブの動作を Cucumber の受け入れテストにしていきます。最初のテストシナリオを思い出してください。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>ホスト 1・ホスト 2・ホスト 3 をスイッチにつなげ、</simpara>
</listitem>
<listitem>
<simpara>リピータハブのコントローラを起動したとき、</simpara>
</listitem>
<listitem>
<simpara>ホスト 1 がホスト 2 へパケットを送ると、</simpara>
</listitem>
<listitem>
<simpara>ホスト 2・ホスト 3 がパケットを受け取る</simpara>
</listitem>
</orderedlist>
<simpara>テストシナリオを Cucumber の受け入れテストに置き換えるには、シナリオの各ステップを<emphasis role="strong">Given(前提条件)</emphasis>・<emphasis role="strong">When(〜したとき)</emphasis>・<emphasis role="strong">Then(こうなる)</emphasis>の3つに分類します。</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Given:</emphasis> ホスト 1・ホスト 2・ホスト 3 をスイッチにつなげ、リピータハブのコントローラを起動したとき、</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">When:</emphasis> ホスト 1 がホスト 2 へパケットを送ると、</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Then:</emphasis> ホスト 2・ホスト 3 がパケットを受け取る。</simpara>
</listitem>
</itemizedlist>
<simpara>では、まずは最初の Given ステップを Cucumber のコードに直します。</simpara>
<section xml:id="_given_仮想ネットワークでリピータハブを動かす">
<title>Given: 仮想ネットワークでリピータハブを動かす</title>
<simpara>シナリオの前提条件 (Given) には、まずはコントローラにつなげるスイッチとホスト 3 台のネットワーク構成 (<link linkend="repeater_hub">図 9-1</link>) を記述します。Cucumber のテストファイル <literal>features/repeater_hub.feature</literal> はこうなります:</simpara>
<screen>Given a file named "trema.conf" with:
  """
  vswitch('repeater_hub') { datapath_id 0xabc }

  vhost('host1') {
    ip '192.168.0.1'
    promisc true
  }
  vhost('host2') {
    ip '192.168.0.2'
    promisc true
  }
  vhost('host3') {
    ip '192.168.0.3'
    promisc true
  }

  link 'repeater_hub', 'host1'
  link 'repeater_hub', 'host2'
  link 'repeater_hub', 'host3'
  """</screen>
<simpara>最初の行 <literal>Given a file named "trema.conf" with: &#8230;&#8203;</literal> は、「&#8230;&#8203; という内容のファイル <literal>trema.conf</literal> があったとき、」を表すテストステップです。このように、Cucumber では英語 (自然言語) でテストステップを記述できます。</simpara>
<simpara>それぞれの仮想ホストで <literal>promisc</literal> オプション (プロミスキャスモード。自分宛でないパケットも受け取れるようにするモード) を <literal>true</literal> にしていることに注意してください。リピータハブはパケットをすべてのポートにばらまくので、こうすることでホストがどんなパケットでも受信できるようにしておきます。</simpara>
<simpara>続いて、この仮想ネットワーク上でコントローラを起動する Given ステップを次のように書きます。</simpara>
<screen>And I trema run "lib/repeater_hub.rb" with the configuration "trema.conf"</screen>
<simpara>これは、シェル上で次のコマンドを実行するのと同じです。</simpara>
<screen>$ ./bin/trema run lib/repeater_hub.rb -c trema.conf -d</screen>
<simpara>Given が書けたところですぐに実行してみます。まだ <literal>lib/repeater_hub.rb</literal> ファイルを作っていないのでエラーになることはわかりきっていますが、エラーを確認するためにあえて実行します。次のコマンドを実行すると、受け入れテストファイル <literal>features/repeater_hub.feature</literal> を実行しテスト結果を表示します。</simpara>
<screen>$ ./bin/cucumber features/repeater_hub.feature
Feature: Repeater Hub example
  @sudo
  Scenario: Run
    Given a file named "trema.conf" with:
      """
      vswitch('repeater_hub') { datapath_id 0xabc }

      vhost('host1') {
        ip '192.168.0.1'
        promisc true
      }
      vhost('host2') {
        ip '192.168.0.2'
        promisc true
      }
      vhost('host3') {
        ip '192.168.0.3'
        promisc true
      }

      link 'repeater_hub', 'host1'
      link 'repeater_hub', 'host2'
      link 'repeater_hub', 'host3'
      """
&lt;&lt;-STDERR
/home/yasuhito/.rvm/gems/ruby-2.2.0/gems/trema-0.7.1/lib/trema/command.rb:40:in `load': cannot load such file -- ../../lib/repeater_hub.rb (LoadError)
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/trema-0.7.1/lib/trema/command.rb:40:in `run'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/trema-0.7.1/bin/trema:54:in `block (2 levels) in &lt;module:App&gt;'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/gli-2.13.2/lib/gli/command_support.rb:126:in `call'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/gli-2.13.2/lib/gli/command_support.rb:126:in `execute'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/gli-2.13.2/lib/gli/app_support.rb:296:in `block in call_command'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/gli-2.13.2/lib/gli/app_support.rb:309:in `call'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/gli-2.13.2/lib/gli/app_support.rb:309:in `call_command'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/gli-2.13.2/lib/gli/app_support.rb:83:in `run'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/trema-0.7.1/bin/trema:252:in `&lt;module:App&gt;'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/trema-0.7.1/bin/trema:14:in `&lt;module:Trema&gt;'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/trema-0.7.1/bin/trema:12:in `&lt;top (required)&gt;'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/bin/trema:23:in `load'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/bin/trema:23:in `&lt;main&gt;'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/bin/ruby_executable_hooks:15:in `eval'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/bin/ruby_executable_hooks:15:in `&lt;main&gt;'

STDERR
    And I trema run "lib/repeater_hub.rb" with the configuration "trema.conf"
      expected "trema run ../../lib/repeater_hub.rb -c trema.conf -d" to be successfully executed (RSpec::Expectations::ExpectationNotMetError)
      ./features/step_definitions/trema_steps.rb:41:in `/^I trema run "([^"]*)"( interactively)? with the configuration "([^"]*)"$/'
      features/repeater_hub.feature:27:in `And I trema run "lib/repeater_hub.rb" with the configuration "trema.conf"'

Failing Scenarios:
cucumber features/repeater_hub.feature:5 # Scenario: Run as a daemon

1 scenario (1 failed)
3 steps (1 failed, 1 skipped, 1 passed)
0m8.113s</screen>
<simpara>予想通り、<literal>trema run</literal> の箇所でエラーになりました。エラーメッセージによると <literal>lib/repeater_hub.rb</literal> というファイルが無いと言っています。このエラーを直すために、とりあえず空のファイルを作ります。</simpara>
<screen>$ mkdir lib
$ touch lib/repeater_hub.rb
$ ./bin/cucumber features/repeater_hub.feature</screen>
<simpara>再びテストを実行すると、今度は次のエラーメッセージが出ます。</simpara>
<screen>$ ./bin/cucumber features/repeater_hub.feature
(中略)
&lt;&lt;-STDERR
error: No controller class is defined.

STDERR
    And I trema run "lib/repeater_hub.rb" with the configuration "trema.conf" # features/step_definitions/trema_steps.rb:30
      expected "trema run ../../lib/repeater_hub.rb -c trema.conf -d" to be successfully executed (RSpec::Expectations::ExpectationNotMetError)
      ./features/step_definitions/trema_steps.rb:41:in `/^I trema run "([^"]*)"( interactively)? with the configuration "([^"]*)"$/'
      features/repeater_hub.feature:27:in `And I trema run "lib/repeater_hub.rb" with the configuration "trema.conf"'</screen>
<simpara>repeater_hub.rb にコントローラクラスが定義されていない、というエラーです。エラーを修正するために、<literal>RepeaterHub</literal> クラスの定義を追加してみます。エラーを修正できればいいので、クラスの中身はまだ書きません。</simpara>
<formalpara>
<title>lib/repeater_hub.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">class RepeaterHub &lt; Trema::Controller
end</programlisting>
</para>
</formalpara>
<simpara>再びテストを実行してみます。今度はパスするはずです。</simpara>
<screen>$ ./bin/cucumber features/repeater_hub.feature
(中略)
1 scenario (1 passed)
3 steps (3 passed)
0m18.207s</screen>
<simpara>やりました! これで Given ステップは動作しました。</simpara>
<simpara>このようにテスト駆動開発では、最初にテストを書き、わざとエラーを起こしてからそれを直すためのコードをちょっとだけ追加します。テスト実行結果からのフィードバックを得ながら「テストを書き、コードを直す」を何度もくりかえしつつ最終的な完成形に近づけていくのです。</simpara>
</section>
<section xml:id="_when_パケットの送信">
<title>When: パケットの送信</title>
<simpara>When には「〜したとき」というきっかけになる動作を記述します。ここでは、Given で定義したホスト host1 から host2 にパケットを送る処理を書きます。パケットを送るコマンドは、trema send_packets でした。Cucumber (Aruba) では、実行したいコマンドを次のように <literal>I run &#8230;&#8203;</literal> で直接書けます。</simpara>
<screen>When I run `trema send_packets --source host1 --dest host2`</screen>
<simpara>テストを一行追加しただけですが、念のため実行しておきます。</simpara>
<screen>$ ./bin/cucumber features/repeater_hub.feature
(中略)
1 scenario (1 passed)
4 steps (4 passed)
0m21.910s</screen>
<simpara>問題なくテストが通りました。次は Then に進みます。</simpara>
</section>
<section xml:id="_then_受信したパケットの数">
<title>Then: 受信したパケットの数</title>
<simpara>Then には「最終的にこうなるはず」というテストを書きます。ここでは、「ホスト 2・ホスト 3 がパケットを受け取るはず」というステップを書けばよいですね。これは次のように書けます。</simpara>
<screen>Then the number of packets received by "host2" should be:
  |      source | #packets |
  | 192.168.0.1 |        1 |
And the number of packets received by "host3" should be:
  |      source | #packets |
  | 192.168.0.1 |        1 |</screen>
<simpara>このステップはテーブル形式をしており、ホスト 2・ホスト 3 それぞれについて、送信元 IP アドレス 192.168.0.1 からパケットを 1 つ受信するはず、ということを表しています。</simpara>
<simpara>ではさっそく実行してみます。</simpara>
<screen>$ ./bin/cucumber features/repeater_hub.feature
(中略)
    When I run `trema send_packets --source host1 --dest host2`
&lt;&lt;-STDERR

STDERR
    Then the number of packets received by "host2" should be:
      | source      | #packets |
      | 192.168.0.1 | 1        |

      expected: 1
           got: 0

      (compared using ==)
       (RSpec::Expectations::ExpectationNotMetError)
      ./features/step_definitions/show_stats_steps.rb:52:in `block (2 levels) in &lt;top (required)&gt;'
      ./features/step_definitions/show_stats_steps.rb:50:in `each'
      ./features/step_definitions/show_stats_steps.rb:50:in `/^the number of packets received by "(.*?)" should be:$/'
      features/repeater_hub.feature:30:in `Then the number of packets received by "host2" should be:'
    And the number of packets received by "host3" should be:
      | source      | #packets |
      | 192.168.0.1 | 1        |

Failing Scenarios:
cucumber features/repeater_hub.feature:5 # Scenario: Run as a daemon

1 scenario (1 failed)
6 steps (1 failed, 1 skipped, 4 passed)
0m20.198s</screen>
<simpara>host2 に 1 つ届くはずだったパケットが届いておらず、失敗しています。<literal>RepeaterHub</literal> クラスはまだ何も機能を実装していないので当然です。</simpara>
<simpara>フラッディングをする Flow Mod を打ち込むコードを <literal>RepeaterHub</literal> クラスに追加して、もう一度テストしてみます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class RepeaterHub &lt; Trema::Controller
  def packet_in(datapath_id, packet_in)
    send_flow_mod_add(
      datapath_id,
      match: ExactMatch.new(packet_in),
      actions: SendOutPort.new(:flood)
    )
  end
end</programlisting>
<screen>$ ./bin/cucumber features/repeater_hub.feature
(中略)
    Then the number of packets received by "host2" should be:
      | source      | #packets |
      | 192.168.0.1 | 1        |

      expected: 1
           got: 0</screen>
<simpara>失敗してしまいました。まだ host2 がパケットを受信できていません。そういえば、Flow Modしただけではパケットは送信されないので、明示的に Packet Out してやらないといけないのでした。そこで次のように Packet Out を追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class RepeaterHub &lt; Trema::Controller
  def packet_in(datapath_id, packet_in)
    send_flow_mod_add(
      datapath_id,
      match: ExactMatch.new(packet_in),
      actions: SendOutPort.new(:flood)
    )
    send_packet_out(
      datapath_id,
      raw_data: packet_in.raw_data,
      actions: SendOutPort.new(:flood)
    )
  end
end</programlisting>
<simpara>再び実行してみます。</simpara>
<screen>$ bundle exec cucumber features/repeater_hub.feature
Rack is disabled
Feature: "Repeater Hub" example

  @sudo
  Scenario: Run as a daemon
    Given a file named "trema.conf" with:
      """
      vswitch('repeater_hub') { datapath_id 0xabc }

      vhost('host1') {
        ip '192.168.0.1'
        promisc true
      }
      vhost('host2') {
        ip '192.168.0.2'
        promisc true
      }
      vhost('host3') {
        ip '192.168.0.3'
        promisc true
      }

      link 'repeater_hub', 'host1'
      link 'repeater_hub', 'host2'
      link 'repeater_hub', 'host3'
      """
    And I trema run "lib/repeater_hub.rb" with the configuration "trema.conf"
    When I run `trema send_packets --source host1 --dest host2`
    Then the number of packets received by "host2" should be:
      | source      | #packets |
      | 192.168.0.1 | 1        |
    And the number of packets received by "host3" should be:
      | source      | #packets |
      | 192.168.0.1 | 1        |

1 scenario (1 passed)
6 steps (6 passed)
0m20.976s</screen>
<simpara>すべてのテストに通りました! 次はテスト駆動開発で欠かせないステップであるリファクタリングに進みます。</simpara>
</section>
</section>
<section xml:id="_リファクタリング">
<title>リファクタリング</title>
<simpara>リファクタリングとは、テストコードによってソフトウェアの振る舞いを保ちつつ、理解や修正が簡単になるようにソースコードを改善することです。Rubyにはリファクタリング用の便利なツールがたくさんあります。中でもよく使うツールは次の 4 つです。</simpara>
<variablelist>
<varlistentry>
<term>reek<footnote><simpara><link xl:href="https://github.com/troessner/reek">https://github.com/troessner/reek</link></simpara></footnote></term>
<listitem>
<simpara>Rubyコードの臭いを自動的に検知し、改善すべき場所を教えてくれる便利なツール</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>flog<footnote><simpara><link xl:href="http://ruby.sadi.st/Flog.html">http://ruby.sadi.st/Flog.html</link></simpara></footnote></term>
<listitem>
<simpara>すべてのメソッドの複雑度 (これが大きいほど複雑でテストしづらい) を客観的なポイントで表示</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>flay<footnote><simpara><link xl:href="http://ruby.sadi.st/Flay.html">http://ruby.sadi.st/Flay.html</link></simpara></footnote></term>
<listitem>
<simpara>メソッドのコピペなど、重複するコードを探して容赦なく指摘してくれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>rubocop<footnote><simpara><link xl:href="https://github.com/bbatsov/rubocop">https://github.com/bbatsov/rubocop</link></simpara></footnote></term>
<listitem>
<simpara>コードが標準的な Ruby のコーディングスタイルに沿っているかチェックしてくれる</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><literal>RepeaterHub</literal> クラスは十分簡潔ですが、念のためこの 4 つを使ってチェックしておきます。</simpara>
<screen>$ ./bin/reek lib/repeater_hub.rb

$ ./bin/flog lib/repeater_hub.rb
     9.0: flog total
     4.5: flog/method average

     5.6: RepeaterHub#packet_in            lib/repeater_hub.rb:7

$ ./bin/flay lib/repeater_hub.rb
Total score (lower is better) = 0

$ ./bin/rubocop lib/repeater_hub.rb
Inspecting 1 file
.

1 file inspected, no offenses detected</screen>
<simpara><literal>reek</literal>・<literal>flog</literal>・<literal>flay</literal>・<literal>rubocop</literal> コマンドすべてで、エラーメッセージは出ていません。ただし <literal>flog</literal> は複雑度を表示するだけなので、リファクタリングするかどうかは自分で判断する必要があります。今回のように、目安として複雑度が10ポイント以下であれば、リファクタリングの必要はありません。</simpara>
<simpara>もしもここでエラーメッセージが出た場合には、コントローラをリファクタリングします。エラーメッセージには修正のヒントが入っているので、それに従えば機械的に修正できます。動くテストコードがあるので、リファクタリングの最中に誤ってコードを壊してしまっても、すぐにミスしたことがわかります。</simpara>
<simpara>以上でコントローラとテストコードの一式が完成しました!</simpara>
</section>
<section xml:id="_まとめ_9">
<title>まとめ</title>
<simpara>Tremaのユニットテストフレームワークを使ってリピータハブを作り、コントローラをテスト駆動開発する方法を学びました。今回学んだことは次の2つです。</simpara>
<itemizedlist>
<listitem>
<simpara>Cucumber・Aruba・trema/cucumber_step_definitionsを使うと、コントローラを起動して仮想ホストの受信パケット数などをテストできる</simpara>
</listitem>
<listitem>
<simpara>テストをGiven・When・Thenの3ステップに分けて分析し設計する方法を学んだ。それぞれのステップをCucumberのテストコードに置き換えることで、テストコードが完成する</simpara>
</listitem>
<listitem>
<simpara>テストが通ったら必ずリファクタリングすること。<literal>reek</literal>・<literal>flog</literal>・<literal>flay</literal>・<literal>rubocop</literal> を使うと、コードの問題点を客観的に洗い出してくれる</simpara>
</listitem>
</itemizedlist>
<simpara>本書で紹介するすべてのサンプルコードには、テストコード (<literal>features/</literal> 以下) が付属しています。本格的にテストコードを書く人は、参考にしてください。</simpara>
</section>
<section xml:id="_参考文献_2">
<title>参考文献</title>
<itemizedlist>
<listitem>
<simpara>『テスト駆動開発入門』(Kent Beck著／ピアソン・エデュケーション) テスト駆動開発のバイブルです。もったいないことに日本語版は訳がまずく、意味の通らないところがたくさんあります。もし英語が苦でなければ、原著の英語版で読むことをおすすめします。</simpara>
</listitem>
<listitem>
<simpara>『リファクタリング』(Martin Fowler著／ピアソン・エデュケーション) この本の最大の功績は、コードのまずい兆候を「コードの臭い」と表現したことです。粗相をした赤ちゃんのおむつのように臭うコードには改善が必要で、この本にはそのためのレシピがそろっています。この本はJavaですが、Ruby版(『リファクタリング：Rubyエディション』Jay Fields、Shane Harvie、Martin Fowler、Kent Beck著／アスキー・メディアワークス)もあります。</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="one_way_bridge">
<title>生活ネットワークをOpenFlowに移行する</title>
<simpara role="lead">あとは実践あるのみ!今までの知識を総動員し、自宅や職場のネットワークをOpenFlow化していろいろ実験してみましょう。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/one_way_bridge/bicycle.png"/>
</imageobject>
<textobject><phrase>bicycle</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_どんどん規模を広げていこう">
<title>どんどん規模を広げていこう</title>
<simpara>ここまでOpenFlowのプロトコルや動作モデル、そしてTremaを使ったOpenFlowプログラミングを学んできました。一人前のOpenFlowエンジニアとしてやっていくために必要な基礎知識はすでにひととおり身についたと言えます。</simpara>
<simpara>あとはひたすら実践するだけです。今まで手に入れた知識を実際に道具として使い、いま生活しているネットワーク上でOpenFlowを実際に動かしてみるのが一番です。まずは自宅のネットワークをOpenFlowで置き換えましょう。これがうまくいき物足りなくなったら、こんどは職場で小規模にOpenFlowネットワークを作りましょう。このように徐々に規模を広げて行くのです。</simpara>
<simpara>実際にその環境で暮らしてみて、はじめて見えてくるニーズやアイデア、改善案があります。初めて自転車に乗ったときのことを思い出してください。補助輪をはずしただけで最初は派手に転びますが、多少はケガをしつつもあきらめずに練習を繰り返しているうち誰でも乗りこなせるようになります。自転車に乗れれば、隣りの街やそのまた隣りと行動範囲は一気に広がります。しかし補助輪をはずさずにただ考えているだけではどこにも行けません。</simpara>
</section>
<section xml:id="_大ケガしないためのヘルメット">
<title>大ケガしないためのヘルメット</title>
<simpara>「でも、いきなりOpenFlowに移行してもし大失敗したら……」。そう考えるのが人情です。家のネットワークはともかく、もし職場のネットワークを止めて同僚に迷惑をかけてしまったらどうしよう……。管理者や上司に注意されたらどうしよう……。</simpara>
<simpara>本章ではそうした大失敗を防ぐための<emphasis role="strong">ヘルメット</emphasis>を紹介します。筆者らは、OpenFlowが登場したころから職場のネットワークで実験を始め、それこそ数え切れないほどの失敗を繰り返してきました。とにかく何度も怒られましたが、その経験からうまくやる方法をアドバイスできます。私たちは既存のネットワークを穏便にOpenFlowに移行するテクニックを持っています。ちょっとしたOpenFlowコントローラを書くだけで、移行の際に起こりがちなネットワーク障害を簡単に防げるのです。</simpara>
<simpara>まずは、私たちの失敗談を振り返らせてください。</simpara>
</section>
<section xml:id="_私たちの失敗談">
<title>私たちの失敗談</title>
<simpara>OpenFlowが登場したばかりのころ、私たちはさっそくスイッチングハブ相当のOpenFlowコントローラを書いて小さなOpenFlowネットワークを職場に構築してみました。「おお、ちゃんと動くじゃん!」気を良くした私たちは、こともあろうにこのOpenFlowネットワークと職場ネットワークとをいきなりつないでしまいました。まあ大丈夫だろうと楽観的に考えていたのです。</simpara>
<simpara>しかしすぐにネットワーク障害が起こり、異常に気づいたネットワーク管理者からお叱りのメールを受け取ることになりました。障害時のセットアップを単純化すると<link linkend="buggy_controller_setup">図10-1</link>のようになります。</simpara>
<figure xml:id="buggy_controller_setup">
<title>障害を起こしたときのネットワーク構成を単純化したもの</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/one_way_bridge/buggy_controller_setup.png"/>
</imageobject>
<textobject><phrase>buggy controller setup</phrase></textobject>
</mediaobject>
</figure>
<simpara>職場ネットワーク（レガシーネットワークとします）のスイッチにはホストを2台つないでおり、スイッチのポート3番をOpenFlowスイッチのポート1番と接続しました。このOpenFlowスイッチは、私たちが書いたスイッチングハブ相当のOpenFlowコントローラ(仮にBuggyControllerとします)で制御していました。</simpara>
<section xml:id="_障害報告_host_flappingが起こっている">
<title>障害報告：Host Flappingが起こっている</title>
<simpara>ネットワーク管理者から届いた障害報告メールには次のようにありました「レガシーネットワークのホストどうしが通信できなくなった。スイッチはHost Flapping警告を出している」</simpara>
<simpara>Host Flappingとは、1つのホストがいくつかのポートの間で高速で移動しているように見えるという障害です。「なんでそんなことが起こるんだろう？」われわれはすぐにOpenFlowネットワークを切断し、そしてもちろんネットワーク管理者にはごめんなさいメールを出してから、原因の分析にとりかかりました。</simpara>
</section>
<section xml:id="_障害原因が判明">
<title>障害原因が判明</title>
<simpara>分析の結果、<link linkend="failure_analysis">図10-2</link>のようなシナリオが起こっているという結論に至りました。</simpara>
<figure xml:id="failure_analysis">
<title>レガシーネットワークで起こった障害のシナリオ</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/one_way_bridge/failure_analysis.png"/>
</imageobject>
<textobject><phrase>failure analysis</phrase></textobject>
</mediaobject>
</figure>
<orderedlist numeration="arabic">
<listitem>
<simpara>host1がhost2へパケットを送信する</simpara>
</listitem>
<listitem>
<simpara>BuggyControllerはOpenFlowスイッチポート1番からのPacket Inを受け取り、OpenFlowスイッチのスイッチポート1番にhost1がつながっていると学習する</simpara>
</listitem>
<listitem>
<simpara>レガシーネットワークスイッチが覚えている host1 の情報がエージアウトし消える <footnote><simpara>厳密に言うと以下のステップが発生するには、レガシーネットワークスイッチのエージアウト間隔よりも OpenFlow スイッチのエージアウト間隔が長い、という前提条件があります</simpara></footnote></simpara>
</listitem>
<listitem>
<simpara>host2がhost1へパケットを送信する</simpara>
</listitem>
<listitem>
<simpara>BuggyControllerはスイッチポート1番から宛先＝host1のPacket Inを受け取る。ここで、host1はOpenFlowスイッチのスイッチポート1番にあると学習しているので、スイッチポート1番にPacket Outする</simpara>
</listitem>
<listitem>
<simpara>結果的に、host1はポート2と3の両方から同じパケットを受け取る。レガシーネットワークのスイッチから見ると、host2がスイッチポート2番と3番を高速に移動しているように見える</simpara>
</listitem>
</orderedlist>
<simpara>つまり、BuggyControllerがレガシーネットワークにパケットを逆流させたおかげでネットワークが大混乱し、通信できない状況が起きたのです。</simpara>
</section>
<section xml:id="_教訓_これをやってはいけない">
<title>教訓：これをやってはいけない</title>
<simpara>振り返ると、失敗した原因は2つありました。</simpara>
<simpara>1つは、OpenFlowネットワークをいきなりレガシーネットワークとつないでしまったことです。OpenFlowネットワーク単体では動いていたのに、というのは言い訳にはなりません。若気の至りや経験不足から来る青いミスです。もう1つは、BuggyControllerがPacket Inと同じポートにPacket Outするという通常あり得ない動作をしていたことです。要所要所で <literal>assert</literal> を入れるといった防御的プログラミングや、ソフトウェアテスト(<link linkend="tdd">9章「Trema でテスト駆動開発」</link>を参照)を徹底していれば防げるバグでしたが、当時の私たちは動かすことに精いっぱいでそこまで気が回りませんでした。</simpara>
<simpara>というわけで、大障害を起こして始めて気付くという最悪のパターンになってしまったわけです。</simpara>
</section>
</section>
<section xml:id="_openflowへの移行パターン">
<title>OpenFlowへの移行パターン</title>
<simpara>大失敗をやらかしてしまった筆者たちは、OpenFlow移行のための作戦を練りなおさざるを得なくなりました。いろいろな方向から考えなおしたところ、OpenFlowへの移行方法には次の3つのパターンがあることがわかりました。もちろん、それぞれでメリット／デメリットや危険度が異なります。</simpara>
<section xml:id="_独立ネットワークパターン">
<title>独立ネットワークパターン</title>
<simpara>最初のパターンは、既存のレガシーネットワークにまったく手を加えずに、それとは独立したもう1つのOpenFlowネットワークを構築する方法です(<link linkend="pattern1">図10-3</link>)。それぞれのネットワーク間でパケットの行き来はなく、お互いに完全に独立しています。</simpara>
<figure xml:id="pattern1">
<title>レガシーネットワークとは独立したOpenFlowネットワークを構築し、徐々に拡大する</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/one_way_bridge/pattern1.png"/>
</imageobject>
<textobject><phrase>pattern1</phrase></textobject>
</mediaobject>
</figure>
<simpara>この状態から、レガシーネットワーク内のサーバや端末を徐々にOpenFlowネットワークに移動することで移行していきます。</simpara>
<simpara>それぞれのネットワーク間ではパケットが行き来できないので、OpenFlowネットワークがレガシーネットワークに悪影響を及ぼす可能性はまずありません。ただし、OpenFlowネットワークに移行する際には関連する機器同士（ファイルサーバとクライアント群など）を一度に移行する必要があります。これはトラブルを起こす可能性が高いため、レガシーネットワークの規模が大きい場合には移行が難しいという問題があります。</simpara>
</section>
<section xml:id="_いきなり接続パターン">
<title>いきなり接続パターン</title>
<simpara>次のパターンは、私たちがやったようにレガシーネットワークとOpenFlowネットワークをいきなりつなげてしまう方法です（<link linkend="pattern2">図10-4</link>）。</simpara>
<figure xml:id="pattern2">
<title>レガシーネットワークとOpenFlowネットワークを直結してしまう</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/one_way_bridge/pattern2.png"/>
</imageobject>
<textobject><phrase>pattern2</phrase></textobject>
</mediaobject>
</figure>
<simpara>この方法だと、相互に通信できるのでネットワーク間でのサーバや端末の移動は自由にできます。このため、独立ネットワークパターンに比べて移行の手間はずっと小さいと言えます。</simpara>
<simpara>ただしこの方法は、私たちが失敗したようにとてもリスクの高い方法です。OpenFlowネットワークのコントローラが完璧に作られていれば、このようにいきなりつなげても問題はありませんが、完璧を期するのはなかなかむずかしいものです。というのも、実際のトラフィックをコントローラに流し込んでみて初めて見つかるバグもあるからです。よって、この方法は自宅ネットワークなど他人に迷惑のかからないネットワーク以外では推奨できません。</simpara>
</section>
<section xml:id="_フィルタ経由で接続パターン">
<title>フィルタ経由で接続パターン</title>
<simpara>最後のパターンは、今までに挙げてきた2つのパターンのいいとこどりです。2つのネットワークを接続するのですが、そのときに<emphasis role="strong">逆流防止フィルタ</emphasis>となるOpenFlowスイッチを間にはさむことでパケットの逆流が起きないようにします（<link linkend="pattern3">図10-5</link>）。</simpara>
<figure xml:id="pattern3">
<title>レガシーネットワークとOpenFlowネットワークの間での逆流を防止する</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/one_way_bridge/pattern3.png"/>
</imageobject>
<textobject><phrase>pattern3</phrase></textobject>
</mediaobject>
</figure>
<simpara>この逆流防止フィルタはたとえば、レガシーネットワーク→OpenFlow ネットワークのような一方向のパケットは通しますが、同じパケットがレガシー側に戻ることを防ぎます。逆方向も同様です。</simpara>
<simpara>この方法の利点は、逆流を防ぐだけで今回のケースも含めたかなりの障害を未然に防げることです。また、使い勝手はいきなり接続した場合と同じなのでOpenFlowへの移行も楽です。ただし、2つのネットワーク間にもう1つフィルタ用のOpenFlowスイッチをはさまなければならないという手間はかかります。</simpara>
</section>
</section>
<section xml:id="_逆流防止フィルタ">
<title>逆流防止フィルタ</title>
<simpara>検討の結果、逆流防止フィルタを使ったパターンが一番良さそうでした。フィルタを動かすためのサーバもちょうど余っていましたし、何よりコントローラとして簡単に実装できそうだったからです。前置きが長くなりましたが、さっそくTremaで実装してみましょう。</simpara>
<simpara>逆流防止フィルタは1つのPacket Inに対して2つのフローエントリを設定します。1つは順方向のフローエントリで、入ってきたパケットをもう1つのスイッチポートに転送します。もう1つは逆方向のフローエントリで、同じパケットが逆方向に流れてきたときにこのパケットを落とします。</simpara>
<section xml:id="_ソースコード">
<title>ソースコード</title>
<simpara>逆流防止フィルタ（OneWayBridge コントローラ）のソースコードは GitHub の trema/one_way_bridge リポジトリ (<link xl:href="https://github.com/trema/one_way_bridge">https://github.com/trema/one_way_bridge</link>) からダウンロードできます。</simpara>
<screen>$ git clone https://github.com/trema/one_way_bridge.git</screen>
<simpara>ダウンロードしたソースツリー上で <literal>bundle install --binstubs</literal> を実行すると、Tremaなどの実行環境一式を自動的にインストールできます。</simpara>
<screen>$ cd one_way_bridge
$ bundle install --binstubs</screen>
<simpara>このコントローラは、Packet In と Flow Removed のハンドラだけを定義したとてもシンプルなものです。</simpara>
<formalpara>
<title>lib/one_way_bridge.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># Safety-net controller bridging legacy and OpenFlow networks.
class OneWayBridge &lt; Trema::Controller
  def packet_in(datapath_id, packet_in)
    out_port = { 1 =&gt; 2, 2 =&gt; 1 }.fetch(packet_in.in_port)
    add_flow datapath_id, packet_in.source_mac, packet_in.in_port, out_port
    send_packet datapath_id, packet_in, out_port
    add_drop_flow datapath_id, packet_in.source_mac, out_port
  end

  def flow_removed(datapath_id, packet_in)
    delete_flow datapath_id, packet_in.match.source_mac_address
  end

  private

  def add_flow(datapath_id, source_mac, in_port, out_port)
    send_flow_mod_add(
      datapath_id,
      idle_timeout: 10 * 60,
      match: Match.new(in_port: in_port, source_mac_address: source_mac),
      actions: SendOutPort.new(out_port)
    )
  end

  def add_drop_flow(datapath_id, source_mac, in_port)
    send_flow_mod_add(
      datapath_id,
      idle_timeout: 10 * 60,
      match: Match.new(in_port: in_port, source_mac_address: source_mac)
    )
  end

  def send_packet(datapath_id, packet_in, out_port)
    send_packet_out(
      datapath_id,
      packet_in: packet_in,
      actions: SendOutPort.new(out_port)
    )
  end

  def delete_flow(datapath_id, source_mac)
    send_flow_mod_delete(
      datapath_id,
      match: Match.new(source_mac_address: source_mac)
    )
  end
end</programlisting>
</para>
</formalpara>
<simpara><literal>packet_in</literal> ハンドラでは、Packet Inしたスイッチポートとは別のポートへパケットを転送するフローエントリを設定し（<literal>add_flow</literal> メソッド）、Packet Inを起こしたパケットを転送します（<literal>send_packet</literal> メソッド）。また、同じパケットが逆向きに流れないようにするフローエントリを設定することで逆流を防ぎます（<literal>add_drop_flow</literal> メソッド）。同じパケットかどうかは送信元のMACアドレスが同じかどうかで判断します。</simpara>
<simpara><literal>flow_removed</literal> ハンドラは、順方向または逆方向のフローエントリが消えたときに呼ばれます。これらのフローエントリはどちらも <literal>:source_mac_address</literal> に同じMACアドレスを指定しているので、<literal>delete_flow</literal> メソッドでもう片方の対になるフローエントリを消します。</simpara>
</section>
<section xml:id="_実行してみよう_5">
<title>実行してみよう</title>
<simpara>逆流防止フィルタを実行するには、レガシーネットワークとOpenFlowネットワークの間にOpenFlowスイッチをはさみ、これをOneWayBridgeコントローラで制御します。でも実機のOpenFlowスイッチを準備するのは大変なので、Tremaの仮想ネットワーク機能でやってしまいましょう。NICが2枚挿さったサーバを用意し、仮想ネットワーク内で起動した仮想スイッチ(vswitch)の各ポートとそれぞれのNICを接続します(<link linkend="one_way_bridge_setup">図10-6</link>）。</simpara>
<figure xml:id="one_way_bridge_setup">
<title>逆流防止フィルタ（OneWayBridgeコントローラ）を実行するための物理構成例</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/one_way_bridge/one_way_bridge_setup.png"/>
</imageobject>
<textobject><phrase>one way bridge setup</phrase></textobject>
</mediaobject>
</figure>
<simpara>この物理構成をTrema設定ファイルにしたものが以下です。仮想リンク（<literal>link</literal> で始まる行）の端点にインタフェース名eth0、eth1を指定していることに注目してください。</simpara>
<formalpara>
<title>逆流防止フィルタ（OneWayBridgeコントローラ）の設定ファイル</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">vswitch ('bridge') {
  datapath_id 0xabc
}

link 'bridge', 'eth0'
link 'bridge', 'eth1'</programlisting>
</para>
</formalpara>
<simpara>実行するには、この設定ファイルを <literal>trema run</literal> の <literal>-c</literal> オプションに渡します。</simpara>
<screen>$ ./bin/trema run ./lib/one-way-bridge.rb -c ./trema.conf</screen>
</section>
<section xml:id="_職場で使ってみた">
<title>職場で使ってみた</title>
<simpara>さっそくこの逆流防止フィルタを導入したところ、問題は起こらなくなりました。現在、OpenFlowスイッチ5台、ホスト約100台から構成されるOpenFlowネットワークを職場ネットワークと接続して運用しています。このOpenFlowネットワークは現在もどんどん拡大しつつあり、その上でOpenFlowを使ったたくさんのアプリケーションが生まれています。こうした<emphasis role="strong">実践あるのみ</emphasis>という姿勢から生まれたたくさんのアプリケーション、それを支えるプログラミングフレームワークとして誕生したのがTremaです。</simpara>
</section>
</section>
<section xml:id="_まとめ_10">
<title>まとめ</title>
<simpara>職場のネットワークを安全にOpenFlowに移行するためのTipsを学びました。</simpara>
<itemizedlist>
<listitem>
<simpara>レガシーネットワークをOpenFlowに移行するいくつかのパターンを考察。自宅など自由にできるネットワークでは<emphasis role="strong">いきなり接続パターン</emphasis>で十分だが、職場ネットワークでは<emphasis role="strong">逆流防止パターン</emphasis>が最適</simpara>
</listitem>
<listitem>
<simpara>逆流防止フィルタを実現するOpenFlowコントローラを実装。2つのフローエントリを設定するだけで、簡単に逆流を防止できる</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="firewall">
<title>ファイアウォール</title>
<simpara role="lead">ファイアウォールは、外部からの不要なパケットの通過を遮断することで、ネットワークを攻撃から守るネットワーク機器です。そのファイアウォールを OpenFlow を使って作ってみましょう。</simpara>
<section xml:id="_透過型ファイアウォール">
<title>透過型ファイアウォール</title>
<simpara>今回実装するファイアウォールはいわゆる<emphasis role="strong">透過型ファイアウォール</emphasis>です。<link linkend="transparent_firewall">図 11-1</link> のようにルータとホストの間にブリッジとしてはさむだけでパケットのフィルタリングが可能です。既存のルータをそのまま使うため、各ホストのネットワーク設定を変更しなくてよいという利点があります。</simpara>
<figure xml:id="transparent_firewall">
<title>透過型ファイアウォール</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/transparent_firewall/transparent_firewall.png"/>
</imageobject>
<textobject><phrase>transparent firewall</phrase></textobject>
</mediaobject>
</figure>
<simpara>パケットのフィルタリングはIPv4ヘッダの情報に基づいて行います。今回はフィルタリングのルールが異なる以下の2種類ファイアウォールを実装します。</simpara>
<variablelist>
<varlistentry>
<term>BlockRFC1918</term>
<listitem>
<simpara>RFC1918が定義するプライベートアドレスを送信元または宛先とするパケットを遮断するファイアウォール。外側からと内側からの両方のパケットを遮断する。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PassDelegated</term>
<listitem>
<simpara>グローバルアドレスからのパケットのみを通すファイアウォール。外側→内側のパケットのみをフィルタする。</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_blockrfc1918コントローラ">
<title>BlockRFC1918コントローラ</title>
<simpara>BlockRFC1918コントローラは送信元または宛先 IP アドレスがプライベートアドレスのパケットを遮断します (<link linkend="block_rfc1918">図 11-2</link>)。プライベートアドレスは RFC1918 (プライベート網のアドレス割当) が定義する次の 3 つの IP アドレス空間です。</simpara>
<itemizedlist>
<listitem>
<simpara>10.0.0.0/8</simpara>
</listitem>
<listitem>
<simpara>172.16.0.0/12</simpara>
</listitem>
<listitem>
<simpara>192.168.0.0/16</simpara>
</listitem>
</itemizedlist>
<figure xml:id="block_rfc1918">
<title>BlockRFC1918ファイアウォールはプライベートアドレスからのパケットを遮断</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/transparent_firewall/block_rfc1918.png"/>
</imageobject>
<textobject><phrase>block rfc1918</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_実行してみよう_6">
<title>実行してみよう</title>
<simpara>仮想ネットワークを使って BlockRFC1918 コントローラを起動してみます。ソースコードと仮想ネットワークの設定ファイルは GitHub の <literal>trema/transparent_firewall</literal> リポジトリ (<link xl:href="https://github.com/trema/transparent_firewall">https://github.com/trema/transparent_firewall</link>) からダウンロードできます。</simpara>
<screen>$ git clone https://github.com/trema/transparent_firewall.git</screen>
<simpara>ダウンロードしたソースツリー上で <literal>bundle install --binstubs</literal> を実行すると、Tremaなどの実行環境一式を自動的にインストールできます。</simpara>
<screen>$ cd transparent_firewall
$ bundle install --binstubs</screen>
<simpara>GitHub から取得したソースリポジトリ内に、仮想スイッチ1台、仮想ホスト3台の構成を持つ設定ファイル <literal>trema.conf</literal> が入っています (<link linkend="firewall_configuration">図 11-3</link>)。</simpara>
<figure xml:id="firewall_configuration">
<title>BlockRFC1918 を実行するための仮想ネットワーク構成</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/transparent_firewall/configuration.png"/>
</imageobject>
<textobject><phrase>configuration</phrase></textobject>
</mediaobject>
</figure>
<formalpara>
<title>trema.conf</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">vswitch('firewall') { datapath_id 0xabc }

vhost('outside') { ip '192.168.0.1' }
vhost('inside') { ip '192.168.0.2' }
vhost('inspector') {
  ip '192.168.0.3'
  promisc true
}

link 'firewall', 'outside'
link 'firewall', 'inside'
link 'firewall', 'inspector'</programlisting>
</para>
</formalpara>
<simpara>ホスト outside は外側のネットワーク、たとえばインターネット上のホストとして動作します。ホスト inside は内側のネットワークのホストです。ホスト inspector は BlockRFC1918 ファイアウォールが落としたパケットを調べるためのデバッグ用ホストです。inspector は outside または inside 宛のパケットを受け取るので、<literal>promisc</literal> オプションを有効にすることで自分宛でないパケットも受け取れるようにしておきます。</simpara>
<simpara>では、いつものように <literal>trema run</literal> の <literal>-c</literal> オプションにこの設定ファイルを渡して BlockRFC1918 コントローラを実行してみましょう。</simpara>
<screen>$ ./bin/trema run ./lib/block_rfc1918.rb -c trema.conf
0xabc: connected
0xabc: loading finished</screen>
<simpara>別ターミナルを開き、<literal>trema send_packets</literal> コマンドを使って outside と inside ホストの間でテストパケットを送ってみます。</simpara>
<screen>$ ./bin/trema send_packets --source outside --dest inside
$ ./bin/trema send_packets --source inside --dest outside</screen>
<simpara>outside と inside はどちらもプライベートアドレスを持つので、BlockRFC1918 コントローラがパケットを落とすはずです。落としたパケットは inspector ホストへ送られます。</simpara>
<simpara><literal>trema show_stats</literal> コマンドで outside、inside そして inspector の受信パケット数をチェックしてみましょう。</simpara>
<screen>$ ./bin/trema show_stats outside
Packets sent:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
$ ./bin/trema show_stats inside
Packets sent:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet
$ ./bin/trema show_stats inspector
Packets received:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet</screen>
<simpara>たしかに、outside と inside の <literal>show_stats</literal> には <literal>Packets received:</literal> の項目がないので、どちらにもパケットは届いていません。そして、落としたパケット 2 つはどちらも inspector に届いています。</simpara>
</section>
</section>
<section xml:id="_blockrfc1918のソースコード">
<title>BlockRFC1918のソースコード</title>
<simpara>BlockRFC1918のソースコードをざっと眺めてみましょう。やっていることは基本的にフローエントリの設定だけなので、難しい点はありません。</simpara>
<formalpara>
<title>lib/block_rfc1918.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># A sample transparent firewall
class BlockRFC1918 &lt; Trema::Controller
  PORT = {
    outside: 1,
    inside: 2,
    inspect: 3
  }

  PREFIX = ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16'].map do |each|
    IPv4Address.new each
  end

  def switch_ready(dpid)
    if @dpid
      logger.info "#{dpid.to_hex}: ignored"
      return
    end
    @dpid = dpid
    logger.info "#{@dpid.to_hex}: connected"
    start_loading
  end

  def switch_disconnected(dpid)
    return if @dpid != dpid
    logger.info "#{@dpid.to_hex}: disconnected"
    @dpid = nil
  end

  def barrier_reply(dpid, _message)
    return if dpid != @dpid
    logger.info "#{@dpid.to_hex}: loading finished"
  end

  private

  def start_loading
    PREFIX.each do |each|
      block_prefix_on_port prefix: each, in_port: :inside, priority: 5000
      block_prefix_on_port prefix: each, in_port: :outside, priority: 4000
    end
    install_postamble 1500
    send_message @dpid, Barrier::Request.new
  end

  def block_prefix_on_port(prefix:, in_port:, priority:)
    send_flow_mod_add(
      @dpid,
      priority: priority + 100,
      match: Match.new(in_port: PORT[in_port],
                       ether_type: 0x0800,
                       source_ip_address: prefix),
      actions: SendOutPort.new(PORT[:inspect]))
    send_flow_mod_add(
      @dpid,
      priority: priority,
      match: Match.new(in_port: PORT[in_port],
                       ether_type: 0x0800,
                       destination_ip_address: prefix),
      actions: SendOutPort.new(PORT[:inspect]))
  end

  def install_postamble(priority)
    send_flow_mod_add(
      @dpid,
      priority: priority + 100,
      match: Match.new(in_port: PORT[:inside]),
      actions: SendOutPort.new(PORT[:outside]))
    send_flow_mod_add(
      @dpid,
      priority: priority,
      match: Match.new(in_port: PORT[:outside]),
      actions: SendOutPort.new(PORT[:inside]))
  end
end</programlisting>
</para>
</formalpara>
<simpara>スイッチがコントローラに接続すると、<literal>switch_ready</literal> ハンドラが呼ばれます。<literal>switch_ready</literal> ハンドラでは、フローエントリを設定する <literal>start_loading</literal> メソッドを呼びます。</simpara>
<formalpara>
<title>BlockRFC1918#switch_ready (lib/block_rfc1918.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def switch_ready(dpid)
  if @dpid
    logger.info "#{dpid.to_hex}: ignored"
    return
  end
  @dpid = dpid
  logger.info "#{@dpid.to_hex}: connected"
  start_loading <co xml:id="CO24-1"/>
end</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO24-1">
<para>フローエントリを設定する <literal>start_loading</literal> メソッドを呼ぶ</para>
</callout>
</calloutlist>
<simpara><literal>start_loading</literal> メソッドでは、パケットのドロップと転送用のフローエントリを設定します。まず、RFC1918 が定義する 3 つのプライベートアドレス空間それぞれについて、送信元または宛先 IP アドレスがプライベートアドレスのパケットを <literal>inspector</literal> ホストに転送するフローエントリを <literal>block_prefix_on_port</literal> メソッドで設定します。</simpara>
<formalpara>
<title>BlockRFC1918#start_loading, BlockRFC1918#block_prefix_on_port (lib/block_rfc1918.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def start_loading
  PREFIX.each do |each|
    block_prefix_on_port prefix: each, in_port: :outside, priority: 4000 <co xml:id="CO25-1"/>
    block_prefix_on_port prefix: each, in_port: :inside, priority: 5000  <co xml:id="CO25-2"/>
  end
  install_postamble 1500
  send_message @dpid, Barrier::Request.new
end

def block_prefix_on_port(prefix:, in_port:, priority:)
  send_flow_mod_add( <co xml:id="CO25-3"/>
    @dpid,
    priority: priority + 100,
    match: Match.new(in_port: PORT[in_port],
                     ether_type: 0x0800,
                     source_ip_address: prefix),
    actions: SendOutPort.new(PORT[:inspect]))
  send_flow_mod_add( <co xml:id="CO25-4"/>
    @dpid,
    priority: priority,
    match: Match.new(in_port: PORT[in_port],
                     ether_type: 0x0800,
                     destination_ip_address: prefix),
    actions: SendOutPort.new(PORT[:inspect]))
end</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO25-1">
<para>スイッチのポート 1 番 (内側ネットワークと接続) で受信するパケットのフローエントリを設定</para>
</callout>
<callout arearefs="CO25-2">
<para>スイッチのポート 2 番 (外側ネットワークと接続) で受信するパケットのフローエントリを設定</para>
</callout>
<callout arearefs="CO25-3">
<para>送信元 IP アドレスがプライベートアドレスのパケットを <literal>inspector</literal> ホストに転送するフローエントリを追加</para>
</callout>
<callout arearefs="CO25-4">
<para>宛先 IP アドレスがプライベートアドレスのパケットを <literal>inspector</literal> ホストに転送するフローエントリを追加</para>
</callout>
</calloutlist>
<simpara>送信元 IP アドレスがプライベートアドレスでないパケットは転送を許可します。このフローエントリは <literal>install_postamble</literal> メソッドで次のように設定します。</simpara>
<formalpara>
<title>BlockRFC1918#install_postamble (lib/block_rfc1918.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def install_postamble(priority)
  send_flow_mod_add( <co xml:id="CO26-1"/>
    @dpid,
    priority: priority + 100,
    match: Match.new(in_port: PORT[:inside]),
    actions: SendOutPort.new(PORT[:outside]))
  send_flow_mod_add( <co xml:id="CO26-2"/>
    @dpid,
    priority: priority,
    match: Match.new(in_port: PORT[:outside]),
    actions: SendOutPort.new(PORT[:inside]))
end</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO26-1">
<para>スイッチのポート 2 番 (内側ネットワーク) で受信した転送 OK なパケットはポート 1 番 (外側ネットワーク) へ転送</para>
</callout>
<callout arearefs="CO26-2">
<para>逆にスイッチのポート 1 番で受信した転送 OK なパケットはポート 2 番へ転送</para>
</callout>
</calloutlist>
<simpara>最後に、すべてのフローエントリがスイッチに反映したことをバリアで確認します。スイッチへ <literal>Barrier::Request</literal> メッセージを送り、スイッチからの <literal>Barrier::Reply</literal> メッセージが <literal>barrier_reply</literal> ハンドラへ届けば、すべてフローエントリの設定は完了です。</simpara>
<formalpara>
<title>BlockRFC1918#barrier_reply (lib/block_rfc1918.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def barrier_reply(dpid, _message) <co xml:id="CO27-1"/>
  return if dpid != @dpid
  logger.info "#{@dpid.to_hex}: loading finished"
end

private

def start_loading
  PREFIX.each do |each|
    block_prefix_on_port prefix: each, in_port: :outside, priority: 4000
    block_prefix_on_port prefix: each, in_port: :inside, priority: 5000
  end
  install_postamble 1500
  send_message @dpid, Barrier::Request.new <co xml:id="CO27-2"/>
end</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO27-2">
<para>スイッチに <literal>Barrier::Request</literal> メッセージを送り、すべてのフローエントリが反映されるのを待つ</para>
</callout>
<callout arearefs="CO27-1">
<para><literal>Barrier::Reply</literal> が届けば、完了メッセージを <literal>logger.info</literal> で出す</para>
</callout>
</calloutlist>
</section>
<section xml:id="_passdelegatedコントローラ">
<title>PassDelegatedコントローラ</title>
<simpara>PassDelegatedコントローラは、外側から内側向きのパケットのうち、送信元 IP アドレスがグローバル IP アドレスのパケットのみを通します (<link linkend="pass_delegated">図 11-4</link>)。</simpara>
<figure xml:id="pass_delegated">
<title>PassDelegatedファイアウォールは外→内側向きのグローバルアドレスからのパケットを通す</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/transparent_firewall/pass_delegated.png"/>
</imageobject>
<textobject><phrase>pass delegated</phrase></textobject>
</mediaobject>
</figure>
<simpara>フローエントリに用いるグローバル IP アドレスには、<literal>trema/transparent_firewall</literal> リポジトリ内のグローバル IP アドレス空間の一覧リスト (<literal>*.txt</literal> ファイル) を使います。このテキストファイルは、グローバルアドレスの割り当てなどを行う地域インターネットレジストリが提供するリストから自動生成したものです。たとえば、アジアと太平洋地域を担当する Asia-Pacific Network Information Centre (APNIC) のファイルは次のような 3000 以上の IP アドレス空間からなります。</simpara>
<formalpara>
<title>aggregated-delegated-apinic.txt</title>
<para>
<screen>1.0.0.0/8
14.0.0.0/16
14.1.0.0/20
14.1.16.0/21
14.1.32.0/19
14.1.64.0/19
14.1.128.0/17
14.2.0.0/15
14.4.0.0/14
14.8.0.0/13
...</screen>
</para>
</formalpara>
<section xml:id="_実行してみよう_7">
<title>実行してみよう</title>
<simpara>PassDelegated コントローラを<link linkend="firewall_configuration">図 11-3</link>と同じ <literal>trema.conf</literal> で起動してみましょう。<literal>trema run</literal> で実行すると、次のようにすべての *.txt ファイルを読みこみ IP アドレス空間ごとにフローエントリを作ります。グローバル IP アドレス空間は全部で2万以上あるので、すべてのフローエントリの作成には数分かかります。</simpara>
<screen>$ ./bin/trema run ./lib/pass_delegated.rb -c pass_delegated.conf
aggregated-delegated-afrinic.txt: 713 prefixes
aggregated-delegated-apnic.txt: 3440 prefixes
aggregated-delegated-arin.txt: 11342 prefixes
aggregated-delegated-lacnic.txt: 1937 prefixes
aggregated-delegated-ripencc.txt: 7329 prefixes
0xabc: connected
0xabc: loading started
0xabc: loading finished in 241.03 seconds</screen>
<simpara>コントローラが起動したら、別ターミナルを開き <literal>trema send_packets</literal> コマンドでoutsideとinsideホストの間でテストパケットを送ってみます。</simpara>
<screen>$ ./bin/trema send_packets --source outside --dest inside
$ ./bin/trema send_packets --source inside --dest outside</screen>
<simpara>PassDelegated コントローラはグローバルアドレス以外の外側から内側へのパケットを遮断します。ホストoutsideはプライベートアドレスを持つので、PassDelegatedコントローラはパケットを落とします。ホストinsideもプライベートアドレスを持ちますが、insideからoutsideへのパケットは通します。<literal>trema show_stats</literal> コマンドで outside、inside、そして inspector の受信パケット数をチェックしてみましょう。</simpara>
<screen>$ ./bin/trema show_stats outside
Packets sent:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
$ ./bin/trema show_stats inside
Packets sent:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet
Packets received:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
$ ./bin/trema show_stats inspector
Packets received:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet</screen>
<simpara>たしかに、outside から inside へのパケットは遮断し、逆向きの inside から outside へのパケットは通しています。そして、outside からの遮断されたパケットは inspector に届いています。</simpara>
</section>
</section>
<section xml:id="_passdelegatedのソースコード">
<title>PassDelegatedのソースコード</title>
<simpara>PassDelegated のソースコードは BlockRFC1918 と似た構造ですが、使うフローエントリの種類が増えています。次の 4 種類のフローエントリを使います。</simpara>
<variablelist>
<varlistentry>
<term>フィルタ用 (優先度: 64000)</term>
<listitem>
<simpara>外側ネットワークのグローバル IP アドレスからのパケットを内側ホストに転送するフローエントリです。3 万以上のエントリがあるため、セットアップは数分かかります。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>バイパス用 (優先度: 65000)</term>
<listitem>
<simpara>フィルタ用フローエントリをセットアップしている間の数分間だけ有効なエントリです。外側⇔内側のすべてのパケットを通します。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ドロップ用 (優先度: 1000)</term>
<listitem>
<simpara>外側ネットワークのグローバル IP アドレス以外からのパケットを inspector ホストに転送するフローエントリです。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IPv4以外用 (優先度: 900)</term>
<listitem>
<simpara>外側ネットワークからの IPv4 以外のパケットを内側ネットワークへ転送するフローエントリです。</simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>lib/pass_delegated.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># A sample transparent firewall
class PassDelegated &lt; Trema::Controller
  PORT = {
    outside: 1,
    inside: 2,
    inspect: 3
  }

  PRIORITY = {
    bypass: 65_000,
    prefix: 64_000,
    inspect: 1000,
    non_ipv4: 900
  }

  PREFIX_FILES = %w(afrinic apnic arin lacnic ripencc).map do |each|
    "aggregated-delegated-#{each}.txt"
  end

  def start(_args)
    @prefixes = PREFIX_FILES.reduce([]) do |result, each|
      data = IO.readlines(File.join __dir__, '..', each)
      logger.info "#{each}: #{data.size} prefixes"
      result + data
    end
  end

  def switch_ready(dpid)
    if @dpid
      logger.info "#{dpid.to_hex}: ignored"
      return
    end
    @dpid = dpid
    logger.info "#{@dpid.to_hex}: connected"
    start_loading
  end

  def switch_disconnected(dpid)
    return if @dpid != dpid
    logger.info "#{@dpid.to_hex}: disconnected"
    @dpid = nil
  end

  def barrier_reply(dpid, _message)
    return if dpid != @dpid
    finish_loading
  end

  private

  def start_loading
    @loading_started = Time.now
    install_preamble_and_bypass
    install_prefixes
    install_postamble
    send_message @dpid, Barrier::Request.new
  end

  # All flows in place, safe to remove bypass.
  def finish_loading
    send_flow_mod_delete(@dpid,
                         strict: true,
                         priority: PRIORITY[:bypass],
                         match: Match.new(in_port: PORT[:outside]))
    logger.info(format('%s: loading finished in %.2f second(s)',
                       @dpid.to_hex, Time.now - @loading_started))
  end

  def install_preamble_and_bypass
    send_flow_mod_add(@dpid,
                      priority: PRIORITY[:bypass],
                      match: Match.new(in_port: PORT[:inside]),
                      actions: SendOutPort.new(PORT[:outside]))
    send_flow_mod_add(@dpid,
                      priority: PRIORITY[:bypass],
                      match: Match.new(in_port: PORT[:outside]),
                      actions: SendOutPort.new(PORT[:inside]))
  end

  def install_prefixes
    logger.info "#{@dpid.to_hex}: loading started"
    @prefixes.each do |each|
      send_flow_mod_add(@dpid,
                        priority: PRIORITY[:prefix],
                        match: Match.new(in_port: PORT[:outside],
                                         ether_type: 0x0800,
                                         source_ip_address: IPv4Address.new(each)),
                        actions: SendOutPort.new(PORT[:inside]))
    end
  end

  # Deny any other IPv4 and permit non-IPv4 traffic.
  def install_postamble
    send_flow_mod_add(@dpid,
                      priority: PRIORITY[:inspect],
                      match: Match.new(in_port: PORT[:outside], ether_type: 0x0800),
                      actions: SendOutPort.new(PORT[:inspect]))
    send_flow_mod_add(@dpid,
                      priority: PRIORITY[:non_ipv4],
                      match: Match.new(in_port: PORT[:outside]),
                      actions: SendOutPort.new(PORT[:inside]))
  end
end</programlisting>
</para>
</formalpara>
<simpara>BlockRFC1918 と同じく、各種フローエントリの設定は <literal>start_loading</literal> メソッドから始まります。</simpara>
<formalpara>
<title>PassDelegated#start_loading (lib/pass_delegated.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def start_loading
  @loading_started = Time.now
  install_preamble_and_bypass
  install_prefixes
  install_postamble
  send_message @dpid, Barrier::Request.new
end</programlisting>
</para>
</formalpara>
<simpara>最初に呼び出す <literal>install_preamble_and_bypass</literal> メソッドは、外側⇔内側のすべてのパケットを通すバイパス用フローエントリを追加します。優先度を他のフローエントリよりも大きくしておくことで、フィルタリング用フローエントリを設定している数分間はすべてのパケットがこのフローエントリにマッチします。このため、フローエントリのセットアップ中でも普通に通信できるようになります。</simpara>
<formalpara>
<title>PassDelegated#install_preamble_and_bypass (lib/pass_delegated.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def install_preamble_and_bypass
  send_flow_mod_add(@dpid, <co xml:id="CO28-1"/>
                    priority: PRIORITY[:bypass],
                    match: Match.new(in_port: PORT[:inside]),
                    actions: SendOutPort.new(PORT[:outside]))
  send_flow_mod_add(@dpid, <co xml:id="CO28-2"/>
                    priority: PRIORITY[:bypass],
                    match: Match.new(in_port: PORT[:outside]),
                    actions: SendOutPort.new(PORT[:inside]))
end</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO28-1">
<para>内側→外側のパケットをすべて通すフローエントリを設定</para>
</callout>
<callout arearefs="CO28-2">
<para>外側→内側のパケットをすべて通すフローエントリを設定</para>
</callout>
</calloutlist>
<simpara>バイパス用フローエントリの後、大量のフィルタ用フローエントリを設定します。PassDelegated がフィルタするのは外側→内側ネットワークだけなので、それぞれのグローバル IP アドレス空間について 1 つずつのフローエントリを作ります。</simpara>
<formalpara>
<title>PassDelegated#install_prefixes (lib/pass_delegated.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def install_prefixes
  logger.info "#{@dpid.to_hex}: loading started"
  @prefixes.each do |each|
    send_flow_mod_add(@dpid,
                      priority: PRIORITY[:prefix],
                      match: Match.new(in_port: PORT[:outside],
                                       ether_type: 0x0800,
                                       source_ip_address: IPv4Address.new(each)),
                      actions: SendOutPort.new(PORT[:inside]))
  end
end</programlisting>
</para>
</formalpara>
<simpara>続く <literal>install_postamble</literal> メソッドでは、ドロップ用と IPv4 以外用の 2 種類のフローエントリを設定します。ドロップ用フローエントリは、外側ネットワークのグローバル IP アドレス以外からのパケットを inspector ホストに転送します。IPv4 以外用フローエントリは、外側ネットワークからの IPv4 以外のパケットをすべて内側ネットワークへ転送します。</simpara>
<formalpara>
<title>PassDelegated#install_postamble (lib/pass_delegated.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># Deny any other IPv4 and permit non-IPv4 traffic.
def install_postamble
  send_flow_mod_add(@dpid, <co xml:id="CO29-1"/>
                    priority: PRIORITY[:inspect],
                    match: Match.new(in_port: PORT[:outside], ether_type: 0x0800),
                    actions: SendOutPort.new(PORT[:inspect]))
  send_flow_mod_add(@dpid, <co xml:id="CO29-2"/>
                    priority: PRIORITY[:non_ipv4],
                    match: Match.new(in_port: PORT[:outside]),
                    actions: SendOutPort.new(PORT[:inside]))
end</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO29-1">
<para>ドロップ用フローエントリの設定</para>
</callout>
<callout arearefs="CO29-2">
<para>IPv4 以外用フローエントリの設定</para>
</callout>
</calloutlist>
<simpara>最後に、すべてのフローエントリが実際にスイッチへ反映されるのをバリアで待った後、外側→内側へのバイパス用フローエントリを削除します。これによって、外側→内側へのグローバルアドレスを持たないホストからのパケットだけをフィルタリング用エントリで遮断できます。</simpara>
<formalpara>
<title>PassDelegated#install_postamble (lib/pass_delegated.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def barrier_reply(dpid, _message)
  return if dpid != @dpid
  finish_loading
end

private

# All flows in place, safe to remove bypass.
def finish_loading
  send_flow_mod_delete(@dpid,
                       strict: true,
                       priority: PRIORITY[:bypass],
                       match: Match.new(in_port: PORT[:outside]))
  logger.info(format('%s: loading finished in %.2f second(s)',
                     @dpid.to_hex, Time.now - @loading_started))
end</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_まとめ_11">
<title>まとめ</title>
<simpara>ネットワーク機器のOpenFlow実装の一環として、2種類の透過型ファイアウォールを作りました。</simpara>
<itemizedlist>
<listitem>
<simpara>透過型ファイアウォールはルータとホストの間にはさむだけで使え、各ホストのネットワーク設定を変更しなくてよい</simpara>
</listitem>
<listitem>
<simpara>Flow Mod がスイッチに反映されたことを保証するには <literal>Barrier::Request</literal> メッセージを使う</simpara>
</listitem>
</itemizedlist>
<simpara>続く章では、インターネットを構成する重要なネットワーク機器であるルータをOpenFlowで作ります。今までに学んできたOpenFlowやRubyプログラミングの知識を総動員しましょう。</simpara>
</section>
</chapter>
<chapter xml:id="router_part1">
<title>ルータ (前編)</title>
<simpara role="lead">今まで学んだ知識を総動員して、ラーニングスイッチよりも高度なルータの実装に挑戦しましょう。まずは、スイッチとルータの違いをきちんと理解することからスタートです。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/map.png"/>
</imageobject>
<textobject><phrase>map</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_ルータとスイッチの違い">
<title>ルータとスイッチの違い</title>
<simpara>ルータとスイッチの一番大きな違いは、パケット転送に使う情報にあります。スイッチはパケットの転送に MAC アドレスを使う一方で、ルータは IP アドレスを使うのです。なぜ、ルータは IP アドレスを使うのでしょうか。MAC アドレスだけでパケットが届くなら、わざわざ IP アドレスを使う必要はありません。実はこれらの違いには、技術的な理由があるのです。</simpara>
<simpara>MAC アドレスでパケットを転送する LAN をイーサネットと呼びます。ネットワークを実装のレベルで分類すると、イーサネットはハードウェアに近いレベルのネットワークです。なぜかと言うと、イーサネットがパケットの転送に使う MAC アドレスは、ハードウェアであるネットワークカードを識別する情報だからです。この MAC アドレスは、パケットのイーサネットヘッダと呼ばれる部分に入っています。</simpara>
<simpara>実は、ハードウェアに近いパケット転送方式はイーサネット以外にもいくつもあります。イーサネットは、転送方式のうちのたった 1 つにすぎないのです。</simpara>
<itemizedlist>
<listitem>
<simpara>ADSL や光ファイバーによるインターネット接続に使う PPP (Point to Point Protocol)。身近に使われている</simpara>
</listitem>
<listitem>
<simpara>WAN で使われる ATM (Asynchronous Transfer Mode) やフレームリレー。利用は徐々に減りつつある</simpara>
</listitem>
<listitem>
<simpara>リング型のネットワークを構成する FDDI (Fiber-Distributed Data Interface)。昔は、大学などの計算機室のワークステーションをつなげるためによく使われていた</simpara>
</listitem>
</itemizedlist>
<simpara>これらの異なるネットワーク同士をつなぐのが IP (インターネットプロトコル) です。インターネットはその名のとおり、ネットとネットの間 (inter) をつなぐ技術で、イーサネットやその他のネットワークの一段上に属します。ルータはインターネットプロトコルでの識別情報である IP アドレスを使って、より低いレベルのネットワーク同士をつなぐのです。</simpara>
</section>
<section xml:id="_イーサネットだけならルータは不要">
<title>イーサネットだけならルータは不要？</title>
<simpara>ここで1つの疑問が出てきます。いろいろある転送方式のうち、もしもイーサネットだけを使うのであれば、ルータによる中継は不要なのでしょうか。</simpara>
<simpara>いいえ、ルータは必要です。もしもルータを使わずに大きなネットワークを作ろうとすると、次の問題が起こります。</simpara>
<variablelist>
<varlistentry>
<term>ブロードキャストの問題</term>
<listitem>
<simpara>ネットワーク上の情報の発見などのためにブロードキャストパケットを送ると、ネットワーク上のすべてのホストにこのパケットがばらまかれる。もし大きいネットワーク内でみんながブロードキャストを送ってしまうと、ネットワークがパンクしてしまう</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>セキュリティの問題</term>
<listitem>
<simpara>もし全体が 1 つのネットワークでどことでも自由に通信できてしまうと、他人の家や他社のホストと簡単に接続できてしまう。こうなると、プライバシー情報や機密データを守るのが大変になる</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>そこで、現実的にはイーサネットだけでネットワークを作る場合にも、家や会社の部署といった単位で小さなネットワークを作り、それらをルータでつなぐ場合が大半です。ルータがネットワーク間の門番としても働き、実際にパケットを転送するかしないかを制御することで、上の 2 つの問題を解決します。</simpara>
</section>
<section xml:id="_ルータの動作">
<title>ルータの動作</title>
<simpara>ルータの存在意義がわかったところで、一般的なイーサネットでのルータの動作を詳しく見ていきましょう。おおまかに言うと、ルータは複数のイーサネットをつなぐために、1) イーサネット間でのパケットの転送と、2) 正しく届けるのに必要なパケットの書き換え、の 2 つの仕事を行います。</simpara>
<section xml:id="_パケットを書き換えて転送する">
<title>パケットを書き換えて転送する</title>
<simpara><link linkend="router_forward_rewrite">図 12-1</link> のホスト A がホスト B にパケットを送る場合を考えます。ホスト A は、送信元 IP アドレスがホスト A、宛先 IP アドレスがホスト B の IP パケットを作ります。</simpara>
<simpara>このパケットをホスト B に届けるためには、ルータに中継してもらわなくてはなりません。ルータにパケットを渡すために、ホスト A は、パケット中の宛先 MAC アドレスをルータの MAC アドレスに、また送信元をホスト A の MAC アドレスにして、出力します。このときのパケットの中身は、次のようになります。</simpara>
<figure xml:id="router_forward_rewrite">
<title>ルータはパケットを転送するために、パケットのイーサネット部分だけを書き換える</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/router_forward_rewrite.png"/>
</imageobject>
<textobject><phrase>router forward rewrite</phrase></textobject>
</mediaobject>
</figure>
<simpara>ルータは、受け取ったパケットをホスト B に届けるために、MAC アドレスの書き換えを行います。ルータは、パケットの宛先をホスト B の MAC アドレスに、送信元をルータの MAC アドレスに書き換えてから、書き換えたパケットをホスト B へと転送します。</simpara>
<simpara>このパケットの書き換えと転送のために必要な処理を、1 つひとつ見ていきましょう。</simpara>
<section xml:id="_ルータの_mac_アドレスを教える">
<title>ルータの MAC アドレスを教える</title>
<simpara>ルータがパケットを受け取るためには、ホストはルータの MAC アドレスを知る必要があります。IPアドレスから宛先のMACアドレスの情報を知るためにはARP(Address Resolution Protocol)というプロトコルを使います。ARPにはARPリクエストとARPリプライという2種類のパケットがあります。ホスト A は、パケットを送る前にルータの MAC アドレスを ARP リクエストで調べ、これを宛先 MAC アドレスとしてパケットに指定します。ルータは ARP リクエストを受け取ると、自身の MAC アドレスを ARP リプライとして返します (<link linkend="router_arp_reply">図 12-2</link>)。</simpara>
<figure xml:id="router_arp_reply">
<title>ルータは ARP リクエストに対し自分の MAC アドレスを応える</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/router_arp_reply.png"/>
</imageobject>
<textobject><phrase>router arp reply</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_宛先ホストの_mac_アドレスを調べる">
<title>宛先ホストの MAC アドレスを調べる</title>
<simpara>ルータがパケットを宛先ホストに送るためには、宛先ホストの MAC アドレスを調べる必要があります。そこでルータは、宛先であるホスト B の MAC アドレスを調べるための ARP リクエストをホスト B へ送ります。このとき、ルータは、ホスト B の MAC アドレスを知らないので、ARP リクエストの宛先 MAC アドレスにブロードキャストアドレス (FF:FF:FF:FF:FF:FF) を指定します。</simpara>
<figure xml:id="router_arp_reequest">
<title>宛先ホストの MAC アドレスを問い合わせる</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/router_arp_request.png"/>
</imageobject>
<textobject><phrase>router arp request</phrase></textobject>
</mediaobject>
</figure>
<simpara>ARP を使って調べた MAC アドレスは、再利用するためにルータ内の ARP テーブルにキャッシュしておきます。これによって、同じホストに対してパケットを繰り返し送る場合、何度も ARP リクエストを送らなくてもすみます。</simpara>
</section>
</section>
<section xml:id="_いくつものルータを経由して転送する">
<title>いくつものルータを経由して転送する</title>
<simpara>ルータが複数あるネットワークでの転送は、少し複雑になります (<link linkend="router_network">図 12-4</link>)。たとえば、ホスト A がホスト B にパケットを送るとします。ルータ A は受け取ったパケットを転送する必要がありますが、宛先であるホスト B はルータ A とは直接はつながっていません。そのため、ルータ A はまずルータ B にパケットを転送し、ルータ B がそのパケットをホスト B へと転送します。</simpara>
<figure xml:id="router_network">
<title>ルータが複数あるネットワークでの転送</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/router_network.png"/>
</imageobject>
<textobject><phrase>router network</phrase></textobject>
</mediaobject>
</figure>
<simpara>ルータ A の次の転送先となるルータは、パケットの宛先ごとに異なります。たとえばホスト A からホスト C へパケットを送る場合には、ルータ A はそのパケットをルータ C へと転送します。</simpara>
<simpara>次の転送先へと正しくパケットを送るために、各ルータは、宛先と次の転送先の対応を記録したルーティングテーブルを持っています。たとえば、ルータ A のルーティングテーブルは、<link linkend="router_network">図 12-4</link> に示すようになります。</simpara>
<simpara>ここまでで、ルータの基本動作の説明はおしまいです。それでは、基本的なルータの機能を実装した、シンプルルータのソースコードを読んでいきましょう。</simpara>
</section>
</section>
<section xml:id="_ソースコード解説_5">
<title>ソースコード解説</title>
<simpara>シンプルルータ (<literal>SimpleRouter</literal>) のソースコードは、いくつのファイルからなります。紙面の都合上、以下ではメインのソースコード (<literal>lib/simple_router.rb</literal>) を中心に説明します。ソースコードは GitHub の <literal>trema/simple_router</literal> リポジトリ (<link xl:href="https://github.com/trema/simple_router">https://github.com/trema/simple_router</link>) からダウンロードできます。</simpara>
<screen>$ git clone https://github.com/trema/simple_router.git
$ cd simple_router
$ bundle install --binstubs</screen>
<section xml:id="_packet_in_ハンドラ_2">
<title>Packet In ハンドラ</title>
<simpara>シンプルルータの主な動作は Packet In ハンドラから始まります。ハンドラ <literal>packet_in</literal> の中身は、次のようになっています。</simpara>
<formalpara>
<title>SimpleRouter#packet_in (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in(dpid, packet_in)
  return unless sent_to_router?(packet_in)

  case packet_in.data
  when Arp::Request
    packet_in_arp_request dpid, packet_in.in_port, packet_in.data
  when Arp::Reply
    packet_in_arp_reply dpid, packet_in
  when Parser::IPv4Packet
    packet_in_ipv4 dpid, packet_in
  else
    logger.debug "Dropping unsupported packet type: #{packet_in.data.inspect}"
  end
end</programlisting>
</para>
</formalpara>
<section xml:id="_自分宛のパケットかを判定する">
<title>自分宛のパケットかを判定する</title>
<simpara>イーサネットにはルータ以外のホストがつながっている可能性があります。そこで Packet In メッセージが上がってきたときには、まずそのパケットが自分宛かどうかを判断します (<literal>sent_to_router?</literal> メソッド)。もし自分宛でない場合にはパケットを破棄します。</simpara>
<formalpara>
<title>SimpleRouter#sent_to_router? (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def sent_to_router?(packet_in)
  return true if packet_in.destination_mac.broadcast?
  interface = Interface.find_by(port_number: packet_in.in_port)
  interface &amp;&amp; interface.mac_address == packet_in.destination_mac
end</programlisting>
</para>
</formalpara>
<simpara>この <literal>sent_to_router?</literal> メソッドはパケットの宛先 MAC アドレス (<literal>packet_in.destination_mac</literal>) をチェックします。宛先 MAC アドレスがブロードキャストである場合、もしくは受信ポート (<literal>packet_in.in_port</literal>) に割り当てられている MAC アドレス (<literal>interface.mac_address</literal>) と同じである場合、自分宛と判断します。</simpara>
</section>
<section xml:id="_パケットの種類によって処理を切り替え">
<title>パケットの種類によって処理を切り替え</title>
<simpara>自分宛のパケットだとわかると、次にパケットの種類を判別します。シンプルルータが処理するパケットは、ARP のリクエストとリプライ、および IPv4 パケットの 3 種類です。<literal>PacketIn#data</literal> メソッドはパケットの種類に応じたオブジェクトを返すので、この返り値に応じてハンドラメソッドを呼び出します。</simpara>
</section>
<section xml:id="_arp_リクエストのハンドル">
<title>ARP リクエストのハンドル</title>
<simpara>ARP リクエストパケットを受信すると <literal>packet_in_arp_request</literal> メソッドを呼びます。ここでは、ARP リプライメッセージを作って Packet Out で ARP リクエストが届いたポートに出力します。</simpara>
<formalpara>
<title>SimpleRouter#packet_in_arp_request (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in_arp_request(dpid, in_port, arp_request)
  interface =
    Interface.find_by(port_number: in_port,
                      ip_address: arp_request.target_protocol_address)
  return unless interface
  send_packet_out(
    dpid,
    raw_data: Arp::Reply.new(
      destination_mac: arp_request.source_mac,
      source_mac: interface.mac_address,
      sender_protocol_address: arp_request.target_protocol_address,
      target_protocol_address: arp_request.sender_protocol_address
    ).to_binary,
    actions: SendOutPort.new(in_port))
end</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_arp_リプライのハンドル">
<title>ARP リプライのハンドル</title>
<simpara>ARP リプライパケットを受信すると、ARP テーブル (<literal>@arp_table</literal>) に MAC アドレスを記録します。ここでは <literal>PacketIn#sender_protocol</literal> メソッドを使って ARP パケット中の送信元 IP アドレスを取り出しています。</simpara>
<formalpara>
<title>SimpleRouter#packet_in_arp_reply (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in_arp_reply(dpid, packet_in)
  @arp_table.update(packet_in.in_port,
                    packet_in.sender_protocol_address,
                    packet_in.source_mac)
  flush_unsent_packets(dpid,
                       packet_in.data,
                       Interface.find_by(port_number: packet_in.in_port))
end</programlisting>
</para>
</formalpara>
<simpara>そして、<literal>flush_unsent_packets</literal> メソッドで宛先 MAC アドレスが解決していないパケットを送ります。この処理については後述します。</simpara>
</section>
<section xml:id="_ipv4_パケットのハンドル">
<title>IPv4 パケットのハンドル</title>
<simpara>IPv4 パケットを受信すると、<literal>packet_in_ipv4</literal> メソッドを呼びます。ルータに届く IPv4 パケットには次の 3 種類があり、それぞれで処理が異なります。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>パケットの転送が必要な場合</simpara>
</listitem>
<listitem>
<simpara>宛先 IP アドレスが自分宛だった場合</simpara>
</listitem>
<listitem>
<simpara>それ以外だった場合 (パケットを破棄)</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>SimpleRouter#packet_in_ipv4 (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in_ipv4(dpid, packet_in)
  if forward?(packet_in)
    forward(dpid, packet_in)
  elsif packet_in.ip_protocol == 1
    icmp = Icmp.read(packet_in.raw_data)
    packet_in_icmpv4_echo_request(dpid, packet_in) if icmp.icmp_type == 8
  else
    logger.debug "Dropping unsupported IPv4 packet: #{packet_in.data}"
  end
end</programlisting>
</para>
</formalpara>
<simpara>パケットを転送するかどうかの判定は <literal>forward?</literal> メソッドです。転送が必要な場合とは、次のようにパケットの宛先 IPv4 アドレスがルータのインタフェースに割り当てた IPv4 アドレスと異なる場合です。</simpara>
<formalpara>
<title>SimpleRouter#forward? (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def forward?(packet_in)
  !Interface.find_by(ip_address: packet_in.destination_ip_address)
end</programlisting>
</para>
</formalpara>
<simpara>パケットの宛先 IP アドレスがルータである場合、ルータ自身が応答します。シンプルルータでは、ICMP Echo リクエスト (ping) に応答する機能だけ実装しています。<literal>packet_in_icmpv4_echo_request</literal> メソッドは次のように ICMP Echo リクエストに応答します。</simpara>
<formalpara>
<title>SimpleRouter#packet_in_icmpv4_echo_request (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in_icmpv4_echo_request(dpid, packet_in)
  icmp_request = Icmp.read(packet_in.raw_data)
  if @arp_table.lookup(packet_in.source_ip_address)
    send_packet_out(dpid,
                    raw_data: create_icmp_reply(icmp_request).to_binary,
                    actions: SendOutPort.new(packet_in.in_port))
  else
    send_later(dpid,
               interface: Interface.find_by(port_number: packet_in.in_port),
               destination_ip: packet_in.source_ip_address,
               data: create_icmp_reply(icmp_request))
  end
end</programlisting>
</para>
</formalpara>
<simpara>まず送信元 IP アドレス (<literal>packet_in.source_ip_address</literal>) に対応する MAC アドレスを ARP テーブルから調べます。MAC アドレスをキャッシュしている場合には、<literal>create_icmp_reply</literal> で応答メッセージを作り、Packet Out で出力します。MAC アドレスをキャッシュしていない場合には、<literal>send_later</literal> メソッドで ARP が解決したときに後で転送します。これについても詳細は後述します。</simpara>
</section>
</section>
<section xml:id="_パケットを書き換えて転送する_2">
<title>パケットを書き換えて転送する</title>
<simpara>ルータの動作の核心、パケットを書き換えて転送する部分です。</simpara>
<formalpara>
<title>SimpleRouter#forward (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def forward(dpid, packet_in)
  next_hop = resolve_next_hop(packet_in.destination_ip_address)

  interface = Interface.find_by_prefix(next_hop)
  return if !interface || (interface.port_number == packet_in.in_port)

  arp_entry = @arp_table.lookup(next_hop)
  if arp_entry
    actions = [SetSourceMacAddress.new(interface.mac_address),
               SetDestinationMacAddress.new(arp_entry.mac_address),
               SendOutPort.new(interface.port_number)]
    send_flow_mod_add(dpid,
                      match: ExactMatch.new(packet_in), actions: actions)
    send_packet_out(dpid, raw_data: packet_in.raw_data, actions: actions)
  else
    send_later(dpid,
               interface: interface,
               destination_ip: next_hop,
               data: packet_in.data)
  end
end</programlisting>
</para>
</formalpara>
<simpara>この <literal>forward</literal> メソッドは、次の 5 つの処理を行います。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>ルーティングテーブルを参照し、次の転送先を決める (<literal>resolve_next_hop</literal>)</simpara>
</listitem>
<listitem>
<simpara>次の転送先に送るための、出力インタフェースを決める (<literal>Interface.find_by_prefix</literal>)</simpara>
</listitem>
<listitem>
<simpara>インタフェースが見つかった場合、ARP アドレスから宛先 MAC アドレスを探す (<literal>@arp_table.lookup</literal>)</simpara>
</listitem>
<listitem>
<simpara>MAC アドレスが見つかった場合、転送用のフローエンントリを書き込み、受信パケットを Packet Out する</simpara>
</listitem>
<listitem>
<simpara>MAC アドレスが見つからなかった場合、<literal>send_later</literal> メソッドで後で転送する</simpara>
</listitem>
</orderedlist>
<simpara>このうち重要なのは 1 と 4 の処理です。1 で次の転送先を決める <literal>resolve_next_hop</literal> メソッドの詳細については次章で見ていきます。ここでは 4 の処理を詳しく見ていきましょう。</simpara>
<section xml:id="_パケットの書き換えと転送_flow_mod_と_packet_out">
<title>パケットの書き換えと転送 (Flow Mod と Packet Out)</title>
<simpara>ARP テーブルから宛先の MAC アドレスがわかると、パケットを書き換えて宛先へ出力するとともに、同様のパケットをスイッチ側で転送するためのフローエントリを書き込みます。<link linkend="forward">図 12-1</link> で説明したように、ルータによるパケットの転送では MAC アドレスを書き換えます。<literal>forward</literal> メソッド内の変数 <literal>actions</literal> はこのためのアクションリストで、送信元と宛先 MAC アドレスの書き換え、そして該当するポートからの出力というアクションの配列です。このアクションは Flow Mod と Packet Out メッセージの送信に使います。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">actions = [SetSourceMacAddress.new(interface.mac_address),
           SetDestinationMacAddress.new(arp_entry.mac_address),
           SendOutPort.new(interface.port_number)]
send_flow_mod_add(dpid,
                  match: ExactMatch.new(packet_in), actions: actions)
send_packet_out(dpid, raw_data: packet_in.raw_data, actions: actions)</programlisting>
</section>
</section>
<section xml:id="_arp_の解決後にパケットを転送する">
<title>ARP の解決後にパケットを転送する</title>
<simpara>ARP が未解決のパケットは転送できないため、解決するまで待つ必要があります。この「ARP 解決後に送る」という処理を行うのが、<literal>send_later</literal> メソッドです。たとえば ICMP Echo リプライの宛先 MAC アドレスが ARP テーブルからすぐわからない場合、次のように <literal>send_later</literal> メソッドを呼び出していました。</simpara>
<formalpara>
<title>SimpleRouter#packet_in_icmpv4_echo_request (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in_icmpv4_echo_request(dpid, packet_in)
  icmp_request = Icmp.read(packet_in.raw_data)
  if @arp_table.lookup(packet_in.source_ip_address)
    send_packet_out(dpid,
                    raw_data: create_icmp_reply(icmp_request).to_binary,
                    actions: SendOutPort.new(packet_in.in_port))
  else
    send_later(dpid,
               interface: Interface.find_by(port_number: packet_in.in_port),
               destination_ip: packet_in.source_ip_address,
               data: create_icmp_reply(icmp_request))
  end
end</programlisting>
</para>
</formalpara>
<simpara><literal>send_later</literal> メソッドは <literal>data:</literal> で渡したパケットデータを ARP 解決後に自動的に転送します。転送に使うルータのインタフェースは <literal>interface:</literal> オプション、また送信先 IP アドレスは <literal>destination_ip:</literal> オプションでそれぞれ指定します。</simpara>
<simpara><literal>send_later</literal> メソッドでは、ARP が未解決なパケットを宛先 IP アドレスごとにキュー (<literal>queue</literal>) に入れます。キューへの追加後に ARP リクエストを送ることで宛先の MAC アドレスを解決します。</simpara>
<formalpara>
<title>SimpleRouter#send_later (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def send_later(dpid, options)
  destination_ip = options.fetch(:destination_ip)
  @unresolved_packet_queue[destination_ip] += [options.fetch(:data)]
  send_arp_request(dpid, destination_ip, options.fetch(:interface))
end</programlisting>
</para>
</formalpara>
<simpara>キューにためたパケットを転送するのは ARP リプライが Packet In したタイミングです。<literal>packet_in_arp_reply</literal> の最後に呼び出している <literal>flush_unsent_packets</literal> がこの処理を行います。</simpara>
<formalpara>
<title>SimpleRouter#flush_unsent_packets (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def flush_unsent_packets(dpid, arp_reply, interface)
  destination_ip = arp_reply.sender_protocol_address
  @unresolved_packet_queue[destination_ip].each do |each|
    rewrite_mac =
      [SetDestinationMacAddress.new(arp_reply.sender_hardware_address),
       SetSourceMacAddress.new(interface.mac_address),
       SendOutPort.new(interface.port_number)]
    send_packet_out(dpid, raw_data: each.to_binary_s, actions: rewrite_mac)
  end
  @unresolved_packet_queue[destination_ip] = []
end</programlisting>
</para>
</formalpara>
<simpara>ここでは MAC アドレスが解決したパケットそれぞれに対して、送信元と宛先 MAC アドレスを書き換えるアクションを指定し Packet Out しています。</simpara>
</section>
</section>
<section xml:id="_まとめ_12">
<title>まとめ</title>
<simpara>従来のネットワーク機器をソフトウェアで実装したシンプルなルータの仕組みを学びました。</simpara>
<itemizedlist>
<listitem>
<simpara>ルータはイーサネットよりも一段上の IP レベルでパケットを転送する。異なるイーサネット間でパケットを中継するために、ルータはパケットの MAC アドレスを書き換える</simpara>
</listitem>
<listitem>
<simpara>宛先ホストの MAC アドレスを調べるために、ルータは ARP エリクエストを送り結果を ARP テーブルにキャッシュする。また、ルータ経由でパケットを送るホストのために、ルータは ARP リクエストに応える必要がある</simpara>
</listitem>
<listitem>
<simpara>いくつものルータを経由してパケットを転送するために、ルータはルーティングテーブルを使って次の転送先を決める</simpara>
</listitem>
<listitem>
<simpara>Packet In したパケットの判別や ARP、そして ICMP 等の処理を行うためのヘルパメソッドを、Trema はたくさん提供している</simpara>
</listitem>
</itemizedlist>
<simpara>続く<link linkend="router_part2">13 章</link>では、ルータの動作にとって書かせないルーティングテーブルについて詳しく見たあと、いよいよこのルータを実行してみます。</simpara>
</section>
</chapter>
<chapter xml:id="router_part2">
<title>ルータ (後編)</title>
<simpara role="lead">ルータが持つ重要な機能であるルーティングテーブルの詳細を見ていきましょう。ルータは実に巧妙な仕組みで転送先の情報を管理します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/map.png"/>
</imageobject>
<textobject><phrase>map</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_宛先ホストをまとめる">
<title>宛先ホストをまとめる</title>
<simpara>ルータが管理するルーティングテーブルは、宛先ホストが増えるごとに大きくなります。前編の説明では、ルータは宛先ホスト1つごとにルーティングテーブルのエントリを管理していました。しかしこれでは、たとえばインターネットにホストが加わるごとに、インターネット上のルータはルーティングテーブルを更新する必要があります。しかも、インターネット上のホスト数は直線的に増え続け、2016年現在では10億台を超えています。そうなると、宛先ホストごとにエントリを管理する方法は非現実的です。</simpara>
<simpara>これを解決するために、ルータは同じイーサネット上にあるホストを1つのグループとしてまとめます。そして、ルーティングテーブルの宛先として、ホストではなくこのグループを指定することで、エントリ数を圧縮します。このとき、グループ情報として使うのがネットワークアドレスとネットマスク長です。</simpara>
<figure xml:id="router_network2">
<title>同じイーサネット上にあるホストを一つの宛先にまとめる</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/router_network2.png"/>
</imageobject>
<textobject><phrase>router network2</phrase></textobject>
</mediaobject>
</figure>
<simpara>宛先ホストのグループ化は次のように行います。たとえば、<link linkend="router_network2">図13-1</link>の右側のネットワークは、ネットワークアドレスが192.168.1.0でネットマスク長が24です(これを192.168.1.0/24と表現します)。このネットワーク中にあるホストX,Y,Zには、ネットワークアドレスと上位24ビットが同じとなるように、つまりIPアドレスが192.168.1で始まるようにします。こうすれば、ホストX,Y,Zは同じ1つのグループ192.168.1.0/24に属するとみなせます。</simpara>
<simpara>このようにアドレスを振ることで、ルータAのルーティングテーブルは、<link linkend="router_network2">図13-1</link>のようにシンプルに書けます。ホストX,Y,Z宛てのパケットを192.168.1.0/24グループ宛てと表現することで、エントリを1つにまとめられるのです。</simpara>
<simpara>このとき、ホストX(192.168.1.1)宛のパケットを受け取ったルータAは次のように動作します。ルーティングテーブルのエントリ192.168.1.0/24と、パケットの宛先192.168.1.1との上位24ビットを比較すると一致します。そこで、ルーティングテーブルから次の転送先はルータBだとわかります。ホストY,Z宛も同様に処理できるので、このエントリ1つでホスト3台分の宛先をカバーできます。</simpara>
<section xml:id="_宛先ホストがルータと直接つながっているかを調べる">
<title>宛先ホストがルータと直接つながっているかを調べる</title>
<simpara><link linkend="router_network2">図13-1</link> では、ルータが宛先ホストに直接接続していない場合について説明しましたが、つながっている/いないはどのように判断するのでしょうか？</simpara>
<simpara>ルータは、その判断のために、自身のインタフェースに割り当てられた IP アドレスを使います。インタフェースに割り当てる IP アドレスには、ネットワーク中のホストとネットワークアドレスが同じ IP アドレスを用います。<link linkend="router_address">図13-2</link> で、ルータ B のインタフェースには、ホスト X, Y, Z と同じネットワークアドレスになるよう、例えばアドレス 192.168.1.254 を割り当てます。</simpara>
<figure xml:id="router_address">
<title>ルータのインタフェースには、ネットワーク内のホストとネットワークアドレスが同じとなるように IP アドレスを割り当てる</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/router_address.png"/>
</imageobject>
<textobject><phrase>router address</phrase></textobject>
</mediaobject>
</figure>
<simpara>ここで <link linkend="router_address">図13-2</link> のルータ B が、ホスト X (192.168.1.1) 宛のパケットを受け取った場合について考えます。ルータ B は、パケットの宛先アドレスを参照し、ネットワークアドレスが同じインタフェースを探します。この例では、192.168.1.254 というアドレスがついたインタフェースが見つかります。あとは、このインタフェースを通じて、ARP リクエストによる MAC アドレス問い合わせを行い、ホスト X 宛にパケットを出力します。</simpara>
</section>
</section>
<section xml:id="_ネットワーク宛てのエントリをまとめる">
<title>ネットワーク宛てのエントリをまとめる</title>
<simpara>複数のホスト宛てエントリをまとめて出来たエントリは、さらにまとめられる場合もあります。</simpara>
<figure xml:id="aggregation">
<title>複数のネットワークへのルーティング情報をまとめる</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/aggregation.png"/>
</imageobject>
<textobject><phrase>aggregation</phrase></textobject>
</mediaobject>
</figure>
<simpara>例として、<link linkend="aggregation">図 13-3</link>の3つのネットワークに接続するルータBを考えてみましょう。これら3つのネットワークアドレスは、上位16ビットが172.16.0.0で共通です。ここでルータAから見ると、この3つのネットワークへの次の転送先は、いずれもルータBです。そのため、これら3つのネットワークへのルーティング情報は、172.16.0.0/16宛として1つにまとめられます。</simpara>
<section xml:id="_1つの宛先に複数のエントリがマッチする場合">
<title>1つの宛先に複数のエントリがマッチする場合</title>
<simpara>パケットの宛先 IP アドレスに複数のエントリが該当する場合はどうなるでしょうか？<link linkend="longest_match">図13-4</link> のルータ A がホスト X (172.16.3.1) にパケットを送る場合について考えてみましょう。ルータ A が持つルーティングテーブルは、ルータ B につながる 3 つのネットワーク宛のエントリはまとめることで、<link linkend="longest_match">図13-4</link>のように 2 つのエントリにできます。しかし、このようにまとめてしまうと、宛先 172.16.3.1 のパケットは、どちらのエントリにもマッチしてしまいます。ルータは、どちらか正しいエントリを選択しなければいけません。</simpara>
<figure xml:id="longest_match">
<title>マスク長が一番長いエントリを選択する</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/longest_match.png"/>
</imageobject>
<textobject><phrase>longest match</phrase></textobject>
</mediaobject>
</figure>
<simpara>複数のエントリにマッチする場合には、ネットマスク長が一番長いエントリを選択するというルールがあります。これをロンゲストマッチと呼びます。ロンゲストマッチにより、ルータAは、ホストX宛のパケットをルータCへと転送し、その結果ホストXへとパケットが届きます。</simpara>
</section>
<section xml:id="_すべての宛先にマッチするデフォルトルート">
<title>すべての宛先にマッチするデフォルトルート</title>
<simpara>すべての宛先をまとめたルーティング情報をデフォルトルートと呼び、その宛先を 0.0.0.0/0 と表します。ネットマスク長は、ルーティング情報をまとめるとき、ネットワークアドレスの共通部分の長さを表していました。デフォルトルートでは、まとめられた宛先には共通部分が全くないため、ネットマスク長は 0 となります。</simpara>
<figure xml:id="default_route">
<title>0.0.0.0/0 は、すべての宛先にマッチする</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/default_route.png"/>
</imageobject>
<textobject><phrase>default route</phrase></textobject>
</mediaobject>
</figure>
<simpara><link linkend="default_route">図13-5</link>のように、インターネットに接続するネットワークでのルーティングテーブルについて考えてみましょう。インターネット上のホスト数は膨大なので、宛先ホストをネットワーク単位にまとめたとしても、数十万エントリを扱う必要があります。しかし、<link linkend="default_route">図13-5</link>のようにインターネットへの出口が1か所だけの場合、エントリをデフォルトルート1つにまとめられます。これによって、ルーティングテーブル中のエントリ数を大きく減らせます。</simpara>
<simpara><link linkend="default_route">図13-5</link> のように、インターネットとは別にネットワーク (172.16.3.0/24) があっても、デフォルトルートを使うことに問題はありません。172.16.3.0/24 宛のパケットがルータ A に届いた場合、ルータはロンゲストマッチからルータ C へのエントリを選択します。それ以外のパケットは、デフォルトルートによってルータ B へ転送し、インターネットへと転送します。</simpara>
</section>
</section>
<section xml:id="_routingtable_のソースコード">
<title>RoutingTable のソースコード</title>
<section xml:id="_パケットを書き換えて転送する_再">
<title>パケットを書き換えて転送する(再)</title>
<simpara><literal>RoutingTable</literal> クラスのソースコードを見る前に、パケットの書き換えと転送を行う <literal>forward</literal> メソッドをもう一度見ていきましょう。<link linkend="router_part1">前章</link>で説明したこのメソッドが行う 5 つの処理のうち、次の転送先と出力インタフェースを決める方法を見ていきます。</simpara>
<formalpara>
<title>SimpleRouter#forward (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def forward(dpid, packet_in)
  next_hop = resolve_next_hop(packet_in.destination_ip_address)

  interface = Interface.find_by_prefix(next_hop)
  return if !interface || (interface.port_number == packet_in.in_port)

  arp_entry = @arp_table.lookup(next_hop)
  if arp_entry
    actions = [SetSourceMacAddress.new(interface.mac_address),
               SetDestinationMacAddress.new(arp_entry.mac_address),
               SendOutPort.new(interface.port_number)]
    send_flow_mod_add(dpid,
                      match: ExactMatch.new(packet_in), actions: actions)
    send_packet_out(dpid, raw_data: packet_in.raw_data, actions: actions)
  else
    send_later(dpid,
               interface: interface,
               destination_ip: next_hop,
               data: packet_in.data)
  end
end</programlisting>
</para>
</formalpara>
<simpara>宛先アドレス (<literal>packet_in.destination_ip_address</literal>) に対する次転送先の決定は、<literal>resolve_next_hop</literal> メソッドで行います。</simpara>
<formalpara>
<title>SimpleRouter#resolve_next_hop (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def resolve_next_hop(destination_ip_address)
  interface = Interface.find_by_prefix(destination_ip_address)
  if interface
    destination_ip_address
  else
    @routing_table.lookup(destination_ip_address)
  end
end</programlisting>
</para>
</formalpara>
<simpara>このメソッドでは、まず宛先アドレスと同じネットワークアドレスを持つインタフェースを探します。もし見つかった場合には、次の転送先として宛先アドレスをそのまま返します。見つからなった場合には、ルーティングテーブルから次の転送先を検索します。</simpara>
<simpara>その後 forward メソッドへ戻り、決定した次の転送先がルータのインタフェースに接続しているかを判定します。</simpara>
<formalpara>
<title>SimpleRouter#forward (lib/simple_router.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">interface = Interface.find_by_prefix(next_hop)
return if !interface || (interface.port_number == packet_in.in_port)</programlisting>
</para>
</formalpara>
<simpara>この判定は、次の転送先と同一のネットワークアドレスを持つインタフェースがあるかどうかを調べればわかります。もし、該当するインタフェースがない場合、ルータはそのパケットを転送できないので、パケットを破棄して転送処理を終えます。</simpara>
</section>
<section xml:id="_ルーティングテーブル_literal_routingtable_literal_クラス_の実装">
<title>ルーティングテーブル (<literal>RoutingTable</literal> クラス) の実装</title>
<simpara>次にルーティングテーブルのソースコードを見ていきます。</simpara>
<formalpara>
<title>lib/routing_table.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># Routing table
class RoutingTable
  include Pio

  MAX_NETMASK_LENGTH = 32

  def initialize(route)
    @db = Array.new(MAX_NETMASK_LENGTH + 1) { Hash.new }
    route.each { |each| add(each) }
  end

  def add(options)
    netmask_length = options.fetch(:netmask_length)
    prefix = IPv4Address.new(options.fetch(:destination)).mask(netmask_length)
    @db[netmask_length][prefix.to_i] = IPv4Address.new(options.fetch(:next_hop))
  end

  def lookup(destination_ip_address)
    MAX_NETMASK_LENGTH.downto(0).each do |each|
      prefix = destination_ip_address.mask(each)
      entry = @db[each][prefix.to_i]
      return entry if entry
    end
    nil
  end
end</programlisting>
</para>
</formalpara>
<simpara>インスタンス変数 <literal>@db</literal> はルーティングテーブルで、ネットマスク長ごと (0 〜 32) に経路を管理します。経路情報はネットワークアドレスをキーとし、次の転送先 IP アドレスを値とするハッシュテーブルです。</simpara>
<simpara>ルーティングテーブルの検索は、<literal>lookup</literal> メソッドで行います。このメソッドでは、宛先 <literal>destination_ip_address</literal> に該当する次の転送先 IP アドレスを <literal>@db</literal> 中から探します。ロンゲストマッチを行うために、ネットマスク長が長い順 (32…0) に <literal>@db</literal> から次の転送先 IP アドレスを探索します。</simpara>
</section>
<section xml:id="_コンフィグ">
<title>コンフィグ</title>
<simpara>ルータが動作するためには、インタフェースのアドレスとルーティングテーブルの設定が必要です。シンプルルータでは、これらの設定を <literal>simple_router.conf</literal> に記述します。</simpara>
<formalpara>
<title>simple_router.conf</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># Simple router configuration
module Configuration
  INTERFACES = [
    {
      port: 1,
      mac_address: '01:01:01:01:01:01',
      ip_address: '192.168.1.1',
      netmask_length: 24
    },
    {
      port: 2,
      mac_address: '02:02:02:02:02:02',
      ip_address: '192.168.2.1',
      netmask_length: 24
    }
  ]

  ROUTES = [
    {
      destination: '0.0.0.0',
      netmask_length: 0,
      next_hop: '192.168.1.2'
    }
  ]
end</programlisting>
</para>
</formalpara>
<simpara>インタフェースの設定では、そのインタフェースの MAC アドレス (<literal>:mac_address</literal>)、IP アドレス (<literal>:ip_address</literal>)、ネットマスク長 (<literal>:netmask_length</literal>) と、このインタフェースが OpenFlow スイッチのどのポート (<literal>:port</literal>) に対応しているかを指定します。</simpara>
<simpara>ルーティングテーブルの設定では、宛先 (<literal>:destination</literal>)、ネットマスク長 (<literal>:netmask_length</literal>) と次の転送先 (<literal>:next_hop</literal>) を指定します。</simpara>
</section>
</section>
<section xml:id="_実行してみよう_8">
<title>実行してみよう</title>
<simpara>いよいよシンプルルータを動かしてみましょう。いろいろなパケットの送受信を行うために、今回は仮想ホストではなくネットワークネームスペースを使います。今まで使ってきた仮想ホストは簡単なパケット送受信機能とカウンタを備えているので、コントローラの初歩的な導通テストには便利でした。ただしコントローラに ssh や http といった通信を流したりベンチマークを計測する場合など、仮想ホストだけでは機能が不十分な場合もあります。ネットワークネームスペース機能を使えば、ping や iperf といったおなじみのツールをはじめ、任意のアプリケーションを仮想ネットワーク上で動かせます。</simpara>
<figure xml:id="sample_router_network">
<title>シンプルルータを動かすための構成</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/sample_router_network.png"/>
</imageobject>
<textobject><phrase>sample router network</phrase></textobject>
</mediaobject>
</figure>
<simpara>たとえば<link linkend="sample_router_network">図 13-6</link> のような IP アドレスとデフォルトルートを持つホスト 2 台をスイッチに接続するには、次のように設定ファイルで <literal>vhost</literal> の代わりに <literal>netns</literal> を指定することで、独立した仮想的なネットワーク環境であるネットワークネームスペースを作れます。それぞれの <literal>netns</literal> のルーティング情報は <literal>route</literal> で指定できます。</simpara>
<formalpara>
<title>trema.conf</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">vswitch('0x1') { dpid 0x1 }
netns('host1') {
  ip '192.168.1.2'
  netmask '255.255.255.0'
  route net: '0.0.0.0', gateway: '192.168.1.1'
}
netns('host2') {
  ip '192.168.2.2'
  netmask '255.255.255.0'
  route net: '0.0.0.0', gateway: '192.168.2.1'
}
link '0x1', 'host1'
link '0x1', 'host2'</programlisting>
</para>
</formalpara>
<simpara>この設定ファイルを指定し <literal>trema run</literal> で <literal>lib/simple_router.rb</literal> を実行すれば、<link linkend="sample_router_network">図 13-6</link>のネットワーク環境でシンプルルータが起動します。</simpara>
<screen>$ ./bin/trema run ./lib/simple-router.rb -c ./trema.conf</screen>
<simpara>ネットワークネームスペース内で任意のコマンドを起動するためには、<literal>trema netns</literal> コマンドを使います。たとえば、次のコマンドを実行すると host1 の環境上でシェルを起動できます。</simpara>
<screen>$ ./bin/trema netns host1</screen>
<simpara>起動したシェル上で、ためしに host1 環境のルーティングテーブルを確認してみましょう。</simpara>
<screen>$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 host1
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 host1</screen>
<simpara>たしかに、デフォルトゲートウェイは設定ファイル通り 192.168.1.1 となっています。このように、<literal>trema netns</literal> で起動したシェル上では通常のコマンドを指定した環境上で実行できます。シェルを終了するには <literal>exit</literal> または kbd:[Ctrl + d] です。</simpara>
<section xml:id="_ping_で動作を確認する">
<title>ping で動作を確認する</title>
<simpara>最初は簡単に ping を使ってシンプルルータが正しく動作しているかを順に確認して行きましょう。まずは、シンプルルータが ping に応答するかどうかの確認です。host1 にログインし、次のようにシンプルルータの IP アドレス 192.168.1.1 に ping を打ってみます。</simpara>
<screen>$ ./bin/trema netns host1
$ ping 192.168.1.1
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_seq=1 ttl=128 time=47.4 ms
64 bytes from 192.168.1.1: icmp_seq=2 ttl=128 time=15.0 ms
64 bytes from 192.168.1.1: icmp_seq=3 ttl=128 time=15.0 ms
64 bytes from 192.168.1.1: icmp_seq=4 ttl=128 time=19.3 ms
64 bytes from 192.168.1.1: icmp_seq=5 ttl=128 time=14.8 ms
64 bytes from 192.168.1.1: icmp_seq=6 ttl=128 time=14.4 ms
64 bytes from 192.168.1.1: icmp_seq=7 ttl=128 time=15.1 ms
^C
--- 192.168.1.1 ping statistics ---
7 packets transmitted, 7 received, 0% packet loss, time 6008ms
rtt min/avg/max/mdev = 14.425/20.189/47.473/11.245 ms</screen>
<simpara>ちゃんと ping が返ってきました。次に、シンプルルータをまたいだ二つのホスト間で通信できることも確認してみましょう。host2 の IP アドレス 192.168.2.2 に対して、host1 から ping を送ります。</simpara>
<screen>$ ping 192.168.2.2
PING 192.168.2.2 (192.168.2.2) 56(84) bytes of data.
64 bytes from 192.168.2.2: icmp_seq=1 ttl=64 time=75.5 ms
64 bytes from 192.168.2.2: icmp_seq=2 ttl=64 time=82.3 ms
64 bytes from 192.168.2.2: icmp_seq=3 ttl=64 time=101 ms
64 bytes from 192.168.2.2: icmp_seq=4 ttl=64 time=83.3 ms
64 bytes from 192.168.2.2: icmp_seq=5 ttl=64 time=78.2 ms
64 bytes from 192.168.2.2: icmp_seq=6 ttl=64 time=76.4 ms
64 bytes from 192.168.2.2: icmp_seq=7 ttl=64 time=70.9 ms
^C
--- 192.168.2.2 ping statistics ---
7 packets transmitted, 7 received, 0% packet loss, time 6008ms
rtt min/avg/max/mdev = 70.995/81.159/101.180/9.050 ms</screen>
<simpara>この場合もちゃんと ping が返ってきています。以上より、シンプルルータのパケット転送を確認できました。</simpara>
</section>
<section xml:id="_iperf_で動作を確認する">
<title>iperf で動作を確認する</title>
<simpara>次は iperf でネットワークスループットを計測してみましょう。まずは iperf をインストールします。</simpara>
<screen>$ sudo apt-get update
$ sudo apt-get install iperf</screen>
<simpara>iperf はサーバ・クライアント型のアプリケーションなので、まずは host2 上で次のように iperf のサーバを起動しておきます。</simpara>
<screen>$ ./bin/trema netns host2
$ iperf -s --bind 192.168.2.2
------------------------------------------------------------
Server listening on TCP port 5001
Binding to local address 192.168.2.2
TCP window size: 85.3 KByte (default)
------------------------------------------------------------</screen>
<simpara>host1 上では次のように iperf のクライアントを起動し、ベンチマークを実行します。</simpara>
<screen>$ ./bin/trema netns host1
$ iperf -c 192.168.2.2 --bind 192.168.1.2
------------------------------------------------------------
Client connecting to 192.168.2.2, TCP port 5001
Binding to local address 192.168.1.2
TCP window size: 85.0 KByte (default)
------------------------------------------------------------
[  3] local 192.168.1.2 port 5001 connected with 192.168.2.2 port 5001
[ ID] Interval       Transfer     Bandwidth
[  3]  0.0-16.4 sec   256 KBytes   128 Kbits/sec</screen>
<simpara>仮想環境上なのでこの数字にはほとんど意味はありませんが、ネットワークネームスペースを使えばこのように iperf や ssh, httpd といったサーバ・クライアント型のアプリケーションも実行できます。</simpara>
</section>
</section>
<section xml:id="_まとめ_13">
<title>まとめ</title>
<simpara>ルータ編のまとめとして、もっとも重要な機能であるルーティングテーブルを詳しく説明しました。</simpara>
<itemizedlist>
<listitem>
<simpara>ルーティングテーブルの複数のエントリ(宛先がホストのIPアドレス)を1つのエントリ(宛先がネットワークアドレス)にまとめることで、エントリ数を減らせる</simpara>
</listitem>
<listitem>
<simpara>こうしてまとめられたエントリは、ネットワークアドレスの一部が同じ他のエントリとまとめることで、さらにエントリ数を減らせる</simpara>
</listitem>
<listitem>
<simpara>パケットの宛先にマッチするエントリがルーティングテーブルに複数ある場合は、ネットマスクがもっとも長いエントリを優先 (ロンゲストマッチ) する</simpara>
</listitem>
<listitem>
<simpara>ルーティングテーブルの宛先に0.0.0.0/0を指定することで、パケットがエントリにマッチしなかった場合のデフォルトの宛先、つまりデフォルトルートを設定できる</simpara>
</listitem>
<listitem>
<simpara>ネットワークネームスペースを使えば、任意のアプリケーションを使ってコントローラをテストできる</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="router13">
<title>ルータ (マルチプルテーブル編)</title>
<simpara role="lead">OpenFlow1.3 のマルチプルテーブルを使うことで、ルータの機能の大部分をフローテーブルとして実装してみましょう</simpara>
<section xml:id="_マルチプルテーブル版ルータのテーブル構成">
<title>マルチプルテーブル版ルータのテーブル構成</title>
<simpara>マルチプルテーブル版ルータは<link linkend="router_multiple_tables_overview">図 14-1</link>の 7 つのテーブルで動作します。Ingress テーブルに入ったパケットはその種類が ARP か IPv4 かによって 2 通りのパスを通り、Egress テーブルから出力します。</simpara>
<figure xml:id="router_multiple_tables_overview">
<title>マルチプルテーブル版ルータのテーブル構成</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/router_multiple_tables_overview.png"/>
</imageobject>
<textobject><phrase>router multiple tables overview</phrase></textobject>
</mediaobject>
</figure>
<simpara>それぞれのテーブルの役割とフローエントリを見て行きましょう。</simpara>
<section xml:id="_ingress_テーブル_protocol_classifier_テーブル">
<title>Ingress テーブル、Protocol Classifier テーブル</title>
<simpara>パケットは最初、テーブル ID が 0 番の Ingress テーブルに入ります (<link linkend="ingress_and_protocol_classifier_table">図 14-2</link>)。</simpara>
<figure xml:id="ingress_and_protocol_classifier_table">
<title>パケットは最初にテーブル ID = 0 の Ingress テーブルに入り、そのまま Protocol Classifier テーブルへ渡される</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/ingress_and_protocol_classifier_table.png"/>
</imageobject>
<textobject><phrase>ingress and protocol classifier table</phrase></textobject>
</mediaobject>
</figure>
<simpara>見ての通り Ingress テーブルでは何も処理をせず、パケットをそのまま Protocol Classifier テーブルへと渡します。</simpara>
<simpara>Protocol Classifier テーブルは、Ingress テーブルから入ったパケットをその種類によって仕分けします。パケットの仕分けにはマッチフィールドの <literal>ether_type</literal> を使います。これが ARP の場合には ARP Responder テーブルへ、IPv4 の場合には Routing Table テーブルへとそれぞれパケット処理を引き継ぎます。</simpara>
</section>
<section xml:id="_arp_responder_テーブル">
<title>ARP Responder テーブル</title>
<simpara>パケットが ARP だった場合、ARP Responder テーブルがパケットを処理します。ARP Responder テーブルは ARP パケットをタイプ別にそれぞれ次のように処理します。</simpara>
<variablelist>
<varlistentry>
<term>ホストからルータへの ARP Reply</term>
<listitem>
<simpara>ホストの MAC アドレスを学習する</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ルータのポート宛の ARP Request</term>
<listitem>
<simpara>ホストの MAC アドレスを学習し、ポートの MAC アドレスを ARP Reply で返す</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>それ以外の ARP</term>
<listitem>
<simpara>パケットを書き換えて適切なポートから転送する</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>ARP Responder テーブルは、前記 3 種類の処理×ポート数分のフローエントリを持ちます。たとえばポートが 2 つの場合には、<link linkend="arp_responder_table">図 14-3</link>のようにフローエントリ数は全部で 6 つです。それぞれのフローエントリの具体的な働きについては後述します。</simpara>
<figure xml:id="arp_responder_table">
<title>ARP Responder テーブルのフローエントリ例</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/arp_responder_table.png"/>
</imageobject>
<textobject><phrase>arp responder table</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_routing_table_テーブル">
<title>Routing Table テーブル</title>
<simpara>パケットが IPv4 だった場合、Routing Table, Interface Lookup そして ARP Table Lookup の 3 つのテーブルによってパケットを処理します。</simpara>
<simpara>パケットが最初に入る Routing Table テーブルは、パケットのネクストホップをロンゲストマッチで決定します。そして、決定したネクストホップをレジスタ <literal>reg0</literal> に入れます。それぞれのフローエントリの具体的な働きについては後述します。</simpara>
<figure xml:id="routing_table_table">
<title>ARP Responder テーブルのフローエントリ例</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/routing_table_table.png"/>
</imageobject>
<textobject><phrase>routing table table</phrase></textobject>
</mediaobject>
</figure>
<note>
<title>コラム: レジスタ</title>
<simpara>レジスタはパケットごとに8個まで (reg0〜reg7) の任意の値を設定できる32ビットの変数です。使い道としては、たとえば Routing Table テーブルで見たように IP アドレス (整数表現) などの即値を入れたり、パケットのフィールド値を入れたりできます。そして、セットしたレジスタの値はマッチフィールドの条件として使えるほか、SendOutPortの出力先ポート番号としても使えます。</simpara>
<simpara>このようにレジスタ機能は非常に柔軟で強力ですが、対応しているスイッチ実装が限られます。レジスタ機能はNicira社による独自拡張であるため、Nicira 拡張に対応した Open vSwitch などの高機能なスイッチでしか使えません。もしこうした拡張機能を使いたい場合には、スイッチのスペックをよく確認しておきましょう。</simpara>
</note>
</section>
<section xml:id="_interface_lookup_テーブル">
<title>Interface Lookup テーブル</title>
<simpara>Interface Lookup テーブルはパケットをどのポートから出力するかを決定します (<link linkend="interface_lookup_table">図 14-5</link>)。Routing Table テーブルで設定した <literal>reg0</literal> のネクストホップを元に、出力先のポート番号を決定し <literal>reg1</literal> にセットします。そして、パケットの送信元 MAC アドレスをポートの MAC アドレスに書き換えます。この動作はポートごとに異なるため、フローエントリ数はルータのポート数と同じになります。</simpara>
<figure xml:id="interface_lookup_table">
<title>Interface Lookup テーブルのフローエントリ例</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/interface_lookup_table.png"/>
</imageobject>
<textobject><phrase>interface lookup table</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_arp_table_lookup_テーブル">
<title>ARP Table Lookup テーブル</title>
<simpara>ARP Table Lookup テーブルはパケットの宛先 MAC アドレスを設定します (<link linkend="arp_table_lookup_table">図 14-6</link>)。 ネクストホップ (<literal>reg0</literal>) から、対応するホストの MAC アドレスをパケットの宛先 MAC アドレスとして書き込みます。</simpara>
<simpara>ルータを起動した直後にはフローエントリ数は 1 つですが、ARP Reply を受け取り新しい MAC アドレスを学習するたびにフローエントリ数が増えます。それぞれのフローエントリの具体的な働きについては後述します。</simpara>
<figure xml:id="arp_table_lookup_table">
<title>ARP Table Lookup テーブルのフローエントリ例</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/arp_table_lookup_table.png"/>
</imageobject>
<textobject><phrase>arp table lookup table</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_egress_テーブル">
<title>Egress テーブル</title>
<simpara>フローテーブルから出力するパケットはすべて Egress テーブルを通ります (<link linkend="egress_table">図 14-7</link>)。Egress テーブルはレジスタ <literal>reg1</literal> が指すポートにパケットを出力します。</simpara>
<figure xml:id="egress_table">
<title>Egress テーブルはパケットをポート reg1 番へ出力する</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/egress_table.png"/>
</imageobject>
<textobject><phrase>egress table</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section xml:id="_マルチプルテーブル版ルータの動作例">
<title>マルチプルテーブル版ルータの動作例</title>
<simpara>マルチプルテーブル版ルータの動作例をいくつか、<link linkend="sample_router_network_openflow13">図 14-8</link>の構成で詳しく見て行きましょう。</simpara>
<figure xml:id="sample_router_network_openflow13">
<title>マルチプルテーブル版ルータを動かすためのネットワーク構成</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/sample_router_network_openflow13.png"/>
</imageobject>
<textobject><phrase>sample router network openflow13</phrase></textobject>
</mediaobject>
</figure>
<simpara>以降の説明で参照するマルチプルテーブル版ルータのソースコードは、GitHub の trema/simple_router リポジトリに入っています。次のコマンドでソースコードを取得してください。</simpara>
<screen>$ git clone https://github.com/trema/simple_router.git</screen>
<simpara>依存する gem のインストールは、いつも通り bundle install コマンドです。</simpara>
<screen>$ cd simple_router
$ bundle install --binstubs</screen>
<simpara>これで準備は完了です。</simpara>
<section xml:id="_ポート宛の_arp_request_に応答する">
<title>ポート宛の ARP Request に応答する</title>
<simpara>host1 がルータのポート 1 番宛に ARP Request を送信した場合、フローテーブルは<link linkend="handle_arp_request">図 14-9</link>の 2 つの処理を行います:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>host1 の MAC アドレスの学習</simpara>
</listitem>
<listitem>
<simpara>ARP Reply を host1 へ送信</simpara>
</listitem>
</orderedlist>
<figure xml:id="handle_arp_request">
<title>host1 がルータのポート 1 宛に ARP Request を送信した場合</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/handle_arp_request.png"/>
</imageobject>
<textobject><phrase>handle arp request</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_host1_の_mac_アドレスの学習">
<title>host1 の MAC アドレスの学習</title>
<simpara>ポート 1 番に届いた ARP Request は、Ingress テーブルから Protocol Classifier を経て ARP Responder のフローエントリにマッチします (<link linkend="handle_arp_request">図 14-9</link> の1)。そして ARP Request を送った host1 の MAC アドレスを学習するため、<literal>SendOutPort</literal> アクションでコントローラへと Packet In します (<link linkend="handle_arp_request">図 14-9</link> の 2)。</simpara>
<simpara>コントローラでは、Packet In の送信元 IP アドレスと MAC アドレスを学習します。この学習は、ARP Table Lookup テーブルに <literal>host1</literal> のフローエントリを追加することで行います (<link linkend="handle_arp_request">図 14-9</link> の 3)。</simpara>
<formalpara>
<title>SimpleRouter13#add_arp_entry (lib/simple_router13.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def add_arp_entry(ip_address, mac_address, dpid)
  send_flow_mod_add(
    dpid,
    table_id: ARP_TABLE_LOOKUP_TABLE,
    priority: 2,
    match: Match.new(ether_type: EthernetHeader::EtherType::IPV4,
                     reg0: IPv4Address.new(ip_address).to_i),
    instructions: [Apply.new(SetDestinationMacAddress.new(mac_address)),
                   GotoTable.new(EGRESS_TABLE)]
  )
end</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_arp_reply_を_host1_へ送信">
<title>ARP Reply を host1 へ送信</title>
<simpara>コントローラを使わずにフローテーブルだけで ARP Reply を返すために、届いた ARP Request を ARP Reply へ書き換えます。書き換えに必要なアクションは多いですが、やっていることは単純です。</simpara>
<itemizedlist>
<listitem>
<simpara>イーサヘッダの <literal>source_mac_address</literal> の値を <literal>destination_mac_address</literal> にコピー</simpara>
</listitem>
<listitem>
<simpara><literal>source_mac_address</literal> の値をインタフェースの MAC アドレスの MAC アドレスの値にセット</simpara>
</listitem>
<listitem>
<simpara>ARP operation の値を ARP Reply にセット</simpara>
</listitem>
<listitem>
<simpara>ARP の <literal>sender_hardware_address</literal> (送信元の MAC アドレス) の値を <literal>target_hardware_address</literal> (宛先の MAC アドレス) にコピー</simpara>
</listitem>
<listitem>
<simpara>ARP の <literal>sender_protocol_address</literal> (送信元の IP アドレス) の値を <literal>target_protocol_address</literal> (宛先の IP アドレス) にコピー</simpara>
</listitem>
<listitem>
<simpara>ARP の <literal>sender_hardware_address</literal> をインタフェースの MAC アドレスの値にセット</simpara>
</listitem>
<listitem>
<simpara>ARP の <literal>sender_protocol_address</literal> をインタフェースの IP アドレスの値にセット</simpara>
</listitem>
</itemizedlist>
<simpara>そして最後に、作った ARP Reply の出力先ポート番号 1 (= <literal>host1</literal> のつながるポート番号) を <literal>reg1</literal> にセットし、ARP Reply を Egress テーブルへ渡します (<link linkend="handle_arp_request">図 14-9</link> の 4)。Egress テーブルはこのポート <literal>reg1</literal> へ ARP Reply を出力します。</simpara>
</section>
</section>
<section xml:id="_host1_から_host2_へ_ping_する">
<title>host1 から host2 へ ping する</title>
<simpara><link linkend="sample_router_network_openflow13">図 14-8</link> においてもう少し複雑な、<literal>host1</literal> から <literal>host2</literal> へ ping を打った場合を考えてみましょう。まずはルータが host2 へ ICMP Echo Request を届ける動作をおさらいします。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>host1 が出力した ICMP Echo Request がスイッチのポート 1 番に届く</simpara>
</listitem>
<listitem>
<simpara>ルータはルーティングテーブルから転送先ポートを 2 番と決定する</simpara>
</listitem>
<listitem>
<simpara>host2 の MAC アドレスを調べるため、ルータはポート 2 番から ARP Request を出力する</simpara>
</listitem>
<listitem>
<simpara>host2 は自分の MAC アドレスを乗せた ARP Reply を出力する</simpara>
</listitem>
<listitem>
<simpara>ルータは ICMP Echo Request の送信元と宛先をそれぞれ書き換えて host2 へ転送する</simpara>
</listitem>
</orderedlist>
<simpara>これに対応するフローテーブルの動作を<link linkend="send_arp_request">図 14-10</link> で見て行きましょう。ポート 1 番に届いた ICMP Echo Request は、Ingress テーブルから Protocol Classifier を経て Routing Table のフローエントリにマッチします (<link linkend="send_arp_request">図 14-10</link> の 1)。Routing Table と Interface Lookup テーブルではロンゲストマッチの処理を行います。</simpara>
<figure xml:id="send_arp_request">
<title>host1 が host2 へ ICMP Echo Request を送信したときに host2 の MAC アドレスを解決するまでの動作</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/send_arp_request.png"/>
</imageobject>
<textobject><phrase>send arp request</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_ロンゲストマッチの処理">
<title>ロンゲストマッチの処理</title>
<simpara>ロンゲストマッチでは、パケットの宛先 IP アドレスからネクストホップと出力ポート番号を決定します。これを Routing Table と Interface Lookup テーブルの 2 つで行います。Routing Table では、パケットの宛先 IP アドレスがポート 2 のネットワークのフローエントリにマッチします<footnote><simpara>ここでは、ルータに直接接続したネットワークへのルーティング (いわゆる connected ルーティング) の動作のみを説明しています。ルータに直接接続していないネットワークへのルーティング (いわゆるスタティックルーティング) の実装については、<literal>lib/simple_router13.rb</literal> の <literal>SimpleRouter13#add_routing_table_flow_entries</literal> メソッドを参照してください。</simpara></footnote>。そこで、ネクストホップ 192.168.2.2 を <literal>reg0</literal> へ入れます。そして、Interface Lookup テーブルではネクストホップに対応する出力ポート 2 を <literal>reg1</literal> にセットします。</simpara>
</section>
<section xml:id="_host2_へ_arp_request_を送る">
<title>host2 へ ARP Request を送る</title>
<simpara>次に ARP Table Lookup テーブルで host2 の MAC アドレスを解決します。host2 の MAC アドレスはまだ学習していないので、ARP Request を送るためコントローラへいったんパケットを Packet In します (<link linkend="send_arp_request">図 14-10</link> の 2)。</simpara>
<simpara>コントローラは Packet In を受け取ると、パケットを「ARP 解決待ちパケットキュー」に追加します。そして、host2 の MAC アドレスを解決するために ARP Request をフローテーブルへ Packet Out します (<link linkend="send_arp_request">図 14-10</link> の 3)。その際、ARP Request には <literal>reg1</literal> (出力先ポート) に 2 をセットしておきます。</simpara>
<formalpara>
<title>SimpleRouter13#packet_in_ipv4 (lib/simple_router13.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in_ipv4(dpid, packet_in)
  dest_ip_address = IPv4Address.new(packet_in.match.reg0.to_i)
  @unresolved_packet_queue[dest_ip_address] += [packet_in.raw_data]
  send_packet_out(
    dpid,
    raw_data: Arp::Request.new(target_protocol_address: dest_ip_address,
                               source_mac: '00:00:00:00:00:00',
                               sender_protocol_address: '0.0.0.0').to_binary,
    actions: [NiciraRegLoad.new(packet_in.match.reg1, :reg1),
              SendOutPort.new(:table)]
  )
end</programlisting>
</para>
</formalpara>
<simpara>フローテーブルへ入った ARP Request は、ARP Responder テーブルのフローエントリにマッチします。そして、<literal>reg1</literal> の値から ARP Request の MAC アドレスと IP アドレスをポート 2 のものにセットしたのち、Egress テーブルから host2 へと転送します。</simpara>
</section>
<section xml:id="_host2_からの_arp_reply_の処理">
<title>host2 からの ARP Reply の処理</title>
<simpara>host2 からの ARP Reply が届くと、コントローラに Packet In します (<link linkend="handle_arp_reply">図 14-11</link> の 1, 2)。</simpara>
<figure xml:id="handle_arp_reply">
<title>host2 の MAC アドレスを学習し ICMP Echo Request を host2 に届けるまでの動作</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/router/handle_arp_reply.png"/>
</imageobject>
<textobject><phrase>handle arp reply</phrase></textobject>
</mediaobject>
</figure>
<simpara>ARP Reply を受け取ったコントローラは次のように動作します。まず、ARP Reply で解決した host2 の MAC アドレス用フローエントリを ARP Table Lookup テーブルに追加します (<link linkend="handle_arp_reply">図 14-11</link> の 3)。そして、MAC アドレス未解決で送信待ちになっていたパケットをすべて、Packet Out で再び Ingress テーブルに入れます (<link linkend="handle_arp_reply">図 14-11</link> の 4)。</simpara>
<formalpara>
<title>SimpleRouter13#packet_in_arp (lib/simple_router13.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in_arp(dpid, packet_in)
  add_arp_entry(packet_in.sender_protocol_address,
                packet_in.sender_hardware_address,
                dpid)
  @unresolved_packet_queue[packet_in.sender_protocol_address].each do |each|
    send_packet_out(dpid, raw_data: each, actions: SendOutPort.new(:table))
  end
  @unresolved_packet_queue[packet_in.sender_protocol_address] = []
end</programlisting>
</para>
</formalpara>
<simpara>以上で host1 から host2 への ICMP Echo Request が届きます。戻りの host2 からの ICMP Echo Reply についても、同様の動作で host1 へと届きます。</simpara>
</section>
</section>
<section xml:id="_実行してみよう_9">
<title>実行してみよう</title>
<simpara>マルチプルテーブル版ルータ (lib/simple_router13.rb) の使いかたは<link linkend="router_part1">12 章</link>、<link linkend="router_part2">13 章</link>で紹介したルータと変わりません。ただし OpenFlow1.3 を使うので、<literal>trema run</literal> の起動オプションに <literal>--openflow13</literal> を付けるのを忘れないでください。</simpara>
<screen>$ ./bin/trema run ./lib/simple-router.rb -c ./trema.conf --openflow13
SimpleRouter13 started.</screen>
<simpara>コントローラが起動したら、ためしに <literal>host1</literal> から <literal>host2</literal> へ ping を送ってみましょう。</simpara>
<screen>$ bundle exec trema netns host1 "ping -c1 192.168.2.2"
PING 192.168.2.2 (192.168.2.2) 56(84) bytes of data.
64 bytes from 192.168.2.2: icmp_seq=1 ttl=64 time=132 ms

--- 192.168.2.2 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 132.738/132.738/132.738/0.000 ms</screen>
<simpara>たしかに host2 へ届いています。<literal>trema dump_flows</literal> コマンドでマルチプルテーブルのフローエントリを眺めてみましょう。</simpara>
<screen>$ bundle exec trema dump_flows 0x1
OFPST_FLOW reply (OF1.3) (xid=0x2):
 cookie=0x0, duration=153.160s, table=0, n_packets=21, n_bytes=1546, priority=0 actions=goto_table:1
 cookie=0x0, duration=153.160s, table=1, n_packets=6, n_bytes=296, priority=0,arp actions=goto_table:2
 cookie=0x0, duration=153.160s, table=1, n_packets=4, n_bytes=392, priority=0,ip actions=goto_table:3
 cookie=0x0, duration=153.152s, table=2, n_packets=1, n_bytes=42, priority=0,arp,in_port=1,arp_tpa=192.168.1.1,arp_op=1 actions=move:NXM_OF_ETH_SRC[]-&gt;NXM_OF_ETH_DST[],set_field:01:01:01:01:01:01-&gt;eth_src,set_field:2-&gt;arp_op,move:NXM_NX_ARP_SHA[]-&gt;NXM_NX_ARP_THA[],move:NXM_OF_ARP_SPA[]-&gt;NXM_OF_ARP_TPA[],set_field:01:01:01:01:01:01-&gt;arp_sha,set_field:192.168.1.1-&gt;arp_spa,load:0xffff-&gt;OXM_OF_IN_PORT[],load:0x1-&gt;NXM_NX_REG1[],goto_table:6
 cookie=0x0, duration=153.142s, table=2, n_packets=1, n_bytes=42, priority=0,arp,in_port=1,arp_tpa=192.168.1.1,arp_op=2 actions=CONTROLLER:65535
 cookie=0x0, duration=153.103s, table=2, n_packets=1, n_bytes=42, priority=0,arp,in_port=2,arp_tpa=192.168.2.1,arp_op=1 actions=move:NXM_OF_ETH_SRC[]-&gt;NXM_OF_ETH_DST[],set_field:02:02:02:02:02:02-&gt;eth_src,set_field:2-&gt;arp_op,move:NXM_NX_ARP_SHA[]-&gt;NXM_NX_ARP_THA[],move:NXM_OF_ARP_SPA[]-&gt;NXM_OF_ARP_TPA[],set_field:02:02:02:02:02:02-&gt;arp_sha,set_field:192.168.2.1-&gt;arp_spa,load:0xffff-&gt;OXM_OF_IN_PORT[],load:0x2-&gt;NXM_NX_REG1[],goto_table:6
 cookie=0x0, duration=153.093s, table=2, n_packets=1, n_bytes=42, priority=0,arp,in_port=2,arp_tpa=192.168.2.1,arp_op=2 actions=CONTROLLER:65535
 cookie=0x0, duration=153.130s, table=2, n_packets=1, n_bytes=64, priority=0,arp,reg1=0x1 actions=set_field:01:01:01:01:01:01-&gt;eth_src,set_field:01:01:01:01:01:01-&gt;arp_sha,set_field:192.168.1.1-&gt;arp_spa,goto_table:6
 cookie=0x0, duration=153.083s, table=2, n_packets=1, n_bytes=64, priority=0,arp,reg1=0x2 actions=set_field:02:02:02:02:02:02-&gt;eth_src,set_field:02:02:02:02:02:02-&gt;arp_sha,set_field:192.168.2.1-&gt;arp_spa,goto_table:6
 cookie=0x0, duration=153.064s, table=3, n_packets=2, n_bytes=196, priority=40024,ip,nw_dst=192.168.1.0/24 actions=move:NXM_OF_IP_DST[]-&gt;NXM_NX_REG0[],goto_table:4
 cookie=0x0, duration=153.055s, table=3, n_packets=2, n_bytes=196, priority=40024,ip,nw_dst=192.168.2.0/24 actions=move:NXM_OF_IP_DST[]-&gt;NXM_NX_REG0[],goto_table:4
 cookie=0x0, duration=153.073s, table=3, n_packets=0, n_bytes=0, priority=0,ip actions=load:0xc0a80102-&gt;NXM_NX_REG0[],goto_table:4
 cookie=0x0, duration=153.047s, table=4, n_packets=2, n_bytes=196, priority=0,reg0=0xc0a80100/0xffffff00 actions=load:0x1-&gt;NXM_NX_REG1[],set_field:01:01:01:01:01:01-&gt;eth_src,goto_table:5
 cookie=0x0, duration=153.039s, table=4, n_packets=2, n_bytes=196, priority=0,reg0=0xc0a80200/0xffffff00 actions=load:0x2-&gt;NXM_NX_REG1[],set_field:02:02:02:02:02:02-&gt;eth_src,goto_table:5
 cookie=0x0, duration=122.241s, table=5, n_packets=1, n_bytes=98, priority=2,ip,reg0=0xc0a80202 actions=set_field:1e:36:b3:90:02:e5-&gt;eth_dst,goto_table:6
 cookie=0x0, duration=122.180s, table=5, n_packets=1, n_bytes=98, priority=2,ip,reg0=0xc0a80102 actions=set_field:e6:b6:de:b6:ed:1e-&gt;eth_dst,goto_table:6
 cookie=0x0, duration=153.027s, table=5, n_packets=2, n_bytes=196, priority=1,ip actions=CONTROLLER:65535
 cookie=0x0, duration=153.022s, table=6, n_packets=6, n_bytes=408, priority=0 actions=output:NXM_NX_REG1[]</screen>
<simpara>それぞれのエントリの <literal>table=数字</literal> の項目がテーブル ID を指しています。この章のマルチプルテーブル構成と見比べて、実際にどれがどのフローエントリかを確認してみてください。ping などでパケットを送受信しながら、フローエントリごとのパケットカウンタ (<literal>n_packets=数字</literal>) の値を確認していくと、より理解が深まることでしょう。</simpara>
</section>
<section xml:id="_まとめ_14">
<title>まとめ</title>
<simpara>OpenFlow1.3 のマルチプルテーブルを使うことで、ルータの機能の大部分をフローテーブルとして実装しました。パケットの種類や処理ごとにテーブルを分割することで、ルータのように複雑な機能もマルチプルテーブルとして実装できます。</simpara>
</section>
</chapter>
<chapter xml:id="topology">
<title>ネットワークトポロジを検出する</title>
<simpara role="lead">大規模なネットワークを構築する前準備として、ネットワークトポロジを OpenFlow で検出してみましょう</simpara>
<section xml:id="_美しい大規模ネットワーク">
<title>美しい大規模ネットワーク</title>
<simpara>筆者はネットワーク研究者という仕事柄、よくさまざまなネットワークを目にします。その中でいつも「すごい!」とうならされるのが、ネットワークエンジニアの憧れ、ShowNet です。ShowNet はネットワーク系最大の展示会 Interop Tokyo の期間中だけ運用されるネットワークで、最新ネットワーク技術のいわばショーケースと言えます。普段は触れることのできない、ネットワーク界の F1 マシンとも言える最新機器を集めたライブデモンストレーションは圧巻の一言です。</simpara>
<simpara>ShowNet の魅力をもっともよく伝えてくれるのが、Interop Tokyo で毎年公開される ShowNet のトポロジ図です (<link linkend="shownet_topology">図 15-1</link>)。注目すべきは、ShowNet の複雑な情報をたった一枚の図に収めているところです。「この部分は、いったいどんなプロトコルで動いているんだろう?」「実際の詳しいトポロジはどうなっているのかな?」こうした気になる部分が、すべて一枚の図にきれいに収まっています。ネットワークが好きな人であれば、気がつくと何時間でも眺めてしまうほどの魅力を持つトポロジ図なのです。</simpara>
<figure xml:id="shownet_topology">
<title>2015 年 Interop Tokyo の ShowNet トポロジ図。引用元: <link xl:href="http://www.interop.jp/2015/shownet/images/topology02.pdf">http://www.interop.jp/2015/shownet/images/topology02.pdf</link> Copyright &#169; Interop Tokyo 2015 ShowNet NOC Team Member and NANO OPT Media, Inc. All Rights Reserved.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topology/shownet_topology.jpg"/>
</imageobject>
<textobject><phrase>shownet topology</phrase></textobject>
</mediaobject>
</figure>
<simpara>ShowNet のようにいくつものスイッチやルータがつながるネットワークの動作では、トポロジ情報の把握が1つの鍵です。パケットが迷子になったりループしたりせずに正しく目的地まで届くためには、スイッチやルータ同士がどのような接続関係にあるかをお互いに把握しなければなりません。</simpara>
<simpara>OpenFlow では、コントローラがこのトポロジ情報を管理します。ネットワーク全体を集中管理するコントローラがトポロジを把握することで、パケットを思いのままに転送できます。たとえば、パケットの転送に、最短パスを使うだけではなく、回り道をさせたり、複数のパス (マルチパス) を使うことも自由自在です。</simpara>
</section>
<section xml:id="_トポロジ検出の仕組み">
<title>トポロジ検出の仕組み</title>
<simpara>コントローラがトポロジ情報を検出するには、スイッチ間のリンクをすべて発見する必要があります。ネットワーク中のスイッチとポート情報は、<literal>switch_ready</literal> ハンドラや Features Request/Reply メッセージを使えばすべて発見できます。したがって、発見したスイッチ間のリンクがすべて発見できれば、ネットワークトポロジを検出できます。</simpara>
<section xml:id="_リンクの発見">
<title>リンクの発見</title>
<simpara>OpenFlow でリンクを発見する方法として代表的なのは、Link Layer Discovery Protocol (LLDP) パケットを使った方法です (<link linkend="lldp_overview">図 15-2</link>)。コントローラはどこにリンクがあるかあたりをつけるために、適当なスイッチ A に LLDP パケットを試しに送ります。もし、スイッチ Aに別のスイッチ B がリンクでつながっていれば、LLDPはそこのリンクを通りスイッチ Bを経由してブーメランのようにコントローラへと戻ってきます。このように LLDP パケットが無事に戻ってくれば、スイッチ A と B はリンクでつながっているとわかります。また、LLDP パケットには通過したリンクの詳しい情報が書き込まれるので、スイッチ A と B がどのポート番号で接続しているかということまでわかります。これを繰り返していけば、最終的にはすべてのリンクを発見できるわけです。</simpara>
<figure xml:id="lldp_overview">
<title>LLDP を使ってリンクを発見する</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topology/lldp_overview.png"/>
</imageobject>
<textobject><phrase>lldp overview</phrase></textobject>
</mediaobject>
</figure>
<simpara>「なぜ、LLDP パケットはきちんとリンクを通ってコントローラまで戻ってくるんだろう？スイッチに LLDP 固有のしかけが必要なのかな？」こう思った方もいるかもしれません。実は、LLDPによるリンクは今まで学んできた OpenFlow の仕組みだけを使って実現できます。つまり、OpenFlow に対応したスイッチであれば LLDPでリンクを発見できるのです。</simpara>
<simpara>LLDP によるリンク発見を OpenFlow で実現する方法を見ていきましょう。<link linkend="lldp_openflow">図 15-3</link> のように、スイッチ 0x1 のポート 5 とスイッチ 0x2 のポート 1 が接続されていたとします。このリンクを発見するために、コントローラは次の動作をします。</simpara>
<figure xml:id="lldp_openflow">
<title>LLDP パケットと OpenFlow の仕組みを使ってリンクを発見する</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topology/lldp_openflow.png"/>
</imageobject>
<textobject><phrase>lldp openflow</phrase></textobject>
</mediaobject>
</figure>
<orderedlist numeration="arabic">
<listitem>
<simpara>コントローラは、接続関係を調べたいスイッチの Datapath ID 0x1 とポート番号 5 を埋め込んだ Link Layer Discovery Protocol (LLDP) パケットを作る</simpara>
</listitem>
<listitem>
<simpara>ポート 5 から出力するというアクションを含む Packet Out メッセージを作り、先ほど作った LLDPパケットをスイッチ 0x1 へと送る</simpara>
</listitem>
<listitem>
<simpara>Packet Out を受け取ったスイッチはアクションに従い、LLDPパケットを指定されたポート 5 から出力する。その結果、LLDP パケットは、ポート 5 の先につながるスイッチ 0x2 へと到着する</simpara>
</listitem>
<listitem>
<simpara>LLDP パケットを受け取ったスイッチ 0x2 は、自身のフローテーブルを参照し、パケットの処理方法を調べる。このとき LLDP に対するフローエントリはあえて設定していないため、今回受信した LLDPパケットは、Packet In としてコントローラまで戻される</simpara>
</listitem>
<listitem>
<simpara>コントローラは、受け取った Packet In メッセージを解析することで、リンクの発見を行う。スイッチ 0x2 からは<link linkend="lldp_packet_in">図 15-4</link> の Packet In メッセージが送られてくる。この中身を見ることで、スイッチ 0x1 のポート 5 と、スイッチ 0x2 のポート 1 の間にリンクを発見できる</simpara>
</listitem>
</orderedlist>
<figure xml:id="lldp_packet_in">
<title>スイッチ 0x2 から送られてくる Packet In メッセージ</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topology/lldp_packet_in.png"/>
</imageobject>
<textobject><phrase>lldp packet in</phrase></textobject>
</mediaobject>
</figure>
<simpara>このように、Packet Out で送られた LLDP パケットは、リンクを通過し、隣のスイッチから Packet In でコントローラへと戻ってきます。この一連の動作によりコントローラはリンクを発見できます。この方法自体は、OpenFlow 仕様でとくに規定されているわけではありません。それぞれのスイッチは OpenFlow 仕様で定められた動作を行っているだけです。つまり、Packet Out と Packet In をうまく使った “OpenFlow ならでは” のリンク発見方法だと言えます。</simpara>
</section>
<section xml:id="_トポロジの検出">
<title>トポロジの検出</title>
<simpara>このリンク発見方法をネットワーク中のすべてのスイッチのすべてのポートに順に適用していけば、ネットワーク全体のスイッチの接続関係、つまりトポロジを検出できます。たとえば<link linkend="topology_before">図 15-5</link>のような 3 台の OpenFlow スイッチからなるネットワークにおいて、どうやってトポロジを検出できるかを見ていきましょう。各 OpenFlow スイッチがコントローラに接続した直後の状態では、コントローラはスイッチ同士がどのように接続されているかを知りません。</simpara>
<figure xml:id="topology_before">
<title>トポロジ検出前のコントローラ</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topology/topology_before.png"/>
</imageobject>
<textobject><phrase>topology before</phrase></textobject>
</mediaobject>
</figure>
<simpara>まずスイッチ 0x1 から調べていきます。はじめに Features Request メッセージを送ることで、スイッチ 0x1 が持つポート一覧を取得します。そして、それぞれのポートに対して、前述のリンク発見手順を行います (<link linkend="topology_after">図 15-6</link>)。その結果、スイッチ 0x1 からスイッチ 0x2 およびスイッチ 0x3 へと至るリンクそれぞれを発見できます。</simpara>
<figure xml:id="topology_after">
<title>スイッチ 0x1 から出るリンクを発見</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topology/topology_after.png"/>
</imageobject>
<textobject><phrase>topology after</phrase></textobject>
</mediaobject>
</figure>
<simpara>あとは同様の手順を、ネットワーク中の各スイッチに対して順に行なっていくだけです。スイッチ 0x2, 0x3 に接続するリンクを順に調べていくことで、ネットワークの完全なトポロジ情報を検出できます。</simpara>
</section>
</section>
<section xml:id="_実行してみよう_10">
<title>実行してみよう</title>
<simpara>このトポロジ検出機能を持つ Topology コントローラを実行してみましょう。ソースコードと仮想ネットワークの設定ファイルは GitHub の trema/topology リポジトリ (<link xl:href="https://github.com/trema/topology">https://github.com/trema/topology</link>) からダウンロードできます。今までと同じく、<literal>git clone</literal> でソースコードを取得し <literal>bundle install</literal> で必要な gem をインストールしてください。</simpara>
<screen>$ git clone https://github.com/trema/topology.git
$ cd topology
$ bundle install --binstubs</screen>
<simpara>ソースコードに含まれる <literal>triangle.conf</literal> はスイッチ 3 台を三角形に接続したトライアングル型のトポロジです (<link linkend="triangle_conf">図 15-7</link>)。</simpara>
<figure xml:id="triangle_conf">
<title>triangle.confのトポロジ</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topology/triangle_conf.png"/>
</imageobject>
<textobject><phrase>triangle conf</phrase></textobject>
</mediaobject>
</figure>
<simpara>これをトポロジコントローラで検出するには、次のように実行します。</simpara>
<screen>$ ./bin/trema run ./lib/topology_controller.rb -c triangle.conf
Topology started (text mode).
Port 0x1:1 added: 1
Port 0x1:2 added: 1, 2
Switch 0x1 added: 0x1
Port 0x3:1 added: 1
Port 0x3:2 added: 1, 2
Switch 0x3 added: 0x1, 0x3
Port 0x2:1 added: 1
Port 0x2:2 added: 1, 2
Switch 0x2 added: 0x1, 0x2, 0x3
Link 0x1-0x2 added: 0x1-0x2
Link 0x1-0x3 added: 0x1-0x2, 0x1-0x3
Link 0x2-0x3 added: 0x1-0x2, 0x1-0x3, 0x2-0x3</screen>
<simpara>先に説明したように、コントローラはまず Features Reply メッセージによってスイッチとポートの一覧を取得します。たとえば、<literal>Port 0x1:1 added</literal> の行はスイッチ 0x1 のポート 1 番をコントローラが検出したという意味です。<literal>Switch 0x1 added</literal> のメッセージも同じく Features Reply メッセージを返したスイッチのデータパス ID を表示しています。</simpara>
<simpara>リンクの検出は LLDP を使って一本ずつ行います。たとえば <literal>Link 0x1-0x2 added</literal> はスイッチ 0x1 から 0x2 に LLDP パケットが通り、コントローラに PacketIn したことからリンクを一本発見したという意味です。これを繰り返すことで最終的に三角形のトポロジ (<literal>Link 0x2-0x3 added: 0x1-0x2, 0x1-0x3, 0x2-0x3</literal> のメッセージ) を発見しています。</simpara>
<simpara>トポロジコントローラはトポロジの変化も検出できます。</simpara>
<figure xml:id="triangle_port_down">
<title>スイッチ 0x1 のポート 1 番を落としたときのトポロジ</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topology/triangle_port_down.png"/>
</imageobject>
<textobject><phrase>triangle port down</phrase></textobject>
</mediaobject>
</figure>
<simpara>たとえば<link linkend="triangle_port_down">図 15-8</link>のようにスイッチ 0x1 のポート 1 番を落としてみましょう。</simpara>
<screen>$ ./bin/trema port_down --switch 0x1 --port 1</screen>
<simpara>すると、コントローラを実行したターミナルには次の表示が出ます。たしかに 0x1-0x2 間のリンクが消滅し、残りは 0x1-0x3 と 0x2-0x3 の二本になりました。</simpara>
<screen>Link 0x1-0x2 deleted: 0x1-0x3, 0x2-0x3
Port 0x1:1 deleted: 2</screen>
<simpara>逆に再びポートを上げると、三角形トポロジが復活します。</simpara>
<screen>$ ./bin/trema port_up --switch 0x1 --port 1</screen>
<screen>Port 0x1:1 added: 1, 2
Link 0x1-0x2 added: 0x1-0x2, 0x1-0x3, 0x2-0x3</screen>
<simpara>トポロジコントローラはトポロジを画像で表示することもできます。この機能を使うためには、システムに graphviz をあらかじめ <literal>apt-get</literal> でインストールしておきます。そして、<literal>trema run</literal> の引数に <literal>--</literal> と <literal>graphviz トポロジ画像出力ファイル名</literal> を指定します。</simpara>
<screen>$ ./bin/trema run ./lib/topology_controller.rb -c triangle.conf -- graphviz /tmp/topology.png</screen>
<simpara>実行すると、<link linkend="graphviz_triangle">図 15-9</link> のようにトポロジ画像が生成されます。</simpara>
<figure xml:id="graphviz_triangle">
<title>トポロジコントローラで生成した三角形トポロジの画像</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topology/graphviz_triangle.png"/>
</imageobject>
<textobject><phrase>graphviz triangle</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_トポロジコントローラのソースコード">
<title>トポロジコントローラのソースコード</title>
<simpara>トポロジコントローラは大きく分けて 3 つの部品からなります (<link linkend="topology_classes">図 15-10</link>)。</simpara>
<variablelist>
<varlistentry>
<term><literal>TopologyController</literal> クラス</term>
<listitem>
<simpara>コントローラの本体で、LLDPパケットの送信とトポロジに関する OpenFlow メッセージの処理をします</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Topology</literal> クラス</term>
<listitem>
<simpara>収集したトポロジ情報を管理し、トポロジの変化を View クラスへ通知します</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>View::Text</literal>, <literal>View::Graphviz</literal> クラス</term>
<listitem>
<simpara>トポロジをテキストまたは画像で表示します</simpara>
</listitem>
</varlistentry>
</variablelist>
<figure xml:id="topology_classes">
<title>トポロジのクラス構成</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topology/topology_classes.png"/>
</imageobject>
<textobject><phrase>topology classes</phrase></textobject>
</mediaobject>
</figure>
<simpara>このクラス分けは、いわゆる MVC モデル (Model-View-Controller) に従っています。<literal>TopologyController</literal> クラスは MVC の Controller にあたり、OpenFlow スイッチとメッセージをやりとりしたり他のクラスをセットアップしたりといった制御を担当します。<literal>Topology</literal> クラスは Model にあたり、ネットワークのモデルすなわちトポロジ情報を管理します。<literal>View::Text</literal> と <literal>View::Graphviz</literal> はその名の通り View にあたり、モデルである Topology を可視化します。</simpara>
<simpara>このようにクラスを MVC で構成するとそれぞれのクラスの役割りがすっきりし、拡張性も向上します。たとえばトポロジを HTML で表示したくなった場合には、新たに <literal>View::Html</literal> クラスを追加するだけで実現できます。しかも、<literal>TopologyController</literal> や <literal>Topology</literal> クラスへの変更はほとんど必要ありません。また、<link linkend="routing_switch">次章</link>で紹介するルーティングスイッチでは、トポロジを部品として使うことで複雑なパケット制御を可能にしています。このように比較的複雑な機能を実現したい場合には、クラスを MVC で構成できるかどうか検討するとよいでしょう。</simpara>
<section xml:id="_モデルとビューのセットアップ">
<title>モデルとビューのセットアップ</title>
<simpara><literal>TopologyController</literal> の仕事の1つは、MVC のモデルとビューのセットアップです。次の <literal>start</literal> ハンドラでは、起動時のコマンドライン引数をパースし、トポロジ表示をテキスト表示 (<literal>View::Text</literal>) にするかまたは画像表示 (<literal>View::Graphviz</literal>) にするかを決定します。そして、決定したビューをモデル (<literal>Topology</literal>) のオブザーバとして追加 (<literal>@topology.add_observer</literal>) します。</simpara>
<formalpara>
<title>TopologyController#start</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def start(args)
  @command_line = CommandLine.new(logger)
  @command_line.parse(args)
  @topology = Topology.new
  @topology.add_observer @command_line.view
  logger.info "Topology started (#{@command_line.view})."
end</programlisting>
</para>
</formalpara>
<simpara>このオブザーバは、デザインパターンにおけるいわゆるオブザーバ・パターンの一例です。<literal>Topology</literal> のオブザーバとして追加されたビューのクラス (<literal>View::Text</literal> または <literal>View::Graphviz</literal>) は、トポロジに変化があった場合に変化イベントを <literal>Topology</literal> から受け取ります。そして、それぞれのビューの方法でトポロジを表示します。</simpara>
<simpara>オブザーバが受け取れるトポロジの変化イベントは次の通りです:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>add_switch</literal>: スイッチの追加イベント</simpara>
</listitem>
<listitem>
<simpara><literal>delete_switch</literal>: スイッチの削除イベント</simpara>
</listitem>
<listitem>
<simpara><literal>add_port</literal>: ポートの追加イベント</simpara>
</listitem>
<listitem>
<simpara><literal>delete_port</literal>: ポートの削除イベント</simpara>
</listitem>
<listitem>
<simpara><literal>add_link</literal>: リンクの追加イベント</simpara>
</listitem>
<listitem>
<simpara><literal>delete_link</literal>: リンクの削除イベント</simpara>
</listitem>
</itemizedlist>
<simpara>オブザーバとして追加できるオブジェクトは、これらのイベントを受け取れば何でもかまいません。たとえば <literal>View::Text</literal> は次のように <literal>add_switch</literal> や <literal>add_port</literal> といったトポロジイベントハンドラを持っており、イベントに応じてトポロジをテキストベースで表示します。</simpara>
<formalpara>
<title>lib/view/text.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">module View
  # Topology controller's CUI.
  class Text
    def initialize(logger)
      @logger = logger
    end

    def add_switch(dpid, topology)
      show_status("Switch #{dpid.to_hex} added",
                  topology.switches.map(&amp;:to_hex))
    end

    def delete_switch(dpid, topology)
      show_status("Switch #{dpid.to_hex} deleted",
                  topology.switches.map(&amp;:to_hex))
    end

    def add_port(port, topology)
      add_or_delete_port :added, port, topology
    end

    def delete_port(port, topology)
      add_or_delete_port :deleted, port, topology
    end

    def add_link(port_a, port_b, topology)
      link = format('%#x-%#x', *([port_a.dpid, port_b.dpid].sort))
      show_status "Link #{link} added", topology.links
    end

    def delete_link(port_a, port_b, topology)
      link = format('%#x-%#x', *([port_a.dpid, port_b.dpid].sort))
      show_status "Link #{link} deleted", topology.links
    end

    def to_s
      'text mode'
    end

    private

    def add_or_delete_port(message, port, topology)
      ports = topology.ports[port.dpid].map(&amp;:number).sort
      show_status "Port #{port.dpid.to_hex}:#{port.number} #{message}", ports
    end

    def show_status(message, objects)
      status = objects.sort.map(&amp;:to_s).join(', ')
      @logger.info "#{message}: #{status}"
    end
  end
end</programlisting>
</para>
</formalpara>
<simpara>MVC で説明したように、未知の外部クラスと連携したい場合にオブザーバ・パターンは便利です。<literal>Topology</literal> からのイベントを受け取るには <literal>Topology#add_observer</literal> でオブザーバとして登録するだけで良く、<literal>Topology</literal> クラスにはオブザーバのクラスに依存するコードはありません。このため、ビューに限らずトポロジ情報を利用するクラスを自由にオブザーバとして追加できます。たとえば<link linkend="routing_switch">次章</link>や<link linkend="sliceable_switch">その次の章</link>で実装するコントローラでは、<literal>Topology</literal> にコントローラ自身をオブザーバとして登録することで、トポロジ情報を利用してパケットの転送を制御します。</simpara>
</section>
<section xml:id="_openflow_メッセージの処理">
<title>OpenFlow メッセージの処理</title>
<simpara><literal>TopologyController</literal> クラスはスイッチから届く OpenFlow メッセージに応じた処理をします。</simpara>
<simpara><literal>switch_ready</literal> ハンドラでは、新しく接続してきたスイッチのポート一覧をを知るために、Features Request メッセージをスイッチに投げます。そして、<literal>features_reply</literal> ハンドラでスイッチから届いた Features Reply が持つポート一覧情報のうち、物理ポートでポートが上がっているものを <literal>@topology</literal> に追加します。このポート一覧は、LLDP パケットを作って送る際に使います。</simpara>
<formalpara>
<title>TopologyController#switch_ready, TopologyController#features_reply</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def switch_ready(dpid)
  send_message dpid, Features::Request.new
end

def features_reply(dpid, features_reply)
  @topology.add_switch dpid, features_reply.physical_ports.select(&amp;:up?)
end</programlisting>
</para>
</formalpara>
<simpara>そのほかのハンドラでは、届いたメッセージの種類に応じてトポロジ情報を更新します。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>switch_disconnected</literal>: コントローラとの接続が切れたスイッチをトポロジ情報 (<literal>@topology</literal>) から削除する</simpara>
</listitem>
<listitem>
<simpara><literal>port_modify</literal>:  ポート情報の変更 (ポートのUPとDOWN) を識別し、どちらの場合も <literal>@topology</literal> に反映する</simpara>
</listitem>
<listitem>
<simpara><literal>packet_in</literal>: 帰ってきた LLDP パケットから発見したリンク情報、または新規ホスト情報を <literal>@topology</literal> に登録する</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>TopologyController#switch_disconnected, TopologyController#port_modify, TopologyController#packet_in</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def switch_disconnected(dpid)
  @topology.delete_switch dpid
end

def port_modify(_dpid, port_status)
  updated_port = port_status.desc
  return if updated_port.local?
  if updated_port.down?
    @topology.delete_port updated_port
  elsif updated_port.up?
    @topology.add_port updated_port
  else
    fail 'Unknown port status.'
  end
end

def packet_in(dpid, packet_in)
  if packet_in.lldp?
    @topology.maybe_add_link Link.new(dpid, packet_in)
  else
    @topology.maybe_add_host(packet_in.source_mac,
                             packet_in.source_ip_address,
                             dpid,
                             packet_in.in_port)
  end
end</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_lldp_パケットをスイッチへ送る">
<title>LLDP パケットをスイッチへ送る</title>
<simpara>LLDP パケットの定期送信は、<literal>flood_lldp_frames</literal> メソッドをタイマで呼び出すことで行います。<literal>@topology</literal> が管理する発見済みポートすべて (<literal>@topology.ports</literal>) に対して、Packet Out で LLDP パケットを送信します。</simpara>
<formalpara>
<title>TopologyController#flood_lldp_frames</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">class TopologyController &lt; Trema::Controller
  timer_event :flood_lldp_frames, interval: 1.sec

  def flood_lldp_frames
    @topology.ports.each do |dpid, ports|
      send_lldp dpid, ports
    end
  end

  private

  def send_lldp(dpid, ports)
    ports.each do |each|
      port_number = each.number
      send_packet_out(
        dpid,
        actions: SendOutPort.new(port_number),
        raw_data: lldp_binary_string(dpid, port_number)
      )
    end
  end</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_トポロジ情報の管理">
<title>トポロジ情報の管理</title>
<simpara><literal>Topology</literal> クラスはトポロジ情報のデータベースです。<literal>TopologyController</literal> が生の OpenFlow メッセージから解釈したトポロジの変化を、ポート一覧、スイッチ一覧などのデータ構造として保存します。そして、変化イベントをオブザーバへ通知します。たとえば <literal>add_switch</literal> メソッドでは、新しいスイッチとポート一覧を登録し、オブザーバの <literal>add_switch</literal> メソッドを呼びます。</simpara>
<formalpara>
<title>Topology#add_switch (lib/topology.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def add_switch(dpid, ports)
  ports.each { |each| add_port(each) }
  maybe_send_handler :add_switch, dpid, self
end

private

def maybe_send_handler(method, *args)
  @observers.each do |each|
    if each.respond_to?(:update)
      each.__send__ :update, method, args[0..-2], args.last
    end
    each.__send__ method, *args if each.respond_to?(method)
  end
end</programlisting>
</para>
</formalpara>
<simpara>スイッチのポート、スイッチにつながっているリンクなど、関連するもの同士は自動的に処理します。たとえば <literal>delete_switch</literal> メソッドでは、スイッチを消すだけでなくスイッチのポートやスイッチとつながるリンクもすべて消します。</simpara>
<formalpara>
<title>Topology#add_switch (lib/topology.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def delete_switch(dpid)
  delete_port(@ports[dpid].pop) until @ports[dpid].empty?
  @ports.delete dpid
  maybe_send_handler :delete_switch, dpid, self
end

def delete_port(port)
  @ports[port.dpid].delete_if { |each| each.number == port.number }
  maybe_send_handler :delete_port, Port.new(port.dpid, port.number), self
  maybe_delete_link port
end

private

def maybe_delete_link(port)
  @links.each do |each|
    next unless each.connect_to?(port)
    @links -= [each]
    port_a = Port.new(each.dpid_a, each.port_a)
    port_b = Port.new(each.dpid_b, each.port_b)
    maybe_send_handler :delete_link, port_a, port_b, self
  end
end</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="_まとめ_15">
<title>まとめ</title>
<simpara>ネットワークトポロジをOpenFlowで検出できる、トポロジコントローラの仕組みを見てきました。この章で学んだことを簡単にまとめておきましょう。</simpara>
<itemizedlist>
<listitem>
<simpara>LLDP でトポロジを検出する仕組み</simpara>
</listitem>
<listitem>
<simpara>トポロジの変化を検出する OpenFlow メッセージとその処理の実装方法</simpara>
</listitem>
<listitem>
<simpara>オブザーバーパターンを使った外部クラスとの連携方法</simpara>
</listitem>
</itemizedlist>
<simpara>次の章では、ネットワーク仮想化の最初の一歩として、たくさんのスイッチを一台の L2 スイッチとして仮想化できる、ルーティングスイッチコントローラを見ていきます。</simpara>
</section>
</chapter>
<chapter xml:id="routing_switch">
<title>たくさんのスイッチを制御する</title>
<simpara role="lead">大規模なネットワークを構成するたくさんのスイッチを連携させ、うまく制御する仕組みを見て行きましょう。</simpara>
<section xml:id="_複数のスイッチを制御する">
<title>複数のスイッチを制御する</title>
<simpara>たくさんの OpenFlow スイッチがつながった環境では、パケットを目的地まで転送するためにスイッチを連携させる必要があります。複数の OpenFlow スイッチを連携し 1 台の大きな仮想スイッチにするコントローラが、本章で紹介するルーティングスイッチです (<link linkend="fig_routing_switch">図 16-1</link>)。同じスイッチ機能を提供するコントローラとしては、<link linkend="learning_switch">7 章</link>や<link linkend="learning_switch13">8 章</link>で紹介したラーニングスイッチがありました。ラーニングスイッチとルーティングスイッチの大きな違いは、連携できるスイッチの台数です。ラーニングスイッチは OpenFlow スイッチを独立した 1 台のスイッチとして扱います。一方で、ルーティングスイッチは複数の OpenFlow スイッチを連携させることで、仮想的な 1 台のスイッチとして扱います。</simpara>
<figure xml:id="fig_routing_switch">
<title>ルーティングスイッチはたくさんの OpenFlow スイッチを連携し 1 台の仮想スイッチとして動作させる</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/routing_switch/routing_switch.png"/>
</imageobject>
<textobject><phrase>routing switch</phrase></textobject>
</mediaobject>
</figure>
<simpara>注意すべきは、ルーティングスイッチはルータではなく、あくまでスイッチであるという点です。<emphasis role="strong">ルーティング</emphasis>スイッチという名前は、複数のOpenFlowスイッチを経由し、まさにルーティングするようにパケットを転送することから来ています。このようにスイッチ機能を実現するという点では、ラーニングスイッチとの機能的な違いはありません。ただし制御できるネットワーク規模の面では、ルーティングスイッチは複数の OpenFlow スイッチを扱えるという違いがあります。</simpara>
<section xml:id="_ルーティングスイッチの動作">
<title>ルーティングスイッチの動作</title>
<simpara>ルーティングスイッチではたくさんのスイッチを接続するため、パケットの転送が複雑になります。宛先のホストまでいくつものスイッチを経由してパケットを届けなくてはならないため、宛先までの道順をスイッチに指示してやる必要があります。</simpara>
<figure xml:id="routing_switch_flow_mod">
<title>最短パスでパケットを転送するフローエントリを書き込む</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/routing_switch/routing_switch_flow_mod.png"/>
</imageobject>
<textobject><phrase>routing switch flow mod</phrase></textobject>
</mediaobject>
</figure>
<simpara>たとえば<link linkend="routing_switch_flow_mod">図 16-2</link>において、ホスト 1 からホスト 4 へとパケットを送信する場合を考えてみましょう。もしパケットを最短のパスで届けたい場合、ホスト 1 → スイッチ 1 → スイッチ 5 → スイッチ 6 → ホスト 4 の順にパケットを転送します。ルーティングスイッチはこの転送をするフローエントリを最短パス上のスイッチ 1, 5, 6 へそれぞれ書き込みます。</simpara>
<simpara>このとき、実際にルーティングスイッチとスイッチ間でやりとりする OpenFlow メッセージは<link linkend="routing_switch_packetin_flowmod_packetout">図 16-3</link>のようになります:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>ホスト 1 がホスト 4 宛てにパケットを送信すると、ルーティングスイッチはこのパケットを Packet In としてスイッチ 1 から受け取る (この Packet In の in_port をポート s とする)</simpara>
</listitem>
<listitem>
<simpara>ルーティングスイッチはあらかじめ収集しておいたトポロジ情報 (<link linkend="topology">15章</link>) を検索し、宛先のホスト 4 が接続するスイッチ (スイッチ 6) とポート番号 (ポート g とする) を得る</simpara>
</listitem>
<listitem>
<simpara>ポート s から宛先のポート g までの最短パスをトポロジ情報から計算する。その結果、ポート s → スイッチ 1 → スイッチ 5 → スイッチ 6 → ポート g というパスを得る</simpara>
</listitem>
<listitem>
<simpara>この最短パスに沿ってパケットを転送するフローエントリを書き込むために、ルーティングスイッチはパス上のスイッチそれぞれに Flow Mod を送る</simpara>
</listitem>
<listitem>
<simpara>Packet In を起こしたパケットを宛先に送るために、ルーティングスイッチはスイッチ 6 のポート g に Packet Out を送る</simpara>
</listitem>
</orderedlist>
<figure xml:id="routing_switch_packetin_flowmod_packetout">
<title>ルーティングスイッチでパケットを送信したときの OpenFlow メッセージ</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/routing_switch/routing_switch_packetin_flowmod_packetout.png"/>
</imageobject>
<textobject><phrase>routing switch packetin flowmod packetout</phrase></textobject>
</mediaobject>
</figure>
<simpara>ここで使っている OpenFlow メッセージはいずれも、今まで使ってきた Packet In や Flow Mod, Packet Out などおなじみの物ばかりです。以下ではステップ 3 で新たに登場した、最短パスの計算方法を詳しく見て行きましょう。</simpara>
</section>
</section>
<section xml:id="_最短パスを計算する">
<title>最短パスを計算する</title>
<simpara>最短パスの計算でよく登場するのがダイクストラ法というアルゴリズムです。これは、出発点から目的地までの最短パスを求める汎用アルゴリズムの 1 つで、カーナビの経路検索や鉄道の乗換案内などにも使われています。</simpara>
<simpara>ダイクストラ法を使った最短パス計算のアルゴリズムは、基本的には次のとおりです。まず、出発点から 1 ホップで到達できるスイッチをすべて探します。次に、見つかったスイッチから出発して 1 ホップで行けるスイッチ、つまり最初の出発点から 2 ホップで到達できるスイッチをすべて探します。これを繰り返して、出発点から 3 ホップ、 4 ホップ……というように距離を広げながら次々とスイッチを探していきます。途中で目的地のスイッチに到達したら探索完了で、そこまでのパスを最短パスとして返します。<footnote><simpara>ダイクストラ法はリンクに重み（距離）がある場合の最短パスを求められるので、実際にはもう少し複雑な手順になります。ネットワーク上の最短パスではそれぞれのリンクは“重み1”として考えるので、このように単純化できます。</simpara></footnote></simpara>
<figure xml:id="dijkstra">
<title>最短パスをダイクストラ法で計算する</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/routing_switch/dijkstra.png"/>
</imageobject>
<textobject><phrase>dijkstra</phrase></textobject>
</mediaobject>
</figure>
<simpara>実際に<link linkend="routing_switch_flow_mod">図 16-2</link> のネットワークでスイッチ 1 からスイッチ 6 までの最短パスをダイクストラ法で探索する手順は<link linkend="dijkstra">図 16-4</link> のようになります:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>始点となるスイッチ 1 を 0 ホップとする</simpara>
</listitem>
<listitem>
<simpara>スイッチ 1 から 1 ホップで行けるすべてのスイッチを見つける。これはスイッチ 1 から出るリンクの先に繋がっているスイッチ 2, 4, 5 である</simpara>
</listitem>
<listitem>
<simpara>同様にステップ 2 で見つかったスイッチから 1 ホップで行けるすべてのスイッチを探し、スイッチ 3, 6 が見つかる。これらは始点からのホップ数が 2 のスイッチである</simpara>
</listitem>
<listitem>
<simpara>ステップ 3 でゴールのスイッチ 6 が見つかったので探索を終わる。最短パスは最終的にスイッチ 1 → スイッチ 5 → スイッチ 6 とわかる</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_実行してみよう_11">
<title>実行してみよう</title>
<simpara>動作原理がわかったところで、実際のトポロジ検出や最短パス計算の動作をルーティングスイッチを起動し確認してみましょう。ルーティングスイッチは他のサンプルと同様、GitHub で公開しています。次のコマンドでソースコードを取得してください。</simpara>
<screen>$ git clone https://github.com/trema/routing_switch.git</screen>
<simpara>依存する gem のインストールは、いつも通り <literal>bundle install</literal> コマンドです。</simpara>
<screen>$ cd routing_switch
$ bundle install --binstubs</screen>
<simpara>これで準備は完了です。</simpara>
<section xml:id="_ルーティングスイッチを動かす">
<title>ルーティングスイッチを動かす</title>
<simpara>それでは、ルーティングスイッチを動かしてみましょう。Trema のネットワークエミュレータ機能を用いて、<link linkend="routing_switch_sample_network">図 16-5</link> のネットワークを作ります。</simpara>
<figure xml:id="routing_switch_sample_network">
<title>ホスト 4 台、スイッチ 6 台からなるネットワーク</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/routing_switch/routing_switch_sample_network.png"/>
</imageobject>
<textobject><phrase>routing switch sample network</phrase></textobject>
</mediaobject>
</figure>
<simpara>この構成を実現する設定ファイルは、ルーティングスイッチのソースツリーに入っています (<literal>trema.conf</literal>)。この設定ファイルを指定して、次のようにルーティングスイッチを起動します。</simpara>
<screen>$ ./bin/trema run ./lib/routing_switch.rb -c trema.conf</screen>
</section>
<section xml:id="_最短パスを通すフローエントリを確認する">
<title>最短パスを通すフローエントリを確認する</title>
<simpara>次に host1 と host4 の間でパケットを送受信し、最短パスを通すフローエントリがうまく設定されることを確認しましょう。ルーティングスイッチ起動直後は、まだ MAC アドレスの学習を行っていないので、host1 から host4 へとパケットを送っただけではフローエントリは設定されません。ラーニングスイッチと同じく、次のように両方向でパケットを送った段階でフローエントリが設定されます。</simpara>
<screen>$ ./bin/trema send_packets --source host1 --dest host4
$ ./bin/trema send_packets --source host4 --dest host1
$ ./bin/trema send_packets --source host1 --dest host4</screen>
<simpara>すると、ルーティングスイッチを起動したターミナルには host4 → host1 と host1 → host4 の 2 つの最短パスを発見した、というメッセージが表示されているはずです。</simpara>
<screen>Creating path: 44:44:44:44:44:44 -&gt; 0x6:1 -&gt; 0x6:2 -&gt; 0x5:5 -&gt; 0x5:2 -&gt; 0x1:4 -&gt; 0x1:1 -&gt; 11:11:11:11:11:11
Creating path: 11:11:11:11:11:11 -&gt; 0x1:1 -&gt; 0x1:4 -&gt; 0x5:2 -&gt; 0x5:5 -&gt; 0x6:2 -&gt; 0x6:1 -&gt; 44:44:44:44:44:44</screen>
<simpara>実際にどのようなフローエントリが設定されたか見てみましょう。フローエントリの確認は <literal>trema dump_flows</literal> コマンドです。まずは host1 から host4 への最短パスである switch1, switch5, switch6 のフローテーブルをそれぞれ見てみましょう。</simpara>
<screen>$ ./bin/trema dump_flows switch1
cookie=0x0, duration=8.949s, table=0, n_packets=0, n_bytes=0, idle_age=8, priority=65535,udp,in_port=4,vlan_tci=0x0000,dl_src=44:44:44:44:44:44,dl_dst=11:11:11:11:11:11,nw_src=192.168.0.4,nw_dst=192.168.0.1,nw_tos=0,tp_src=0,tp_dst=0 actions=output:1
cookie=0x0, duration=4.109s, table=0, n_packets=0, n_bytes=0, idle_age=4, priority=65535,udp,in_port=1,vlan_tci=0x0000,dl_src=11:11:11:11:11:11,dl_dst=44:44:44:44:44:44,nw_src=192.168.0.1,nw_dst=192.168.0.4,nw_tos=0,tp_src=0,tp_dst=0 actions=output:4
$ ./bin/trema dump_flows switch5
cookie=0x0, duration=14.230s, table=0, n_packets=0, n_bytes=0, idle_age=14, priority=65535,udp,in_port=5,vlan_tci=0x0000,dl_src=44:44:44:44:44:44,dl_dst=11:11:11:11:11:11,nw_src=192.168.0.4,nw_dst=192.168.0.1,nw_tos=0,tp_src=0,tp_dst=0 actions=output:2
cookie=0x0, duration=9.320s, table=0, n_packets=0, n_bytes=0, idle_age=9, priority=65535,udp,in_port=2,vlan_tci=0x0000,dl_src=11:11:11:11:11:11,dl_dst=44:44:44:44:44:44,nw_src=192.168.0.1,nw_dst=192.168.0.4,nw_tos=0,tp_src=0,tp_dst=0 actions=output:5
$ ./bin/trema dump_flows switch6
cookie=0x0, duration=18.688s, table=0, n_packets=0, n_bytes=0, idle_age=18, priority=65535,udp,in_port=1,vlan_tci=0x0000,dl_src=44:44:44:44:44:44,dl_dst=11:11:11:11:11:11,nw_src=192.168.0.4,nw_dst=192.168.0.1,nw_tos=0,tp_src=0,tp_dst=0 actions=output:2
cookie=0x0, duration=13.723s, table=0, n_packets=0, n_bytes=0, idle_age=13, priority=65535,udp,in_port=2,vlan_tci=0x0000,dl_src=11:11:11:11:11:11,dl_dst=44:44:44:44:44:44,nw_src=192.168.0.1,nw_dst=192.168.0.4,nw_tos=0,tp_src=0,tp_dst=0 actions=output:1</screen>
<simpara>たしかに switch1, switch5, switch6 それぞれについて、host1 と host4 間の 2 つの最短パス用のフローエントリが設定されています。</simpara>
<simpara>一方で、最短パス上にない switch2, switch3, switch4 はパケットが通らないため、次のようにフローエントリがありません。</simpara>
<screen>$ ./bin/trema dump_flows switch2

$ ./bin/trema dump_flows switch3

$ ./bin/trema dump_flows switch4</screen>
</section>
<section xml:id="_最短パスの再計算を確認する">
<title>最短パスの再計算を確認する</title>
<simpara>トポロジ上のリンクが切れた場合、ルーティングスイッチは自動的に最短パスを作り直します。たとえば<link linkend="routing_switch_sample_network">図 16-5</link> において、switch1 と switch5 の間のリンクが切れた場合を考えます。このときルーティングスイッチは古い最短パス (host1 ⇔ switch1 ⇔ switch5 ⇔ switch6 ⇔ host4) のフローエントリを消します。そして、再び host1 が host2 へパケットを送ったタイミングで、ルーティングスイッチは新しい最短パス (host1 → switch1 → switch4 → switch5 → switch6) を作ります (<link linkend="routing_switch_update_shortest_path">図 16-6</link>)。</simpara>
<figure xml:id="routing_switch_update_shortest_path">
<title>最短パスの作り直し</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/routing_switch/routing_switch_update_shortest_path.png"/>
</imageobject>
<textobject><phrase>routing switch update shortest path</phrase></textobject>
</mediaobject>
</figure>
<simpara>この動作も実際に動かして確認してみましょう。リンクの削除は <literal>trema delete_link</literal> コマンドです。</simpara>
<screen>$ ./bin/trema delete_link switch1 switch5</screen>
<simpara>すると、ルーティングスイッチを起動したターミナルには host1 ⇔ host4 の 2 つの最短パスを削除したというメッセージが表示されます。</simpara>
<screen>Deleting path: 44:44:44:44:44:44 -&gt; 0x6:1 -&gt; 0x6:2 -&gt; 0x5:5 -&gt; 0x5:2 -&gt; 0x1:4 -&gt; 0x1:1 -&gt; 11:11:11:11:11:11
Deleting path: 11:11:11:11:11:11 -&gt; 0x1:1 -&gt; 0x1:4 -&gt; 0x5:2 -&gt; 0x5:5 -&gt; 0x6:2 -&gt; 0x6:1 -&gt; 44:44:44:44:44:44</screen>
<simpara>再び host1 から host4 へパケットを送ってみましょう。</simpara>
<screen>$ ./bin/trema send_packets --source host1 --dest host4</screen>
<simpara>すると次のように、ルーティングスイッチを起動したターミナルには host1 → host4 の新たな最短パスが表示されます。</simpara>
<screen>Creating path: 11:11:11:11:11:11 -&gt; 0x1:1 -&gt; 0x1:3 -&gt; 0x4:2 -&gt; 0x4:3 -&gt; 0x5:4 -&gt; 0x5:5 -&gt; 0x6:2 -&gt; 0x6:1 -&gt; 44:44:44:44:44:44</screen>
<simpara>以上でルーティングスイッチの最短パス計算と再計算の動作を見てきました。いよいよソースコードを読んでみましょう。</simpara>
</section>
</section>
<section xml:id="_ルーティングスイッチのソースコード">
<title>ルーティングスイッチのソースコード</title>
<simpara>ルーティングスイッチは次の 4 つのクラスが協調して動作します (<link linkend="routing_switch_classes">図 16-7</link>)。</simpara>
<variablelist>
<varlistentry>
<term>RoutingSwitch クラス</term>
<listitem>
<simpara>スイッチから届く OpenFlow メッセージを振り分けます。OpenFlow スイッチと接続し、スイッチから上がってくる OpenFlow メッセージをその種類に応じて Topology または PathManager へと振り分けます</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>TopologyController, Topology クラス (<link linkend="topology">15 章</link>で紹介)</term>
<listitem>
<simpara>トポロジの変化イベントを PathManager へ通知します。トポロジ情報の変化に関連する OpenFlow メッセージを RoutingSwitch から受け取り、ネットワークトポロジ上のイベントへ変換し PathManager へ渡します</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PathManager クラス</term>
<listitem>
<simpara>ルーティングスイッチの本体です。RoutingSwitch から Packet In メッセージを受け取ると、Topology から受け取るトポロジ情報を元に最短パスを計算し、Path クラスを通じて新しい最短パスをスイッチに反映します</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Path クラス</term>
<listitem>
<simpara>パスの生成と削除に必要なフローエントリの操作を一手に引き受けます。FlowMod や FlowModDelete といった OpenFlow メッセージの詳細を PathManager から隠蔽します</simpara>
</listitem>
</varlistentry>
</variablelist>
<figure xml:id="routing_switch_classes">
<title>ルーティングスイッチのクラス構成</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/routing_switch/routing_switch_classes.png"/>
</imageobject>
<textobject><phrase>routing switch classes</phrase></textobject>
</mediaobject>
</figure>
<simpara>複雑な機能を持つコントローラは、このように機能を小さなクラスに分割することでスッキリと書けます。LLDP の送受信といったトポロジ検出処理は Topology クラスに、FlowMod といったフローエントリの処理は Path クラスにそれぞれまかせ、そして PathManager クラスが全体をとりまとめることで見通しが良くなりテストもしやすくなります。もし新しく機能を追加したくなった場合にも、既存のコードは改造せず新機能に対応するクラスを追加するだけです<footnote><simpara><link linkend="sliceable_switch">16 章</link>ではルーティングスイッチにクラスを追加することで仮想ネットワーク機能を実装する例を紹介します。</simpara></footnote>。</simpara>
<section xml:id="_routingswitch_クラスのソースコード_routing_switch_rb">
<title>RoutingSwitch クラスのソースコード (routing_switch.rb)</title>
<simpara>RoutingSwitch クラスは委譲パターンによって各 OpenFlow メッセージを他のクラスへと振り分けます。</simpara>
<formalpara>
<title>lib/routing_switch.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">delegate :switch_ready, to: :@topology
delegate :features_reply, to: :@topology
delegate :switch_disconnected, to: :@topology
delegate :port_modify, to: :@topology

def packet_in(dpid, packet_in)
  @topology.packet_in(dpid, packet_in)
  @path_manager.packet_in(dpid, packet_in) unless packet_in.lldp?
end</programlisting>
</para>
</formalpara>
<simpara>たとえば Topology クラスへ switch_ready イベントを転送するには、<literal>delegate</literal> メソッドを使って Topology クラスのインスタンスへ <literal>switch_ready</literal> メソッドを委譲します。なお packet_in イベントは Topology と PathManager の両方に届ける必要があるため、packet_in ハンドラの中で明示的にそれぞれの packet_in メソッドを呼び出すことで転送しています。</simpara>
</section>
<section xml:id="_pathmanager_のソースコード_path_manager_rb">
<title>PathManager のソースコード (path_manager.rb)</title>
<simpara>PathManager は、Topology クラスとObserverパターンで連携します。TopologyクラスはRoutingSwitchクラスから上がってくる生のOpenFlowメッセージをトポロジ上の変化イベント(スイッチ・ポート・リンクの追加/削除とホストの追加)へと変換し、オブザーバである PathManager クラスのトポロジイベントハンドラを呼び出します。</simpara>
<formalpara>
<title>PathManager クラスのトポロジイベントハンドラ (lib/path_manager.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def add_port(port, _topology)
  @graph.add_link port.dpid, port
end

def delete_port(port, _topology)
  @graph.delete_node port
end

# TODO: update all paths
def add_link(port_a, port_b, _topology)
  @graph.add_link port_a, port_b
end

def delete_link(port_a, port_b, _topology)
  @graph.delete_link port_a, port_b
  Path.find { |each| each.link?(port_a, port_b) }.each(&amp;:destroy)
end

def add_host(mac_address, port, _topology)
  @graph.add_link mac_address, port
end</programlisting>
</para>
</formalpara>
<simpara>PathManager はトポロジイベントを受け取ると、インスタンス変数 <literal>@graph</literal> として持つ現在のネットワークグラフを更新します。たとえばLLDPによって新しいリンクを発見すると、Topology はトポロジイベント <literal>add_link</literal> を PathManager へ送ります。そして PathManager は新しく見つかったリンクを <literal>@graph</literal> へ追加します。</simpara>
<simpara>PathManager は <literal>packet_in</literal> イベントに反応し、届いたパケットを宛先へと届けます。</simpara>
<formalpara>
<title>PathManager#packet_in</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in(_dpid, packet_in)
  path = maybe_create_shortest_path(packet_in)
  ports = path ? [path.out_port] : @graph.external_ports
  ports.each do |each|
    send_packet_out(each.dpid,
                    raw_data: packet_in.raw_data,
                    actions: SendOutPort.new(each.number))
  end
end

def maybe_create_shortest_path(packet_in)
  shortest_path =
    @graph.dijkstra(packet_in.source_mac, packet_in.destination_mac)
  return unless shortest_path
  Path.create shortest_path, packet_in
end</programlisting>
</para>
</formalpara>
<simpara><literal>packet_in</literal> ハンドラの動作は<link linkend="path_manager_internals">図 16-6</link> の通りです:</simpara>
<figure xml:id="path_manager_internals">
<title>PathManager の仕組み</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/routing_switch/path_manager_internals.png"/>
</imageobject>
<textobject><phrase>path manager internals</phrase></textobject>
</mediaobject>
</figure>
<orderedlist numeration="arabic">
<listitem>
<simpara>グラフ情報から送信元→宛先への最短パスを計算する。もし最短パスが見つかった場合には、最短パス上のスイッチにフローエントリを <literal>Path.create</literal> で打つ</simpara>
</listitem>
<listitem>
<simpara>最短パスが見つかった場合には、宛先ポートにPacketOutすることでPacketInを起こしたパケットを宛先へ届ける。見つからなかった場合には、パケットをすべての外部ポート (外部と接続しているポート) へPacketOutする</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_path_のソースコード_path_rb">
<title>Path のソースコード (path.rb)</title>
<simpara>Path クラスはパスの生成と削除に必要なフローエントリの操作を一手に引き受けます。たとえば、パスを生成するメソッド <literal>Path.create</literal> の実装は次のようになっています:</simpara>
<formalpara>
<title>Path.create (lib/path.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def self.create(shortest_path, packet_in)
  new.save(shortest_path, packet_in).tap { |new_path| all &lt;&lt; new_path }
end

def save(full_path, packet_in)
  @full_path = full_path
  @packet_in = packet_in
  logger.info 'Creating path: ' + @full_path.map(&amp;:to_s).join(' -&gt; ')
  flow_mod_add_to_each_switch
  self
end

def flow_mod_add_to_each_switch
  path.each_slice(2) do |in_port, out_port|
    send_flow_mod_add(out_port.dpid,
                      match: exact_match(in_port.number),
                      actions: SendOutPort.new(out_port.number))
  end
end</programlisting>
</para>
</formalpara>
<simpara>PathManager が <literal>Path.create</literal> を呼び出すと、<literal>Path</literal> クラスのインスタンスメソッド <literal>save</literal> を呼び出します。<literal>save</literal> メソッドでは最短パスに沿ってフローエントリを <literal>flow_mod_add_to_each_switch</literal> メソッドでスイッチに書き込みます。</simpara>
</section>
</section>
<section xml:id="_openflow_を使う利点">
<title>OpenFlow を使う利点</title>
<simpara>本章のはじめで説明したように、ルーティングスイッチは OpenFlow ネットワークを 1 台の仮想的なスイッチとして動作させるコントローラです。普通のスイッチを真似るだけならば、わざわざ OpenFlow を使わなくてもよいのでは? と思うかもしれません。ここでは、OpenFlow を使った場合の利点について考えてみたいと思います。</simpara>
<section xml:id="_リンク帯域を有効活用できる">
<title>リンク帯域を有効活用できる</title>
<simpara>通常のスイッチで構成されたネットワークでは、パケットのループを防ぐためにスパニングツリープロトコルでリンクの一部を遮断します。たとえば、<link linkend="spt1">図 16-7</link>のようなループを含むネットワークでスパニングツリープロトコルを使うと、スイッチ2とスイッチ3間のリンクが遮断されループが解消します。このとき、たとえばホスト2からホスト3へのパケットは、この遮断されたリンクを通過できないため、スイッチ1を経由して転送します。これは明かに無駄な回り道で、せっかくのリンク帯域が無駄になっています。</simpara>
<figure xml:id="spt1">
<title>スパニングツリーではループを避けるために一部のリンクを遮断する</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/routing_switch/spt1.png"/>
</imageobject>
<textobject><phrase>spt1</phrase></textobject>
</mediaobject>
</figure>
<simpara>一方、ルーティングスイッチではコントローラがトポロジ全体を把握しているため、ループを防ぐためのリンク遮断は必要ありません。パケットの転送経路を各スイッチにフローエントリとして明示的に指示するため、ループを含むトポロジであっても問題なく動作します。このためスパニングツリーを使う場合と比べて、ネットワーク中のリンクを有効に使えます（<link linkend="spt2">図 16-8</link>）。</simpara>
<figure xml:id="spt2">
<title>ルーティングスイッチではネットワーク中のリンクを有効に使える</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/routing_switch/spt2.png"/>
</imageobject>
<textobject><phrase>spt2</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_いろいろなパス選択アルゴリズムを使える">
<title>いろいろなパス選択アルゴリズムを使える</title>
<simpara>パスの決定はコントローラで一括して行なうため、パス決定アルゴリズムを入れ替えるだけで、さまざまなパス選択を実現できます。今回、ルーティングスイッチではダイクストラ法による最短パスを使いましたが、たとえば<link linkend="multipath">図 16-9</link>のようにフロー毎に異なるパスを設定することで、帯域確保のためのマルチパスを作ることも簡単にできます。</simpara>
<figure xml:id="multipath">
<title>OpenFlowでは最短でないパスを含んだマルチパスを自由に作れる</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/routing_switch/multipath.png"/>
</imageobject>
<textobject><phrase>multipath</phrase></textobject>
</mediaobject>
</figure>
<simpara>このようなマルチパスは従来の自律分散型でも実現できますが、厳しい制限があります。IETFが標準化を行うTRILL（Transparent Interconnect of Lots of Links）や IEEE が標準化を行う SPB（Shortest Path Bridges）は、マルチパス転送に対応しています。しかし、マルチパス転送を使えるのは、最短パスが複数ある場合<footnote><simpara>このようなパスを、イコールコストマルチパス（Equal Cost Multipath）と呼びます。</simpara></footnote>だけです。最短ではないパスは、ループを起こす可能性があるため使えません。また最短パスが1本だけの場合にもマルチパスにできません。</simpara>
</section>
</section>
<section xml:id="_まとめ_16">
<title>まとめ</title>
<simpara>いくつものスイッチからなるネットワークを扱える、ルーティングスイッチの動作を見てきました。この章で学んだことを簡単にまとめておきましょう。</simpara>
<itemizedlist>
<listitem>
<simpara>パケットを最短パスで宛先まで届ける方法。ダイクストラ法を使って最短パスを求め、最短パス上のスイッチにフローエントリを書き込む</simpara>
</listitem>
<listitem>
<simpara>複数のクラスを連携しコントローラを実装する方法。メソッドの移譲やオブザーバーパターンを使い、機能ごとに分割したクラスを組み合わせる</simpara>
</listitem>
<listitem>
<simpara>OpenFlowを使う場合の利点。すべてのリンクを使うことで帯域を有効活用できるほか、マルチパスなどのパス選択アルゴリズムを自由に使える</simpara>
</listitem>
</itemizedlist>
<simpara>次の章では、ネットワーク仮想化を実現する本格的なコントローラの一例として、ルーティングスイッチを発展させたスライス機能付きスイッチを見ていきます。</simpara>
<section xml:id="_参考文献_3">
<title>参考文献</title>
<itemizedlist>
<listitem>
<simpara>『最短経路の本——レナのふしぎな数学の旅』（Peter Gritzmann、Rene Brandenberg 著／シュプリンガー・ジャパン） 最短経路を題材にしたストーリ仕立てのグラフ理論入門書です。本章ではネットワーク上での最短パスを求める場合のダイクストラ法を紹介しましたが、リンクに重みがある場合の一般的なダイクストラ法についてはこの本がおすすめです。</simpara>
</listitem>
<listitem>
<simpara>『マスタリングTCP/IP 応用編』（Philip Miller 著／オーム社 とくにレイヤ3の経路制御プロトコルについて詳しく説明した本です。ダイクストラ法を用いた経路制御プロトコルの1つであるOSPFについても説明しているので、ルーティングスイッチとの違いを比べてみるのもおもしろいでしょう。</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="sliceable_switch">
<title>ネットワークを仮想化する</title>
<simpara role="lead">IaaS (Infrastructure as a Service) の構築に必要な大規模ネットワークを OpenFlow で実現しましょう。<link linkend="routing_switch">16 章</link>で紹介したルーティングスイッチの応用です。</simpara>
<section xml:id="_ネットワークをスライスに分ける">
<title>ネットワークをスライスに分ける</title>
<simpara>クラウドサービスの核となる機能は仮想化です。たとえばクラウドサービスの一種である IaaS は、サーバやネットワークといった物理リソースを仮想化し、まるで雲 (クラウド) のように大きな仮想リソースとしてユーザに提供します。ユーザは自分専用のリソースをこの仮想リソースプールからいつでも好きなときに借り出せます。</simpara>
<simpara>クラウドサービスが制御する物理リソースのうち、ネットワークの仮想化は OpenFlow の得意分野です。物理リソースのうちサーバの仮想化は、Xen などの仮想マシンモニタを使えば、一台のサーバ上に何台もの仮想マシンを起動することで多数のユーザを集約できます。もう1つの物理リソースであるネットワークの仮想化については、後に説明するように OpenFlow コントローラで同様の仕組みを実現できます。この 2 つの組み合わせにより、クラウドサービスは「仮想マシン + 仮想ネットワーク」という専用環境をユーザごとに提供します。</simpara>
<simpara>本章で取り上げる「スライス機能付きスイッチ」は、ネットワークを仮想化するコントローラです (<link linkend="slice">図 17-1</link>)。1つの物理ネットワークをたくさんのスライス、つまりユーザごとの論理的なネットワークに分割することで、たくさんのユーザを1つの物理ネットワーク上に集約できます。</simpara>
<figure xml:id="slice">
<title>スライス機能付きスイッチは 1 つの物理ネットワークをたくさんの独立した仮想ネットワークに分割できる</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/sliceable_switch/slice.png"/>
</imageobject>
<textobject><phrase>slice</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_スライスの実現方法">
<title>スライスの実現方法</title>
<simpara>スライスを実現する代表的な既存技術が VLANです。VLAN はスイッチをポート単位や MAC アドレス単位でスライスに分割できます。また VLAN タグと呼ばれる ID をパケットにつけることでスイッチをまたがったスライスも作れます。</simpara>
<simpara>ただし、VLAN にはスライス数の上限が 4094 個というプロトコル上の制約があります。このため、オフィスなどといった中小規模ネットワークではともかく、IaaS のようにユーザ数がゆうに数万を越える場合には使えません。</simpara>
<simpara>一方 OpenFlow によるスライスではこの制約はありません。フローエントリをうまく使えば、既存の VLAN の仕組みを使わなくてもスライスを実現できるからです。つまり OpenFlow を使えば、「スライス数に制限のない仮想ネットワーク」を作れます。</simpara>
<simpara>スライス機能付きスイッチは OpenFlow によるスライスの実装です。これは<link linkend="routing_switch">15章</link>で紹介したルーティングスイッチを改造することにより、上限なくたくさんのスライスを作れるようにしたものです。また、実際に OpenStack などのクラウド構築ミドルウェアの一部として使うことも考慮しており、REST API を通じてスライスの作成/削除などの操作ができます。</simpara>
</section>
<section xml:id="_インストール_3">
<title>インストール</title>
<simpara>スライス機能付きスイッチを使って、ネットワーク仮想化を実際に試してみましょう。スライス機能付きスイッチのソースコードはルーティングスイッチのリポジトリに入っています。もしルーティングスイッチをまだインストールしていなければ、次のコマンドでインストールしてください。</simpara>
<screen>$ git clone https://github.com/trema/routing_switch.git
$ cd routing_switch
$ bundle install --binstubs</screen>
<section xml:id="_スライス機能付きスイッチを起動する">
<title>スライス機能付きスイッチを起動する</title>
<simpara>スライス機能付きスイッチの動作を確認してみましょう。これまで通り Trema のネットワークエミュレータを用いて、<link linkend="sliceable_switch_network">図 17-2</link> のネットワークを作ります。ルーティングスイッチのソースコードに含まれる設定ファイル (<literal>trema.conf</literal>) を使えば、このネットワーク構成を実現できます。</simpara>
<figure xml:id="sliceable_switch_network">
<title>スライス機能付きスイッチを実行するネットワーク</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/sliceable_switch/sliceable_switch_network.png"/>
</imageobject>
<textobject><phrase>sliceable switch network</phrase></textobject>
</mediaobject>
</figure>
<simpara>スライス機能を有効にするには、ルーティングスイッチの <literal>trema run</literal> に <literal>-- --slicing</literal> オプションを付けてください。</simpara>
<screen>$ ./bin/trema run ./lib/routing_switch.rb -c trema.conf -- --slicing</screen>
<simpara>それでは起動したスライス機能付きスイッチを使って、さっそくいくつかスライスを作ってみましょう。</simpara>
</section>
<section xml:id="_スライスを作る">
<title>スライスを作る</title>
<simpara>スライスの作成には <literal>slice</literal> コマンドを使います。2 枚のスライス <literal>slice1</literal>、 <literal>slice2</literal> を作り、それぞれに 2 台ずつホストを追加してみましょう (<link linkend="creating_slices">図 17-3</link>)。</simpara>
<figure xml:id="creating_slices">
<title>スライスの作成例</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/sliceable_switch/creating_slices.png"/>
</imageobject>
<textobject><phrase>creating slices</phrase></textobject>
</mediaobject>
</figure>
<simpara>スライスの追加は <literal>slice add</literal> コマンドです。</simpara>
<screen>$ ./bin/slice add slice1
$ ./bin/slice add slice2</screen>
<simpara><literal>slice add_host</literal> コマンドでスライスにホストを追加します。<literal>host1</literal>、<literal>host4</literal> のポートと MAC アドレスを <literal>slice1</literal> に、<literal>host2</literal> と <literal>host3</literal> を <literal>slice2</literal> に、それぞれ追加します。</simpara>
<screen>$ ./bin/slice add_host --port 0x1:1 --mac 11:11:11:11:11:11 --slice slice1
$ ./bin/slice add_host --port 0x6:1 --mac 44:44:44:44:44:44 --slice slice1
$ ./bin/slice add_host --port 0x4:1 --mac 22:22:22:22:22:22 --slice slice2
$ ./bin/slice add_host --port 0x5:1 --mac 33:33:33:33:33:33 --slice slice2</screen>
<simpara>ネットワークがスライスにうまく分割できているか、パケットを送って確認してみましょう。</simpara>
</section>
<section xml:id="_スライスを確認する">
<title>スライスを確認する</title>
<simpara>スライスが正しく動作しているか確認するには、次の 2 つを試せば OK です。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>同じスライスに属するホスト間で通信できること</simpara>
</listitem>
<listitem>
<simpara>異なるスライスに属するホスト間で通信できないこと</simpara>
</listitem>
</orderedlist>
<simpara>これは今までやってきた通り、<literal>trema send_packet</literal> と <literal>trema show_stats</literal> コマンドで簡単に確認できます。たとえば同じスライス <literal>slice1</literal> に属するホスト <literal>host1</literal> と <literal>host4</literal> で通信できることを確認するには、お互いにパケットを 1 つずつ送信し、それぞれのホストでパケットを 1 つずつ受信できているかどうかを見ます。</simpara>
<screen>$ ./bin/trema send_packet --source host1 --dest host4
$ ./bin/trema send_packet --source host4 --dest host1
$ ./bin/trema show_stats host1
Packets sent:
  192.168.0.1 -&gt; 192.168.0.4 = 1 packet
Packets received:
  192.168.0.4 -&gt; 192.168.0.1 = 1 packet
$ ./bin/trema show_stats host4
Packets sent:
  192.168.0.4 -&gt; 192.168.0.1 = 1 packet
Packets received:
  192.168.0.1 -&gt; 192.168.0.4 = 1 packet</screen>
<simpara>たしかに問題なく通信できています。それでは異なるスライス間での通信はどうでしょう。同様に調べてみましょう。</simpara>
<screen>$ ./bin/trema reset_stats host1
$ ./bin/trema send_packet --source host1 --dest host2
$ ./bin/trema send_packet --source host2 --dest host1
$ ./bin/trema show_stats host1
Packets sent:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
$ ./bin/trema show_stats host2
Packets sent:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet</screen>
<simpara>たしかに、<literal>slice1</literal> の <literal>host1</literal> から <literal>slice2</literal> の <literal>host2</literal> へのパケットは届いていません。以上から、1 つのネットワークが 2 つの独立したスライスにうまく分割できていることが確認できました。</simpara>
</section>
</section>
<section xml:id="_rest_api_を使う">
<title>REST API を使う</title>
<simpara>スライス機能付きスイッチは OpenStack などのミドルウェアと連携するための REST API を提供しています。REST API はプログラミング言語を問わず使えるため、スライス機能付きスイッチの持つ仮想ネットワーク機能をさまざまなミドルウェアに簡単に組込めます。</simpara>
<simpara>スライス機能付きスイッチの REST API は Ruby の HTTP サーバ実装である WEBrick で動作します （<link linkend="rest_overview">図17-4</link>)。WEBrick に「スライスの作成」や「ホストの追加」といったリクエストを HTTP で送ると、WEBrick はリクエスト内容をスライス機能付きスイッチ経由でネットワークへと反映します。また、現在のスライスやホストの状態も同様に REST API 経由で取得できます。</simpara>
<figure xml:id="rest_overview">
<title>スライス機能付きスイッチの REST API 構成</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/sliceable_switch/rest_overview.png"/>
</imageobject>
<textobject><phrase>rest overview</phrase></textobject>
</mediaobject>
</figure>
<simpara>REST API の起動は次のコマンドです。スライス機能付きスイッチを起動した後に <literal>rackup</literal> コマンドで WEBrick を起動します。</simpara>
<screen>$ ./bin/trema run ./lib/routing_switch.rb -c trema.conf -d -- --slicing
$ ./bin/rackup</screen>
<simpara>それでは実際にいくつか REST API を試してみましょう。</simpara>
<section xml:id="_rest_api_でスライスを作る">
<title>REST API でスライスを作る</title>
<simpara>REST API 経由でスライスを作るには、スライスの情報が入った JSON を HTTP POST で REST サーバに送ります。たとえば yutaro_slice という名前のスライスを作る JSON は次の通りです。</simpara>
<screen>{"name": "yutaro_slice"}</screen>
<simpara>次にこの JSON を /slices という URI に HTTP POST メソッドで送ります。<literal>curl</literal> コマンドを使えば、次のように手軽に REST サーバとやりとりできます。なお REST サーバである WEBrick のデフォルト待ち受けポートは 9292 です。</simpara>
<screen>$ curl -sS -X POST -d ’{"name": "yutaro_slice"}’ 'http://localhost:9292/slices' -H Content-Type:application/json -v</screen>
<simpara>成功すると次のようにスライスの作成成功を示す HTTP ステータスコード 201 が返ってきます。</simpara>
<screen>* Hostname was NOT found in DNS cache
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 9292 (#0)
&gt; POST /slices HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:9292
&gt; Accept: */*
&gt; Content-Type:application/json
&gt; Content-Length: 21
&gt;
* upload completely sent off: 21 out of 21 bytes
&lt; HTTP/1.1 201 Created <co xml:id="CO30-1"/>
&lt; Content-Type: application/json
&lt; Content-Length: 21
* Server WEBrick/1.3.1 (Ruby/2.0.0/2014-10-27) is not blacklisted
&lt; Server: WEBrick/1.3.1 (Ruby/2.0.0/2014-10-27)
&lt; Date: Mon, 30 Mar 2015 08:15:22 GMT
&lt; Connection: Keep-Alive
&lt;
* Connection #0 to host localhost left intact
{"name": "yutaro_slice"}</screen>
<calloutlist>
<callout arearefs="CO30-1">
<para>スライス作成成功を示す HTTP ステータスコード 201</para>
</callout>
</calloutlist>
</section>
<section xml:id="_スライスにホストを追加する">
<title>スライスにホストを追加する</title>
<simpara>作ったスライスにはホストを追加できます。追加するホストを指定するには、ホストのつながっているスイッチの dpid とポート番号、そしてホストの MAC アドレスを使います。これをホスト追加の URI である <literal>/slices/:slice_id/ports/:port_id/mac_addresses</literal> に HTTP POST メソッドで送ります。たとえば、スライス <literal>yutaro_slice</literal> に dpid = 0x1, ポート番号 = 1, MAC アドレス = 11:11:11:11:11:11 のホストを追加するコマンドは次のようになります。</simpara>
<screen>$ curl -sS -X POST -d ’{"name": "11:11:11:11:11:11"}’ 'http://localhost:9292/slices/yutaro_slice/ports/0x1:1/mac_addresses' -H Content-Type:application/json -v</screen>
<simpara>次のようにホスト追加の成功を示す HTTP ステータスコード 201 が返ってくれば成功です。</simpara>
<screen>[{"name": "11:11:11:11:11:11"}]
* Hostname was NOT found in DNS cache
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 9292 (#0)
&gt; POST /slices/foo/ports/0x1:1/mac_addresses HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:9292
&gt; Accept: */*
&gt; Content-Type:application/json
&gt; Content-Length: 29
&gt;
} [data not shown]
* upload completely sent off: 29 out of 29 bytes
&lt; HTTP/1.1 201 Created <co xml:id="CO31-1"/>
&lt; Content-Type: application/json
&lt; Content-Length: 31
* Server WEBrick/1.3.1 (Ruby/2.0.0/2014-10-27) is not blacklisted
&lt; Server: WEBrick/1.3.1 (Ruby/2.0.0/2014-10-27)
&lt; Date: Tue, 31 Mar 2015 00:20:45 GMT
&lt; Connection: Keep-Alive
&lt;
{ [data not shown]
* Connection #0 to host localhost left intact</screen>
<calloutlist>
<callout arearefs="CO31-1">
<para>ホスト追加成功を示す HTTP ステータスコード 201</para>
</callout>
</calloutlist>
</section>
<section xml:id="_スライスの構成を見る">
<title>スライスの構成を見る</title>
<simpara>これまでの設定がきちんと反映されているか確認してみましょう。<literal>/slices/:slice_id/ports</literal> に HTTP GET メソッドでアクセスすることで、スライスに追加したポート一覧を取得できます。先ほど作った <literal>slice_yutaro</literal> スライスの情報を取得してみましょう<footnote><simpara><literal>curl</literal> の出力を短くするために、冗長オプション (<literal>-v</literal>) は省略しています</simpara></footnote>。</simpara>
<screen>$ curl -sS -X GET 'http://localhost:9292/slices/yutaro_slice/ports'
[{"name": "0x1:1", "dpid": 1, "port_no": 1}]</screen>
<simpara>たしかに、スライス <literal>yutaro_slice</literal> にはスイッチ <literal>0x1</literal> のポート 1 番が追加されています。このポートに接続した <literal>host1</literal> の情報は <literal>/slices/:slice_id/ports/:port_id/mac_addresses</literal> で取得できます。</simpara>
<screen>$ curl -sS -X GET 'http://localhost:9292/slices/yutaro_slice/ports/0x1:1/mac_addresses'
[{"name": "11:11:11:11:11:11"}]</screen>
</section>
</section>
<section xml:id="_rest_api_一覧">
<title>REST API 一覧</title>
<simpara>REST API は今回紹介した以外にも API を提供しています (<link linkend="rest_api_table">表 17-1</link>)。やりとりする JSON データ等の詳しい仕様は <link xl:href="https://relishapp.com/trema/routing-switch/docs/rest-api">https://relishapp.com/trema/routing-switch/docs/rest-api</link> で公開していますので、本格的に使いたい人はこちらも参照してください。</simpara>
<table xml:id="rest_api_table" frame="all" rowsep="1" colsep="1">
<title>表 17-1: REST API 一覧</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">動作</entry>
<entry align="left" valign="top">メソッド</entry>
<entry align="left" valign="top">URI</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>スライスの作成</simpara></entry>
<entry align="left" valign="top"><simpara>POST</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/slices</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>スライスの削除</simpara></entry>
<entry align="left" valign="top"><simpara>DELETE</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/slices/:slice_id</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>スライスの一覧</simpara></entry>
<entry align="left" valign="top"><simpara>GET</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/slices</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>スライス情報の取得</simpara></entry>
<entry align="left" valign="top"><simpara>GET</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/slices/:slice_id</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ポートの追加</simpara></entry>
<entry align="left" valign="top"><simpara>POST</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/slices/:slice_id/ports</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ポートの削除</simpara></entry>
<entry align="left" valign="top"><simpara>DELETE</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/slices/:slice_id/ports/:port_id</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ポートの一覧</simpara></entry>
<entry align="left" valign="top"><simpara>GET</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/slices/:slice_id/ports</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ポート情報の取得</simpara></entry>
<entry align="left" valign="top"><simpara>GET</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/slices/:slice_id/ports/:port_id</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MAC アドレスの追加</simpara></entry>
<entry align="left" valign="top"><simpara>POST</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/slices/:slice_id/ports/:port_id/mac_addresses</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MAC アドレスの削除</simpara></entry>
<entry align="left" valign="top"><simpara>DELETE</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/slices/:slice_id/ports/:port_id/mac_addresses/:mac_address_id</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MAC アドレスの一覧</simpara></entry>
<entry align="left" valign="top"><simpara>GET</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/slices/:slice_id/ports/:port_id/mac_addresses</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="_スライス機能付きスイッチの実装">
<title>スライス機能付きスイッチの実装</title>
<simpara>実はスライス機能は、<link linkend="routing_switch">15章</link>で説明したルーティングスイッチへのほんの少しの改造だけで実現しています。コントローラとOpenFlowスイッチの視点で見ると、スライス機能付きスイッチは次のように動作します（<link linkend="sliceable_switch_internals">図17-5</link>）。</simpara>
<figure xml:id="sliceable_switch_internals">
<title>スライス機能付きスイッチの動作</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/sliceable_switch/sliceable_switch_internals.png"/>
</imageobject>
<textobject><phrase>sliceable switch internals</phrase></textobject>
</mediaobject>
</figure>
<orderedlist numeration="arabic">
<listitem>
<simpara>ホスト 1 がホスト 4 宛てにパケットを送信すると、ルーティングスイッチはこのパケットを Packet In としてスイッチ 1 から受け取る (この Packet In の in_port をポート s とする)</simpara>
</listitem>
<listitem>
<simpara>ルーティングスイッチはあらかじめ収集しておいたトポロジ情報 (<link linkend="topology">14章</link>) を検索し、宛先のホスト 4 が接続するスイッチ (スイッチ 6) とポート番号 (ポート g とする) を得る</simpara>
</listitem>
<listitem>
<simpara>ポート s とポート g が同じスライスに属するか判定する。もし同じスライスではない場合にはパケットを捨て、以降の処理は行わない</simpara>
</listitem>
<listitem>
<simpara>ポート s から宛先のポート g までの最短パスをトポロジ情報から計算する。その結果、ポート s → スイッチ 1 → スイッチ 5 → スイッチ 6 → ポート g というパスを得る</simpara>
</listitem>
<listitem>
<simpara>この最短パスに沿ってパケットを転送するフローエントリを書き込むために、ルーティングスイッチはパス上のスイッチそれぞれに Flow Mod を送る</simpara>
</listitem>
<listitem>
<simpara>Packet In を起こしたパケットを宛先に送るために、ルーティングスイッチはスイッチ 6 に Packet Out (ポート g) を送る</simpara>
</listitem>
</orderedlist>
<simpara>スライス機能付きスイッチがルーティングスイッチと異なるのは、ステップ 3 を追加した点だけです。ステップ 3 では送信元と宛先ホストがそれぞれ同じスライスに属しているかを判定し、同じスライスに所属している場合のみパケットを転送します。それ以外はルーティングスイッチとまったく同じです。</simpara>
</section>
<section xml:id="_スライス機能付きスイッチのソースコード">
<title>スライス機能付きスイッチのソースコード</title>
<simpara>スライス機能は、ルーティングスイッチに次の新たなクラス 2 個を追加することで実現しています (<link linkend="sliceable_switch_classes">図 17-6</link>)。</simpara>
<variablelist>
<varlistentry>
<term>PathInSliceManager クラス</term>
<listitem>
<simpara>スライス内のパスを管理するコントローラの本体</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Slice クラス</term>
<listitem>
<simpara>スライスを管理する</simpara>
</listitem>
</varlistentry>
</variablelist>
<figure xml:id="sliceable_switch_classes">
<title>スライス機能付きスイッチを構成するクラス</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/sliceable_switch/sliceable_switch_classes.png"/>
</imageobject>
<textobject><phrase>sliceable switch classes</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_pathinslicemanager_クラス">
<title>PathInSliceManager クラス</title>
<simpara>PathInSliceManager クラスは <literal>packet_in</literal> ハンドラでパケットの送信元と宛先が同じスライスに属するかどうかを判定します。それ以外の動作は PathManager クラスと同じなので、PathInSliceManager は PathManager を継承し <literal>packet_in</literal> ハンドラだけをオーバーライドします。</simpara>
<formalpara>
<title>PathInSliceManager#packet_in</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def packet_in(_dpid, packet_in)
  slice = Slice.find do |each|
    each.member?(packet_in.slice_source) &amp;&amp;
    each.member?(packet_in.slice_destination(@graph))
  end
  ports = if slice
            path = maybe_create_shortest_path_in_slice(slice.name, packet_in)
            path ? [path.out_port] : []
          else
            external_ports(packet_in)
          end
  packet_out(packet_in.raw_data, ports)
end</programlisting>
</para>
</formalpara>
<simpara>Packet In メッセージが PathInSliceManager へ到着すると、PathInSliceManager は次の方法でパケットを宛先へと届けます。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>パケットの送信元 MAC アドレスと宛先 MAC アドレスが同じスライスに属するかどうか判定する。もし同じスライスだった場合には、PathManager と同様に最短パスを作り宛先ホストへパケットを届ける</simpara>
</listitem>
<listitem>
<simpara>もし同じスライスでなかった場合、パケットをすべての外部ポート (スライス機能付きスイッチが管理するスイッチ以外と接続した全てのポート) へ PacketOut する。つまり、スライスに属していないホストへとばらまく<footnote><simpara>この処理からわかるように、スライスに属していないホスト同士はデフォルトで通信できる仕様になっています</simpara></footnote></simpara>
</listitem>
</orderedlist>
<simpara>ステップ 1 で使っている <literal>Slice.find</literal> メソッド (パケットの送信元と宛先が同じスライスに属するかどうか) といったスライスに関わる処理は、次の <literal>Slice</literal> クラスが行います。</simpara>
</section>
<section xml:id="_slice_クラス">
<title>Slice クラス</title>
<simpara>Slice クラスはスライスの管理クラスです。スライスの追加・削除や検索といったクラスメソッドのほか、スライスへのポートやホストの追加・削除といった機能を提供します。</simpara>
<simpara>たとえば先ほど使った <literal>Slice.find</literal> メソッドは、スライスの一覧 (<literal>all</literal>) に対して同じ <literal>find</literal> メソッドを呼び出すだけです。</simpara>
<formalpara>
<title>スライスの検索 (lib/slice.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def self.find(&amp;block)
  all.find(&amp;block)
end</programlisting>
</para>
</formalpara>
<simpara>スライスの追加メソッド <literal>Slice.create</literal> は指定した名前でスライスを作成します。最初に、すでに同じ名前のスライスがないかどうかを <literal>Slice.find_by</literal> で確認します。そして、スライスオブジェクトを <literal>Slice.new</literal> で作ります。作ったスライスはスライス一覧 (<literal>all</literal>) に追加します。</simpara>
<formalpara>
<title>スライスの追加 (lib/slice.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def self.create(name)
  if find_by(name: name)
    fail SliceAlreadyExistsError, "Slice #{name} already exists"
  end
  new(name).tap { |slice| all &lt;&lt; slice }
end</programlisting>
</para>
</formalpara>
<simpara><literal>Slice.destroy</literal> は <literal>create</literal> の逆で、スライスの削除メソッドです。最初に、削除しようとした名前のスライスがあるかどうかを <literal>Slice.find_by!</literal> で確認します。そして、削除するスライスに属する最短パス (<literal>Path</literal> オブジェクト) を削除します。最後に、そのスライスをスライス一覧 <literal>all</literal> から消します。</simpara>
<formalpara>
<title>スライスの削除 (lib/slice.rb)</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">def self.destroy(name)
  find_by!(name: name)
  Path.find { |each| each.slice == name }.each(&amp;:destroy)
  all.delete_if { |each| each.name == name }
end</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="_まとめ_17">
<title>まとめ</title>
<simpara>Hello Trema から始めた Trema プログラミングも、いつの間にか本格的なクラウド用ネットワークを作れるまでになりました！</simpara>
<itemizedlist>
<listitem>
<simpara>スライス機能付きスイッチが同一のスライス内の通信のみを許可する仕組み</simpara>
</listitem>
<listitem>
<simpara>クラウド構築ミドルウェアからスライスを設定するためのREST APIの使い方</simpara>
</listitem>
</itemizedlist>
<simpara>次章では、Trema を使った仮想ネットワークソフトウェアであり、商用クラウドにも使われている OpenVnet を紹介します。本章で解説したスライス機能付きスイッチとはまったく異なる「分散 Trema」とも言えるスライスの実現方法は、商用クラウドの作り方として参考になります。</simpara>
</section>
</chapter>
<chapter xml:id="openvnet">
<title>OpenVNetで本格的な仮想ネットワーク</title>
<simpara role="lead">OpenVNetはTremaで構築された本格的な仮想ネットワーク基盤です。実際のデータセンターでも使える仮想ネットワークを体験しましょう。</simpara>
<section xml:id="_openvnetとは">
<title>OpenVNetとは</title>
<simpara>OpenVNetはOpenFlowで仮想ネットワークを構築するためのフリーソフトウェアです。Tremaを使ってあらゆるパケットの挙動を自由に制御することで、既存のネットワーク上にあたかもユーザ専用のネットワークがあるかのような環境を作り出すことができます。開発はWSF(Wakame Software Foundation)が中心となっており、筆者の一人である山崎の所属する株式会社あくしゅの開発者がメインコミッターを務めています。ソフトウェアライセンスにLGPLv3を採用し、組織の枠を越えたオープンソースでの開発を行っています。</simpara>
<simpara>OpenVNetはもともと、WSFのプロジェクトの 1 つであるWakame-vdcからネットワーク機能を切り出したものです。Wakame-vdcはデータセンター全体を仮想化するためのソフトウェアで、すでにいくつもの企業や研究機関で商業化や実用化が進んでいます。</simpara>
<itemizedlist>
<listitem>
<simpara>国立情報学研究所 (NII): 分散処理の実証実験、クラウド教育教材として活用</simpara>
</listitem>
<listitem>
<simpara>九州電力: 大規模データの分散処理基盤として</simpara>
</listitem>
<listitem>
<simpara>NTT PCコミュニケーションズ: パブリッククラウド WebARENA VPSクラウド</simpara>
</listitem>
<listitem>
<simpara>京セラコミュニケーションシステム: パブリッククラウド GreenOffice Unified Cloud</simpara>
</listitem>
<listitem>
<simpara>TIS株式会社: OpenVNetのDocker対応とクラウド間連携の実証プロジェクト (後述)</simpara>
</listitem>
</itemizedlist>
<section xml:id="_エッジ仮想化による仮想ネットワーク">
<title>エッジ仮想化による仮想ネットワーク</title>
<simpara>OpenVNetによるネットワーク仮想化の特長は、<emphasis role="strong">エッジ仮想化</emphasis>である点です。エッジ仮想化では、仮想マシンと既存のネットワークとの間にソフトウェアOpenFlowスイッチ(エッジスイッチ)を設置し、ここで全てのパケットを制御します。これによって、仮想マシンからは、あたかも独立したネットワークがあるかのように見えます。</simpara>
<simpara>エッジスイッチの主な仕事は、物理ネットワークと仮想ネットワーク間でのパケットの相互書き換えです。</simpara>
<figure xml:id="edge_network_virtualization">
<title>エッジ仮想化によるネットワークの仮想化</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openvnet/edge_translation.png"/>
</imageobject>
<textobject><phrase>edge translation</phrase></textobject>
</mediaobject>
</figure>
<orderedlist numeration="arabic">
<listitem>
<simpara>仮想マシンから仮想ネットワークに送信したパケットは、エッジスイッチが物理ネットワークを通るように書き換え、宛先のサーバへ送出する</simpara>
</listitem>
<listitem>
<simpara>宛先のサーバに届く直前のエッジスイッチで逆の書き換えを行う。つまり、物理ネットワークを通ってきたパケットを仮想ネットワーク内のパケットに見えるように書き換える</simpara>
</listitem>
</orderedlist>
<simpara>こうしたエッジスイッチによるパケットの書き換えは仮想マシンからは見えません。OpenVNetの作り出した仮想ネットワークが、仮想マシンからは物理ネットワークであるかのように見えます。</simpara>
<simpara>エッジ仮想化のもう一つの大きな利点は、OpenFlow化されていない既存のネットワーク上で動作することです。たとえば <link linkend="sliceable_switch">第17章「ネットワークを仮想化する」</link> で紹介したスライサブルスイッチには、ネットワークスイッチがすべてOpenFlowに対応しているという前提がありました。一方エッジ仮想化では、この制御を物理サーバ上に起動したエッジスイッチだけで行います。こうすることで、既に構築されたネットワークの上で仮想ネットワークを実現できます。</simpara>
</section>
</section>
<section xml:id="_エッジ仮想化の利点">
<title>エッジ仮想化の利点</title>
<simpara>OpenVNetのようなエッジ仮想化は、次の2つの場面で特に威力を発揮します。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>既存ネットワークの活用</simpara>
</listitem>
<listitem>
<simpara>ダウンサイジング</simpara>
</listitem>
</orderedlist>
<section xml:id="_既存ネットワークの活用">
<title>既存ネットワークの活用</title>
<simpara>最小の変更だけで既存データセンター上に仮想ネットワークサービスを構築できます。エッジ仮想化によるネットワーク仮想化はほぼ物理サーバの追加だけで実現できます。このため、物理ネットワークの新たな敷設や再設定をできるだけ抑えながら、その上に新しく仮想ネットワークを構築して提供できます。</simpara>
</section>
<section xml:id="_ダウンサイジング">
<title>ダウンサイジング</title>
<simpara>古い大量の物理スイッチを仮想ネットワーク化することで一掃できます。近年のネットワーク帯域向上により、物理ネットワークの仮想環境への詰め込みが一般的になってきました。たとえば単純計算しただけでも、10Gbpsの物理ネットワークには10Mbpsの仮想ネットワークを100個ほど詰め込めます。さらに、ネットワーク利用率のばらつきを考慮し効率的に設計すれば、より多くを集約できます。</simpara>
</section>
</section>
<section xml:id="_openvnetの全体アーキテクチャ">
<title>OpenVNetの全体アーキテクチャ</title>
<simpara>OpenVNetのアーキテクチャは非常にシンプルです。データセンタ全体のネットワークの構成を管理するのが、vnmgr(Virtual Network Manager)です。vnmgrはグローバルな仮想ネットワーク設定情報を元に、分散するvna(Virtual Network Agent)に対して、エッジスイッチを設定するよう指示します。個々の vna は Trema を使ったコントローラとして実装しており、それぞれが担当するエッジスイッチへとフローエントリを書き込みます。</simpara>
<figure xml:id="openvnet_architecture">
<title>OpenVNetの全体アーキテクチャ</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openvnet/openvnet_architecture.png"/>
</imageobject>
<textobject><phrase>openvnet architecture</phrase></textobject>
</mediaobject>
</figure>
<simpara>OpenVNetはTrema以外にも、定評のあるフリーソフトウェアをコンポーネントとして利用しています。エッジスイッチとして動作するソフトウェアスイッチ、グローバルな仮想ネットワーク設定情報を管理するデータベース、そして vnmgr と vna 間のメッセージングには、それぞれ次のソフトウェアを採用しています。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">コンポーネント</entry>
<entry align="left" valign="top">実装</entry>
<entry align="left" valign="top">URL</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>OpenFlow スイッチ</simpara></entry>
<entry align="left" valign="top"><simpara>Open vSwitch</simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="http://openvswitch.org/">http://openvswitch.org/</link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>設定情報データベース</simpara></entry>
<entry align="left" valign="top"><simpara>MySQL</simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="http://www.mysql.com/">http://www.mysql.com/</link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>メッセージング</simpara></entry>
<entry align="left" valign="top"><simpara>ZeroMQ &amp; Redis</simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="http://zeromq.org/">http://zeromq.org/</link> <link xl:href="http://redis.io/">http://redis.io/</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_openvnetの主な機能">
<title>OpenVNetの主な機能</title>
<simpara>OpenVNetは仮想ネットワーク以外にも、次の 4 つの強力な機能を持っています。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>仮想ルータによる仮想ネットワーク接続</simpara>
</listitem>
<listitem>
<simpara>セキュリティグループによる仮想ファイアウォール機能</simpara>
</listitem>
<listitem>
<simpara>DHCPとDNSサービス</simpara>
</listitem>
<listitem>
<simpara>仮想ネットワークと既存ネットワークの接続</simpara>
</listitem>
</orderedlist>
<section xml:id="_仮想ルータによる仮想ネットワーク間接続">
<title>仮想ルータによる仮想ネットワーク間接続</title>
<simpara>OpenVNet上に作成した２つ以上の仮想ネットワークの間を自由に相互接続できます。これにより、２つの異なる仮想ネットワークに接続する仮想マシン同士が通信できるようになります。これはちょうど、仮想ネットワークの間にルータを仮想的に配置するようなものです。</simpara>
<figure xml:id="route_between_vnets">
<title>仮想ルータによる仮想ネットワーク間接続</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openvnet/route_between_vnets.png"/>
</imageobject>
<textobject><phrase>route between vnets</phrase></textobject>
</mediaobject>
</figure>
<simpara>この仮想ルータ機能は、すべてエッジスイッチのフローによって実現しています。仮想マシン間のパケットは余計なネットワーク経路を辿らず、エッジスイッチ間で最適な通信をします。</simpara>
</section>
<section xml:id="_セキュリティグループによる仮想ファイアウォール機能">
<title>セキュリティグループによる仮想ファイアウォール機能</title>
<simpara>エッジスイッチは各仮想マシンのトラフィック全ての関所でもあります。セキュリティグループは、この関所にパケットの受け入れ許可ルールを指定し、仮想マシンのファイアウォールとして機能させるものです。</simpara>
<figure xml:id="sequrity_groups">
<title>セキュリティグループ間の仮想ファイアウォール機能</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openvnet/sequrity_groups.png"/>
</imageobject>
<textobject><phrase>sequrity groups</phrase></textobject>
</mediaobject>
</figure>
<simpara>セキュリティグループは、このファイアウォール設定を仮想的なグループ間の通信に設定できます。仮想ファイアウォールの設定をエッジスイッチのフローエントリへと自動変換することで、グループ間の適切な通信ルールを制御します。</simpara>
</section>
<section xml:id="_dhcpとdnsサービス">
<title>DHCPとDNSサービス</title>
<simpara>DHCPやDNSなどのサービスをエッジスイッチとコントローラだけで処理できます。これにより、新たにDHCPサーバなどを立てなくてもソフトウェア的に各種ネットワークサービスを提供できます。</simpara>
<figure xml:id="dhcp">
<title>DHCPサービスをエッジスイッチとvnaで実現</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openvnet/dhcp.png"/>
</imageobject>
<textobject><phrase>dhcp</phrase></textobject>
</mediaobject>
</figure>
<simpara>たとえばDHCPの場合、DHCP関係のパケットはエッジスイッチでマッチさせ、vnaにエスカレーションします。vnaはDHCPの返信パケットを生成し仮想マシンへ直接返答します。この機能は、仮想マシンに割り振るIPアドレスが自明である場合に利用できます。</simpara>
</section>
<section xml:id="_仮想ネットワークと外部ネットワークとの接続">
<title>仮想ネットワークと外部ネットワークとの接続</title>
<simpara>OpenVNetで作った仮想ネットワークを、外部のネットワークと接続する機能を VNetEdge と呼びます。2つのネットワーク境界にあるエッジスイッチ上のフローを使って、ネットワーク間でパケットの相互転送を行います。</simpara>
<simpara>VNetEdgeでは、トランスレーションと呼ぶルールに従ってパケットの相互転送を行います。例えば、特定のVLANタグを持ったパケットを任意の仮想ネットワークへ転送したり、特定のIPアドレス宛のパケットを仮想ネットワーク内の任意のIPアドレスへ変換したりできます。</simpara>
</section>
</section>
<section xml:id="_使ってみる">
<title>使ってみる</title>
<simpara>OpenVNetの利用はとても簡単です。実行に必要なものは次の2つだけです。</simpara>
<itemizedlist>
<listitem>
<simpara>CentOS 6.6以上(CentOS6系)が稼働する物理または仮想マシン</simpara>
</listitem>
<listitem>
<simpara>インターネット接続</simpara>
</listitem>
</itemizedlist>
<figure xml:id="openvnet_installation_overview">
<title>1台のマシンで動作するOpenVNet環境</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openvnet/openvnet_installation_overview.png"/>
</imageobject>
<textobject><phrase>openvnet installation overview</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_インストールしてみる">
<title>インストールしてみる</title>
<simpara>OpenVNetのインストールと初期設定は、以下の手順で進めます。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>OpenVNetのインストール</simpara>
</listitem>
<listitem>
<simpara>RedisとMySQLのインストール</simpara>
</listitem>
<listitem>
<simpara>エッジスイッチの設定</simpara>
</listitem>
<listitem>
<simpara>各種サービスの起動</simpara>
</listitem>
</orderedlist>
<section xml:id="_openvnetのインストール">
<title>OpenVNetのインストール</title>
<simpara>OpenVNetは <literal>yum</literal> パッケージとして提供されています。リポジトリの設定ファイルである <literal>openvnet.repo</literal> を <literal>/etc/yum/repos.d/</literal> ディレクトリに次のようにダウンロードします。</simpara>
<screen>$ sudo curl -o /etc/yum.repos.d/openvnet.repo -R https://raw.githubusercontent.com/axsh/openvnet/master/deployment/yum_repositories/stable/openvnet.repo</screen>
<simpara>次に、OpenVNetで利用するミドルウェアパッケージをまとめらたリポジトリ設定ファイル <literal>openvnet-third-party.repo</literal> を <literal>/etc/yum.repos.d/</literal> ディレクトリにダウンロードします。</simpara>
<screen>$ sudo curl -o /etc/yum.repos.d/openvnet-third-party.repo -R https://raw.githubusercontent.com/axsh/openvnet/master/deployment/yum_repositories/stable/openvnet-third-party.repo</screen>
<simpara>加えて、OpenVNetのインストールに必要なエンタープライズLinux用の拡張パッケージである <literal>epel-release</literal> パッケージをインストールしておきます。</simpara>
<screen>$ sudo yum install -y epel-release</screen>
<simpara>ここまで完了したら、OpenVNetパッケージをインストールします。<literal>openvnet</literal> パッケージはメタパッケージで、OpenVNetの動作に必要なパッケージを一度に全てインストールできます。</simpara>
<screen>$ sudo yum install -y openvnet</screen>
</section>
<section xml:id="_redisとmysqlのインストール">
<title>RedisとMySQLのインストール</title>
<simpara>RedisおよびMySQL serverパッケージをインストールします。OpenVNetは、Redisをプロセス間通信ミドルウェアとして、またMySQLをネットワーク構成情報のデータベースとして利用します。</simpara>
<screen>$ sudo yum install -y mysql-server redis</screen>
</section>
<section xml:id="_エッジスイッチの設定">
<title>エッジスイッチの設定</title>
<simpara><literal>br0</literal> という名前のエッジスイッチを作成します。後の疎通確認では、 <literal>inst1</literal> および <literal>inst2</literal> という2つの仮想マシンをこのエッジスイッチに接続します。 <literal>br0</literal> の設定ファイルとして、 <literal>/etc/sysconfig/network-scripts/ifcfg-br0</literal> を、以下の内容で作成します。</simpara>
<screen>DEVICE=br0
DEVICETYPE=ovs
TYPE=OVSBridge
ONBOOT=yes
BOOTPROTO=static
HOTPLUG=no
OVS_EXTRA="
 set bridge     ${DEVICE} protocols=OpenFlow10,OpenFlow12,OpenFlow13 --
 set bridge     ${DEVICE} other_config:disable-in-band=true --
 set bridge     ${DEVICE} other-config:datapath-id=0000aaaaaaaaaaaa --
 set bridge     ${DEVICE} other-config:hwaddr=02:01:00:00:00:01 --
 set-fail-mode  ${DEVICE} standalone --
 set-controller ${DEVICE} tcp:127.0.0.1:6633
"</screen>
<simpara>なお、この設定では <literal>datapath-id</literal> を <literal>0000aaaaaaaaaaaa</literal> という値に設定しています。この値はOpenVNetがエッジスイッチを認識するための一意な識別子で、16進数の値を設定できます。後ほど利用する値ですので、覚えておいて下さい。</simpara>
</section>
<section xml:id="_各種サービスの起動">
<title>各種サービスの起動</title>
<simpara>次のコマンドで <literal>openvswitch</literal> サービスとエッジスイッチを起動します。</simpara>
<screen>$ sudo service openvswitch start
$ sudo ifup br0</screen>
<simpara>ネットワーク構成情報を保持するデータベースとして、MySQL serverを起動します。</simpara>
<screen>$ sudo service mysqld start</screen>
<simpara>OpenVNetは、OpenVNetと同時にインストールされるRubyを利用しますので、環境変数PATHにそのパスを設定しておきます。</simpara>
<screen>$ PATH=/opt/axsh/openvnet/ruby/bin:${PATH}</screen>
<simpara>次に、構成情報のためのデータベースの作成を行います。</simpara>
<screen>$ cd /opt/axsh/openvnet/vnet
$ bundle exec rake db:create
$ bundle exec rake db:init</screen>
<simpara>OpenVNetの各サービス間の通信に使うRedisを起動します。</simpara>
<screen>$ service redis start</screen>
<simpara>OpenVNetのサービス群 (<literal>vnmgr</literal> 、 <literal>webapi</literal> 、 <literal>vna</literal>) を起動します。</simpara>
<screen>$ sudo initctl start vnet-vnmgr
$ sudo initctl start vnet-webapi</screen>
<simpara><literal>vnctl</literal> ユーティリティで構成情報データベースを作成します。次のコマンドで、<literal>vna</literal> が管理するエッジスイッチの Datapath ID をOpenVNetに教えます。</simpara>
<screen>$ vnctl datapaths add --uuid dp-test1 --display-name test1 --dpid 0x0000aaaaaaaaaaaa --node-id vna</screen>
<simpara><literal>vna</literal> と Datapath ID の紐付けができたので、 <literal>vna</literal> を起動してみましょう。</simpara>
<screen>$ sudo initctl start vnet-vna</screen>
<simpara><literal>ovs-vsctl</literal> コマンドで、 <literal>vna</literal> が正しく動作しているかを確認できます。</simpara>
<screen>$ ovs-vsctl show
fbe23184-7f14-46cb-857b-3abf6153a6d6
    Bridge "br0"
        Controller "tcp:127.0.0.1:6633"
            is_connected: true</screen>
<simpara>ここで、 <literal>is_connected: true</literal> の文字列が見えていれば、 <literal>vna</literal> は正しく動作しています。</simpara>
<simpara>次に仮想マシンとして2つの仮想マシン( <literal>inst1</literal> と <literal>inst2</literal> )を作成し、OpenVNetの仮想ネットワークに接続してみます。起動する仮想マシンの種類として、今回は軽量なコンテナの一種であるLXCを使います。</simpara>
<screen>$ sudo yum -y install lxc lxc-templates</screen>
<simpara><literal>lxc</literal> および <literal>lxc-templates</literal> パッケージのインストールが完了したら、コンテナのリソース制御を行う <literal>cgroup</literal> を設定します。</simpara>
<screen>$ sudo mkdir /cgroup
$ echo "cgroup /cgroup cgroup defaults 0 0" &gt;&gt; /etc/fstab
$ sudo mount /cgroup</screen>
<simpara>仮想マシン作成コマンドである <literal>lxc-create</literal> が利用する <literal>rsync</literal> をインストールします。</simpara>
<screen>$ sudo yum install -y rsync</screen>
<simpara>LXCの動作の準備が出来ましたので、いよいよ仮想マシン <literal>inst1</literal>、<literal>inst2</literal> を作成します。</simpara>
<screen>$ sudo lxc-create -t centos -n inst1
$ sudo lxc-create -t centos -n inst2</screen>
<simpara><literal>lxc-create</literal> を実行すると、それぞれの仮想マシンの <literal>root</literal> ユーザのパスワードが入ったファイル名を出力します。このパスワードは後で仮想マシンにログインする際に利用しますので、覚えておいて下さい。</simpara>
<simpara>次に、仮想マシンのネットワークインタフェースの設定を行います。 <literal>/var/lib/lxc/inst1/config</literal> ファイルを開き、内容を以下で置き換えて下さい。</simpara>
<screen>lxc.network.type = veth
lxc.network.flags = up
lxc.network.veth.pair = inst1
lxc.network.hwaddr = 10:54:FF:00:00:01
lxc.rootfs = /var/lib/lxc/inst1/rootfs
lxc.include = /usr/share/lxc/config/centos.common.conf
lxc.arch = x86_64
lxc.utsname = inst1
lxc.autodev = 0</screen>
<simpara>同様に、 <literal>/var/lib/lxc/inst2/config</literal> ファイルを開き、内容を以下で置き換えます。</simpara>
<screen>lxc.network.type = veth
lxc.network.flags = up
lxc.network.veth.pair = inst2
lxc.network.hwaddr = 10:54:FF:00:00:02
lxc.rootfs = /var/lib/lxc/inst2/rootfs
lxc.include = /usr/share/lxc/config/centos.common.conf
lxc.arch = x86_64
lxc.utsname = inst2
lxc.autodev = 0</screen>
<simpara>設定ファイルの内容を置き換えたら、仮想マシンを起動します。</simpara>
<screen>$ sudo lxc-start -d -n inst1
$ sudo lxc-start -d -n inst2</screen>
<simpara>仮想マシンが起動したら、その仮想マシンのネットワークインタフェースを先程設定したエッジスイッチに手動で接続します。これは、ちょうどネットワークケーブルを物理スイッチに挿入する操作に対応します。</simpara>
<screen>$ sudo ovs-vsctl add-port br0 inst1
$ sudo ovs-vsctl add-port br0 inst2</screen>
<simpara>これで、OpenVNetのインストールと、OpenVNetの仮想ネットワークを体験する準備が整いました。ここまでの操作では、何もない物理ネットワークと繋がるエッジスイッチに仮想マシンが接続しただけの状態です。</simpara>
<figure xml:id="openvnet_connected">
<title>仮想マシンがエッジスイッチに接続した状態</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openvnet/openvnet_connected.png"/>
</imageobject>
<textobject><phrase>openvnet connected</phrase></textobject>
</mediaobject>
</figure>
<simpara>では、最も基本的な仮想ネットワークを1つ作成をしてみましょう。</simpara>
</section>
</section>
<section xml:id="_cliで仮想ネットワークを操作する">
<title>CLIで仮想ネットワークを操作する</title>
<simpara>仮想ネットワークの操作はすべて <literal>vnctl</literal> コマンドで行います。まずは、1つの仮想ネットワークを作成してみましょう。</simpara>
<simpara>作成する仮想ネットワークのアドレスを <literal>10.100.0.0/24</literal> とし、 <literal>inst1</literal> のIPアドレスを <literal>10.100.0.10</literal>、<literal>inst2</literal> のIPアドレスを <literal>10.100.0.11</literal> とします。次の <literal>vnctl networks</literal> コマンドでこのネットワークを作成できます。</simpara>
<screen>$ vnctl networks add \
  --uuid nw-test1 \
  --display-name testnet1 \
  --ipv4-network 10.100.0.0 \
  --ipv4-prefix 24 \
  --network-mode virtual</screen>
<figure xml:id="openvnet_cli_simplenetwork_1">
<title>仮想ネットワークの作成</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openvnet/openvnet_cli_simplenetwork_1.png"/>
</imageobject>
<textobject><phrase>openvnet cli simplenetwork 1</phrase></textobject>
</mediaobject>
</figure>
<simpara>次に、どのネットワークインタフェースがどの仮想ネットワークに所属しているのかを <literal>vnctl</literal> コマンドでOpenVNetに教えます。 これは、 <literal>vnctl interfaces</literal> コマンドで実行できます。まずは、 <literal>inst1</literal> の持つネットワークインタフェースを仮想ネットワークに設定します。</simpara>
<screen>$ vnctl interfaces add \
  --uuid if-inst1 \
  --mode vif \
  --owner-datapath-uuid dp-test1 \
  --mac-address 10:54:ff:00:00:01 \
  --network-uuid nw-test1 \
  --ipv4-address 10.100.0.10 \
  --port-name inst1</screen>
<simpara>同様に、 <literal>inst2</literal> の持つネットワークインタフェースを仮想ネットワークに設定します。</simpara>
<screen>vnctl interfaces add \
  --uuid if-inst2 \
  --mode vif \
  --owner-datapath-uuid dp-test1 \
  --mac-address 10:54:ff:00:00:02 \
  --network-uuid nw-test1 \
  --ipv4-address 10.100.0.11 \
  --port-name inst2</screen>
<simpara>この操作により、OpenVNetは <literal>10.100.0.0/24</literal> の仮想ネットワークを作成し、そこにそれぞれ <literal>10.100.0.10</literal> 、 <literal>10.100.0.11</literal> のIPアドレスを持つネットワークインタフェースを接続します。</simpara>
<figure xml:id="openvnet_cli_simplenetwork_2">
<title>ネットワークインタフェースにIPアドレスを設定した状態</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openvnet/openvnet_cli_simplenetwork_2.png"/>
</imageobject>
<textobject><phrase>openvnet cli simplenetwork 2</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_疎通確認をする">
<title>疎通確認をする</title>
<simpara>作成した2つの仮想マシンが仮想ネットワークを通じて疎通できることを確認します。まず <literal>inst1</literal> にログインし、IPアドレスを確認してみます。</simpara>
<screen>$ lxc-console -n inst1
$ ip addr show</screen>
<simpara>この時点ではまだ <literal>inst1</literal> の <literal>eth0</literal> にIPアドレスを設定していないため、IPアドレスが表示されません。作った仮想ネットワークではDHCPサービスを有効にしていないため、IPアドレスは手動で設定する必要があります。</simpara>
<simpara><literal>inst1</literal> のコンソールにて次のコマンドを実行し、 <literal>eth0</literal> にIPアドレス <literal>10.100.0.10</literal> を設定します。これは、 <literal>vnctl</literal> で設定した <literal>inst1</literal> のネットワークインタフェースのIPアドレスと同じにする必要があります。</simpara>
<screen>$ ip addr add 10.100.0.10/24 dev eth0</screen>
<simpara>もう1つ端末を開き、 <literal>inst2</literal> に対し同じ操作を行います。<literal>inst2</literal> の <literal>eth0</literal> に設定するIPアドレスは、 <literal>10.100.0.11</literal> です。</simpara>
<screen>$ lxc-console -n inst2
$ ip addr add 10.100.0.11/24 dev eth0</screen>
<simpara>これで2つの仮想マシンそれぞれに仮想ネットワーク内のIPアドレスを設定できました。</simpara>
<figure xml:id="openvnet_cli_simplenetwork_3">
<title>ネットワークインタフェースにIPアドレスを設定</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openvnet/openvnet_cli_simplenetwork_3.png"/>
</imageobject>
<textobject><phrase>openvnet cli simplenetwork 3</phrase></textobject>
</mediaobject>
</figure>
<simpara>それでは、お互いに <literal>ping</literal> を実行してみます。まずは、 <literal>inst2</literal> から <literal>inst1</literal> に <literal>ping</literal> を実行します。</simpara>
<screen>$ ping 10.100.0.10</screen>
<simpara>うまく行った場合、pingは正しく動作し、疎通が確認できるはずです。もしうまく動作しない場合は、ここまでの手順を確認してみて下さい。</simpara>
<simpara>疎通できるようになったところで、従来のネットワークとOpenVNetの仮想ネットワークとの興味深い違いを1つ紹介しておきましょう。先ほど <literal>inst2</literal> の <literal>eth0</literal> に設定したIPアドレスを、 <literal>10.100.0.11/24</literal> から <literal>10.100.0.15/24</literal> に変更してみましょう。</simpara>
<screen>$ sudo ip addr del 10.100.0.11/24 dev eth0
$ sudo ip addr add 10.100.0.15/24 dev eth0</screen>
<simpara>設定が終わったら、再び <literal>inst1</literal> に対して <literal>ping</literal> を実行してみます。</simpara>
<screen>$ ping 10.100.0.10</screen>
<simpara>先程とは異なり、疎通ができなくなったはずです。これがもし従来のネットワークだった場合、 <literal>10.100.0.0/24</literal> の範囲内のIPアドレスであれば疎通できます。しかしOpenVNetは設定情報に従って厳格に通信制限を行うため、<literal>inst2</literal> のIPアドレスが <literal>10.100.0.11</literal> でない限り、通信を許可しません。</simpara>
</section>
</section>
<section xml:id="_openvnetを応用した実用例">
<title>OpenVNetを応用した実用例</title>
<simpara>最後にOpenVNetの高度な応用事例として、OpenVNetのDockerコンテナ対応、および複数クラウド間の仮想ネットワークによる連携機能を紹介します。いずれも、著者の所属するTIS株式会社が実証実験を行い、それぞれの成果はフリーソフトウェアとして配布しています。</simpara>
<section xml:id="_複数サーバ上のdockerコンテナを仮想ネットワークで接続する">
<title>複数サーバ上のDockerコンテナを仮想ネットワークで接続する</title>
<simpara>Docker <footnote><simpara>Dockerの詳細は、Dockerの公式ドキュメント(<link xl:href="https://docs.docker.com/)を参照ください">https://docs.docker.com/)を参照ください</link></simpara></footnote> とは、dotCloud社（現Docker社）が自社のパブリックPaaSを実現するために開発したコンテナの一種です。アプリケーションの実行環境を容易に素早く、かつ他の影響を受けないようにして立ち上げるために、Dockerは他から隔離された環境（＝コンテナ）を作り出します。</simpara>
<simpara>Dockerは様々なリソースを隔離しますが、ネットワークもその隔離すべきリソースの一つです。そのためDockerは、ネットワークネームスペースや仮想ネットワークインタフェースを用いて、サーバ内部に他から隔離された仮想ネットワークを作ります。さらに Docker は iptables を使って、この仮想ネットワークを外部と通信できるようにします。</simpara>
<simpara>この方式は、複数のサーバ上でDockerを動作させる場合に問題が生じます。Dockerが作り出す仮想ネットワークはサーバ内に閉じており、異なるサーバで動作しているDockerコンテナ同士が通信できないためです。</simpara>
<simpara>この問題は、DockerにOpenVNetを組み合わせれば、解決できます。Dockerコンテナ同士をOpenVNetの仮想ネットワークで接続すれば、サーバをまたいだDockerコンテナ間が通信できるようになります。さらに、OpenVNetを使うことで、Docker コンテナを繋ぐネットワークに対して、セキュリティグループの機能が使えます。</simpara>
<simpara>例えばある物理ネットワーク上のサーバ2台と、ルータで接続された別の物理ネットワーク上のサーバ1台の合計3つのサーバがあるとします。これらのサーバ上でDockerコンテナを動作させ、それらをOpenVNetの仮想ネットワークで接続することを考えてみましょう。</simpara>
<simpara>まず最初に、各サーバ上にエッジスイッチを立ち上げます。次に、各サーバ上でDockerコンテナを立ち上げ、それらをエッジスイッチに接続します。</simpara>
<simpara>さらに以下の手順でOpenVNetを設定します。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>各エッジスイッチのDatapath IDをOpenVNetに設定する</simpara>
</listitem>
<listitem>
<simpara>各サーバが所属する物理ネットワークの情報をOpenVNetに設定する</simpara>
</listitem>
<listitem>
<simpara>OpenVNetが敷設する仮想ネットワークを定義する</simpara>
</listitem>
<listitem>
<simpara>各サーバの物理ネットワークインタフェースの情報をOpenVNetに設定する</simpara>
</listitem>
<listitem>
<simpara>立ち上げたDockerコンテナの仮想ネットワークインタフェースの情報をOpenVNetに設定する</simpara>
</listitem>
<listitem>
<simpara>OpenVNetが制御するセキュリティグループを定義する</simpara>
</listitem>
<listitem>
<simpara>各仮想ネットワークインタフェースに望みのセキュリティグループを割り当てる</simpara>
</listitem>
<listitem>
<simpara>OpenVNet上に仮想ルータを構成して、物理ネットワークと仮想ネットワーク間のルーティングを定義する</simpara>
</listitem>
</orderedlist>
<simpara>最後に各サーバとDockerコンテナにスタティックルートを設定すれば、OpenVNetを用いたDockerネットワーキングが完成します。</simpara>
<simpara>各サーバ上のDockerコンテナは、OpenVNetが作った一つの仮想ネットワークに接続していますので、異なるサーバのDockerコンテナ同士が通信できます。またセキュリティグループの機能を使えば、OpenVNet が到達すべきでないパケットを遮断するため、個々のDockerコンテナにパケットフィルタルールを定義する必要がなくなります。</simpara>
<figure>
<title>OpenVNetを用いたDockerネットワーキング</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openvnet/docker_openvnet_1.png"/>
</imageobject>
<textobject><phrase>docker openvnet 1</phrase></textobject>
</mediaobject>
</figure>
<simpara>なお、ここで説明した手順を実行するツールキットを、walfisch <footnote><simpara><link xl:href="https://github.com/tech-sketch/walfisch">https://github.com/tech-sketch/walfisch</link></simpara></footnote> というフリーソフトウェアとして公開しています。実際に実行したコマンドが標準出力に表示されますので、興味がある方は一度動作させてみると良いでしょう。</simpara>
</section>
<section xml:id="_複数のクラウドを仮想ネットワークで連結する">
<title>複数のクラウドを仮想ネットワークで連結する</title>
<simpara>OpenVNetはDockerコンテナ間を連結するというミクロな機能だけでなく、複数のクラウド間を連結するというマクロな機能も提供します。</simpara>
<simpara>現在様々なクラウドが利用可能ですが、提供されるネットワーク機能やその利用方法はクラウドごとに大きく異なります。このため複数のクラウド間を連結したい場合、それぞれのクラウドのネットワーク機能を強く意識したネットワーク設計を行う必要があります。</simpara>
<simpara>OpenVNetは、OpenVNetの仮想ネットワークと外部のネットワークの間をシームレスに接続するVNetEdge機能を持っています。そのためOpenVNetを利用することで、クラウドごとに異なるネットワーク機能に依存せず、複数のクラウドをシームレスに連携できます。</simpara>
<simpara>例えば、プライベートクラウドとしてWakame-vdc、パブリッククラウドとしてAmazon Web Servicesのネットワークを連結するケースを考えます。</simpara>
<figure xml:id="narukozaka_tools">
<title>プライベートIaaSとパブリックIaaSの連結構成</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/openvnet/narukozaka_tools.png"/>
</imageobject>
<textobject><phrase>narukozaka tools</phrase></textobject>
</mediaobject>
</figure>
<simpara>VNetEdgeはこの連結を次のように実現しています。まず、仮想ネットワークIDとVLAN IDの変換規則をOpenVNetに登録します。そして、Wakame-vdcの仮想ネットワークと、Amazon Web ServicesのVirtual Private Cloudで構築されたネットワークの間を流れるパケットがVNetEdgeのエッジスイッチを通過する際に、この２つのネットワークが同一のネットワークであるかのようにパケット転送を制御します。</simpara>
<simpara>このツールキットはフリーソフトウェアとして公開しており <footnote><simpara><link xl:href="https://github.com/cloudconductor-incubator/narukozaka-tools">https://github.com/cloudconductor-incubator/narukozaka-tools</link></simpara></footnote>、複数のクラウド間を連結する以外にも多くの機能を持ちます。</simpara>
<itemizedlist>
<listitem>
<simpara>wakame-vdcとパブリックIaaSの間を自動的に連結する機能</simpara>
</listitem>
<listitem>
<simpara>IaaSのネットワーク上に、VNetEdgeをスイッチとしたスター型のネットワークトポロジを構築する機能</simpara>
</listitem>
<listitem>
<simpara>Wakame-vdc側のインスタンスとAmazon Web Services側のインスタンスのVNetEdge間の通信の暗号化</simpara>
</listitem>
<listitem>
<simpara>IaaSのインスタンスイメージの作成と起動</simpara>
</listitem>
<listitem>
<simpara>IaaSのインスタンスにインストールするミドルウェアの自動設定</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_まとめ_18">
<title>まとめ</title>
<simpara>Tremaで構築された本格的な仮想ネットワーク基盤である OpenVNet を紹介しました。</simpara>
<itemizedlist>
<listitem>
<simpara>OpenVNet はエッジ仮想化であるため、既存の物理ネットワークをほぼそのまま活用して、仮想ネットワークを実現できる</simpara>
</listitem>
<listitem>
<simpara>オンプレミス環境以外にも、AWSに代表されるパブリッククラウドでも利用できる</simpara>
</listitem>
<listitem>
<simpara>仮想マシンだけでなく、Dockerに代表されるコンテナ主体の基盤とも組み合わせて利用できる</simpara>
</listitem>
<listitem>
<simpara>LGPL3ライセンスに基づくフリーソフトウェアであり、オープンな開発コミュニティを持っている</simpara>
</listitem>
</itemizedlist>
<simpara>OpenVNetは、Tremaと同じく開発者を広く募集しています。腕に覚えのある方は、ぜひOpenVNetのホームページ (<link xl:href="http://openvnet.org/">http://openvnet.org/</link>) から開発にご参加ください。</simpara>
</section>
</chapter>
<appendix xml:id="_copyright_and_license">
<title>Copyright and License</title>
<simpara>This book is released under the GNU General Public License version 3.0:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://www.gnu.org/licenses/gpl-3.0.html">http://www.gnu.org/licenses/gpl-3.0.html</link></simpara>
</listitem>
</itemizedlist>
</appendix>
</book>